#include <18F4550.h>

#fuses NOLVP, NOPROTECT, NOMCLR, NOWDT
#use delay(clock = 20M, crystal = 20M)

#include <HDM64GS12.c>

#include <math.h>
#include <stdlibm.h>

#include "setup_disp.h"

#use rs232(rcv=pin_c7,xmit=pin_c6,baud=9600,bits=8,parity=n)


const float internal_angle = (2*(float)PI)/3.0f;   
// dibujar
void glcd_line(int x1, int y1, int x2, int y2, int1 color);
void draw_triangle(int x, int y, float starting_angle, int1 color);
void glcd_lineTracing(int *xx, int *yy, int n_points, int1 color);
void draw_asteroid(int x, int y, int life, int1 color);
void glcd_text57(int x, int y, char* textptr, int size, int1 color);
void inicio(int sec);
void scores(unsigned int16 scr, unsigned int lvl, int1 color);
void single_menu(int1 play);

char dataRS232;

char mode = 'i';
char mode_inic = 't';

int1 flagg = 1;
int1 flag_rec = 0;

int current_data = 0;

unsigned int p1_pot_x = 125;
unsigned int p1_pot_y = 125;
unsigned int p1_pot_xx = 125;
unsigned int p1_pot_yy = 125;
int1 p1_L = 0;
int1 p1_R = 0;

unsigned int p2_pot_x = 125;
unsigned int p2_pot_y = 125;
unsigned int p2_pot_xx = 125;
unsigned int p2_pot_yy = 125;
int1 p2_L = 0;
int1 p2_R = 0;

#int_rda
void rcv_data(){

   dataRS232 = getch();
   
   switch(current_data){
      case 0:
         p1_pot_x = dataRS232;
         break;
      case 1:
         p1_pot_y = dataRS232;
         break;
      case 2:
         p1_pot_xx = dataRS232;
         break;
      case 3:
         p1_pot_yy = dataRS232;
         break;
      case 4:
         p2_pot_x = dataRS232;
         break;
      case 5:
         p2_pot_y = dataRS232;
         break;
      case 6:
         p2_pot_xx = dataRS232;
         break;
      case 7:
         p2_pot_yy = dataRS232;
         break;
      case 8:
         p1_L = (dataRS232 & 0x01) ? 1 : 0;
         p1_R = (dataRS232 & 0x02) ? 1 : 0;
         p2_L = (dataRS232 & 0x04) ? 1 : 0;
         p2_R = (dataRS232 & 0x08) ? 1 : 0;
         break;
   }
   
   current_data++;
   if(current_data == 9)
      current_data = 0;
}

void main(){
      
   enable_interrupts(GLOBAL);
   enable_interrupts(int_rda);

   delay_ms(100);

   glcd_init(ON);
   glcd_fillScreen(0);

   int inic_men = 0;
   int last_inic_men = 0;
   
   int single_men = 0;
   int last_single_men = 0;
   
   inicio(1);

   while(TRUE){
      switch(mode){
         case 'i':{ // inicio
            if(p1_pot_y > 125){
               inic_men = 0;
            }
            else{
               if(p1_pot_x > 125){
                  inic_men = 2;
               }
               else{
                  inic_men = 1;
               }
            }
            
            if(inic_men != last_inic_men){
               glcd_fillScreen(0);
               inicio(inic_men);
            }
            if(p1_R){
               switch(inic_men){
                  case 1:
                     mode = 's';
                     glcd_fillScreen(0);
                     single_menu(1);
                     break;
                  case 2:
                     mode = 'm';
                     glcd_fillScreen(0);
                     break;
                  default:
                     mode = 'i';
                     break;
               }
            }
            
            
            last_inic_men = inic_men;
         break;
         }
         case 's':{ // single
            if(p1_pot_y > 125){
               single_men = 1;
            }
            else{
               single_men = 0;
            }
            
            if(single_men != last_single_men){
               glcd_fillScreen(0);
               single_menu(single_men);
            }
            
            if(p1_L){
               switch(inic_men){
                  case 0:
                     mode = 'i';
                     glcd_fillScreen(0);
                     inicio(1);
                     break;
                  case 1:
                     mode = 'j';
                     glcd_fillScreen(0);
                     break;
               }
            }
            
            last_single_men = single_men;
            break;
         }
         case 'm':{ // multiplayer
            break;
         }
         case 'j':{ // jugnado single
            break;
         }
         case 'J':{ // jugando multiplayer coop
            break;
            }
         case 'p':{ // jugando multiplayer pvp
            break;
         }
         default:{
            break;
         }
      }

            printf("p");
            
   }
}

void glcd_line(int x1, int y1, int x2, int y2, int1 color){
   signed int  x, y, addx, addy, dx, dy;
   signed long P;
   int i;
   dx = abs((signed int)(x2 - x1));
   dy = abs((signed int)(y2 - y1));
   x = x1;
   y = y1;

   if(x1 > x2)
      addx = -1;
   else
      addx = 1;
   if(y1 > y2)
      addy = -1;
   else
      addy = 1;

   if(dx >= dy)
   {
      P = 2*dy - dx;

      for(i=0; i<=dx; ++i)
      {
         glcd_pixel(x, y, color);

         if(P < 0)
         {
            P += 2*dy;
            x += addx;
         }
         else
         {
            P += 2*dy - 2*dx;
            x += addx;
            y += addy;
         }
      }
   }
   else
   {
      P = 2*dx - dy;

      for(i=0; i<=dy; ++i)
      {
         glcd_pixel(x, y, color);

         if(P < 0)
         {
            P += 2*dx;
            y += addy;
         }
         else
         {
            P += 2*dx - 2*dy;
            x += addx;
            y += addy;
         }
      }
   }
}
void glcd_lineTracing(int *xx, int *yy, int n_points, int1 color){
    int i;
    for (i = 0; i < n_points-1; i++) {      // Iterate thru all points, drawing a line between each point
        glcd_line((xx+i),(yy+i),(xx+i+1),(yy+i+1),color);
    }
    glcd_line((xx+i),(yy+i),(xx),(yy),color);
}
void draw_triangle(int x, int y, float starting_angle, int1 color){
   int x_points_on_glcd = (int)malloc(3 * sizeof(int));
   int y_points_on_glcd = (int)malloc(3 * sizeof(int));
   
   for(char i = 0; i < 3; i++){    
       *(x_points_on_glcd+i) = x + (char)((float)5*cos((float)i*internal_angle - starting_angle));
       *(y_points_on_glcd+i) = y + (char)((float)5*sin((float)i*internal_angle - starting_angle));
   }
                                            
   glcd_lineTracing(x_points_on_glcd,y_points_on_glcd,3,color);
   
   free(x_points_on_glcd);
   free(y_points_on_glcd);
}
void draw_asteroid(int x, int y, int life, int1 color){
   int x2 = x + life*8;
   int y2 = y + life*8;
   
   if(x2 > 127){
      glcd_line(x,y,127,y,color);
      glcd_line(0,y,x2-127,y,color);
      if(y2 > 63){
         glcd_line(x,y2-63,127,y2-63,color);
         glcd_line(0,y2-63,x2-127,y2-63,color);

         glcd_line(x,y,x,63,color);
         glcd_line(x,0,x,y2-63,color);
         
         glcd_line(x2-127,y,x2-127,63,color);
         glcd_line(x2-127,0,x2-127,y2-63,color);
      }
      else{
         glcd_line(x,y2,127,y2,color);
         glcd_line(0,y2,x2-127,y2,color);

         glcd_line(x,y,x,y2,color);

         glcd_line(x2-127,y,x2-127,y2,color);
      }
   }
   else{
      glcd_line(x,y,x2,y,color);
      if(y2 > 63){
         glcd_line(x,y2-63,x2,y2-63,color);

         glcd_line(x,y,x,63,color);
         glcd_line(x,0,x,y2-63,color);
         
         glcd_line(x2,y,x2,63,color);
         glcd_line(x2,0,x2,y2-63,color);
      }
      else{
         glcd_line(x,y2,x2,y2,color);

         glcd_line(x,y,x,y2,color);

         glcd_line(x2,y,x2,y2,color);
      }
   }
}

void glcd_text57(int x, int y, char* textptr, int size, int1 color){

   int i, j, k, l, m;                     // Loop counters
   BYTE pixelData[5];                     // Stores character data

   for(i=0; textptr[i] != '\0'; ++i, ++x) // Loop through the passed string
   {
      if(textptr[i] < 'S') // Checks if the letter is in the first text array
         memcpy(pixelData, TEXT[textptr[i]-' '], 5);
      else if(textptr[i] <= '~') // Check if the letter is in the second array
         memcpy(pixelData, TEXT2[textptr[i]-'S'], 5);
      else
         memcpy(pixelData, TEXT[0], 5);   // Default to space

      if(x+5*size >= GLCD_WIDTH)          // Performs character wrapping
      {
         x = 0;                           // Set x at far left position
         y += 7*size + 1;                 // Set y at next position down
      }
      for(j=0; j<5; ++j, x+=size)         // Loop through character byte data
      {
         for(k=0; k<7*size; ++k)          // Loop through the vertical pixels
         {
            if(bit_test(pixelData[j], k)) // Check if the pixel should be set
            {
               for(l=0; l<size; ++l)      // The next two loops change the
               {                          // character's size
                  for(m=0; m<size; ++m)
                  {
                     glcd_pixel(x+m, y+k*size+l, color); // Draws the pixel
                  }
               }
            }
         }
      }
   }
}

void inicio(int sec){
   switch(sec){
      case 1:{
         char text_asteroids[] = "ASTEROIDS";
         glcd_text57(38,4,text_asteroids,1,1);
         
         for(int i = 0; i < 16; i++){
            for(int j = 0; j < 16; j++){
               if(personaje[j][i] == 1){
                  glcd_pixel(20+i,26+j,0);
                  
                  glcd_pixel(82+i,26+j,1);
                  glcd_pixel(96+i,26+j,1);
               }
               else{
                  glcd_pixel(20+i,26+j,1);
                  
                  glcd_pixel(82+i,26+j,0);
                  glcd_pixel(96+i,26+j,0);
               }
            }
         }
      break;
      }
      case 2:{
         char text_asteroids[] = "ASTEROIDS";
         glcd_text57(38,4,text_asteroids,1,1);
         
         for(int i = 0; i < 16; i++){
            for(int j = 0; j < 16; j++){
               if(personaje[j][i] == 1){
                  glcd_pixel(20+i,26+j,1);
                  
                  glcd_pixel(82+i,26+j,0);
                  glcd_pixel(96+i,26+j,0);
               }
               else{
                  glcd_pixel(20+i,26+j,0);
                  
                  glcd_pixel(82+i,26+j,1);
                  glcd_pixel(96+i,26+j,1);
               }
            }
         }
      break;
      }
      default:{
         for(int i = 2; i < 13; i++){
            glcd_line(32,i,97,i,1);
         }
         char text_asteroids[] = "ASTEROIDS";
         glcd_text57(38,4,text_asteroids,1,0);
         
         for(int i = 0; i < 16; i++){
            for(int j = 0; j < 16; j++){
               if(personaje[j][i] == 1){
                  glcd_pixel(20+i,26+j,1);
                  
                  glcd_pixel(82+i,26+j,1);
                  glcd_pixel(96+i,26+j,1);
               }
               else{
                  glcd_pixel(20+i,26+j,0);
                  
                  glcd_pixel(82+i,26+j,0);
                  glcd_pixel(96+i,26+j,0);
               }
            }
         }
      break;
      }
   }
}

void single_menu(int1 play){
   char text_ret[] = "RETURN";
   char text_play[] = "PLAY";
   if(play){
      for(int i = 29; i <= 41;i++){
         glcd_line(20,i,90,i,1);
      }
      glcd_text57(24,30,text_play,1,0);
      
      for(int i = 43; i <= 55;i++){
         glcd_line(20,i,90,i,0);
      }
      glcd_text57(24,44,text_ret,1,1);
   }
   else{
      for(int i = 29; i <= 41;i++){
         glcd_line(20,i,90,i,0);
      }
      glcd_text57(24,30,text_play,1,1);
      
      for(int i = 43; i <= 55;i++){
         glcd_line(20,i,90,i,1);
      }
      glcd_text57(24,44,text_ret,1,0);
   
   }
}

void scores(unsigned int16 scr, unsigned int lvl, int1 color){
   char text_score[6];
   sprintf(text_score, "S:%lu", scr);
   glcd_text57(0, 0, text_score, 1, color);
   char text_level[4];
   sprintf(text_level, "L:%u", lvl);
   glcd_text57(103, 0, text_level, 1, color);
}
