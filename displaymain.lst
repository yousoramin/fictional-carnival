CCS PCH C Compiler, Version 5.112, 5967               22-nov.-24 13:51

               Filename:   C:\Users\Kevin\Desktop\UAQ Auto\Tareas y Trabajos\S4_Microsistemas\videoujuego online\displaymain.lst

               ROM used:   19856 bytes (61%)
                           Largest free fragment is 12908
               RAM used:   609 (30%) at main() level
                           762 (37%) worst case
               Stack used: 5 locations (4 in main + 1 for interrupts)
               Stack size: 31

*
0000:  GOTO   2D24
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.5
0056:  GOTO   0060
005A:  BTFSC  F9E.5
005C:  GOTO   0510
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVFF  15,FF5
009A:  MOVFF  16,FF6
009E:  MOVFF  17,FF7
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... #include <18F4550.h>
.................... //////////// Standard Header file for the PIC18F4550 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F4550
00AE:  CLRF   FF7
00B0:  ADDLW  BE
00B2:  MOVWF  FF6
00B4:  MOVLW  00
00B6:  ADDWFC FF7,F
00B8:  TBLRD*+
00BA:  MOVF   FF5,W
00BC:  RETURN 0
00BE:  DATA 00,00
00C0:  DATA 00,00
00C2:  DATA 00,00
00C4:  DATA 00,5F
00C6:  DATA 00,00
00C8:  DATA 00,03
00CA:  DATA 00,03
00CC:  DATA 00,14
00CE:  DATA 3E,14
00D0:  DATA 3E,14
00D2:  DATA 24,2A
00D4:  DATA 7F,2A
00D6:  DATA 12,43
00D8:  DATA 33,08
00DA:  DATA 66,61
00DC:  DATA 36,49
00DE:  DATA 55,22
00E0:  DATA 50,00
00E2:  DATA 05,03
00E4:  DATA 00,00
00E6:  DATA 00,1C
00E8:  DATA 22,41
00EA:  DATA 00,00
00EC:  DATA 41,22
00EE:  DATA 1C,00
00F0:  DATA 14,08
00F2:  DATA 3E,08
00F4:  DATA 14,08
00F6:  DATA 08,3E
00F8:  DATA 08,08
00FA:  DATA 00,50
00FC:  DATA 30,00
00FE:  DATA 00,08
0100:  DATA 08,08
0102:  DATA 08,08
0104:  DATA 00,60
0106:  DATA 60,00
0108:  DATA 00,20
010A:  DATA 10,08
010C:  DATA 04,02
010E:  DATA 3E,51
0110:  DATA 49,45
0112:  DATA 3E,04
0114:  DATA 02,7F
0116:  DATA 00,00
0118:  DATA 42,61
011A:  DATA 51,49
011C:  DATA 46,22
011E:  DATA 41,49
0120:  DATA 49,36
0122:  DATA 18,14
0124:  DATA 12,7F
0126:  DATA 10,27
0128:  DATA 45,45
012A:  DATA 45,39
012C:  DATA 3E,49
012E:  DATA 49,49
0130:  DATA 32,01
0132:  DATA 01,71
0134:  DATA 09,07
0136:  DATA 36,49
0138:  DATA 49,49
013A:  DATA 36,26
013C:  DATA 49,49
013E:  DATA 49,3E
0140:  DATA 00,36
0142:  DATA 36,00
0144:  DATA 00,00
0146:  DATA 56,36
0148:  DATA 00,00
014A:  DATA 08,14
014C:  DATA 22,41
014E:  DATA 00,14
0150:  DATA 14,14
0152:  DATA 14,14
0154:  DATA 00,41
0156:  DATA 22,14
0158:  DATA 08,02
015A:  DATA 01,51
015C:  DATA 09,06
015E:  DATA 3E,41
0160:  DATA 59,55
0162:  DATA 5E,7E
0164:  DATA 09,09
0166:  DATA 09,7E
0168:  DATA 7F,49
016A:  DATA 49,49
016C:  DATA 36,3E
016E:  DATA 41,41
0170:  DATA 41,22
0172:  DATA 7F,41
0174:  DATA 41,41
0176:  DATA 3E,7F
0178:  DATA 49,49
017A:  DATA 49,41
017C:  DATA 7F,09
017E:  DATA 09,09
0180:  DATA 01,3E
0182:  DATA 41,41
0184:  DATA 49,3A
0186:  DATA 7F,08
0188:  DATA 08,08
018A:  DATA 7F,00
018C:  DATA 41,7F
018E:  DATA 41,00
0190:  DATA 30,40
0192:  DATA 40,40
0194:  DATA 3F,7F
0196:  DATA 08,14
0198:  DATA 22,41
019A:  DATA 7F,40
019C:  DATA 40,40
019E:  DATA 40,7F
01A0:  DATA 02,0C
01A2:  DATA 02,7F
01A4:  DATA 7F,02
01A6:  DATA 04,08
01A8:  DATA 7F,3E
01AA:  DATA 41,41
01AC:  DATA 41,3E
01AE:  DATA 7F,09
01B0:  DATA 09,09
01B2:  DATA 06,1E
01B4:  DATA 21,21
01B6:  DATA 21,5E
01B8:  DATA 7F,09
01BA:  DATA 09,09
01BC:  DATA 76,00
01BE:  CLRF   FF7
01C0:  ADDLW  CE
01C2:  MOVWF  FF6
01C4:  MOVLW  01
01C6:  ADDWFC FF7,F
01C8:  TBLRD*+
01CA:  MOVF   FF5,W
01CC:  RETURN 0
01CE:  DATA 26,49
01D0:  DATA 49,49
01D2:  DATA 32,01
01D4:  DATA 01,7F
01D6:  DATA 01,01
01D8:  DATA 3F,40
01DA:  DATA 40,40
01DC:  DATA 3F,1F
01DE:  DATA 20,40
01E0:  DATA 20,1F
01E2:  DATA 7F,20
01E4:  DATA 10,20
01E6:  DATA 7F,41
01E8:  DATA 22,1C
01EA:  DATA 22,41
01EC:  DATA 07,08
01EE:  DATA 70,08
01F0:  DATA 07,61
01F2:  DATA 51,49
01F4:  DATA 45,43
01F6:  DATA 00,7F
01F8:  DATA 41,00
01FA:  DATA 00,02
01FC:  DATA 04,08
01FE:  DATA 10,20
0200:  DATA 00,00
0202:  DATA 41,7F
0204:  DATA 00,04
0206:  DATA 02,01
0208:  DATA 02,04
020A:  DATA 40,40
020C:  DATA 40,40
020E:  DATA 40,00
0210:  DATA 01,02
0212:  DATA 04,00
0214:  DATA 20,54
0216:  DATA 54,54
0218:  DATA 78,7F
021A:  DATA 44,44
021C:  DATA 44,38
021E:  DATA 38,44
0220:  DATA 44,44
0222:  DATA 44,38
0224:  DATA 44,44
0226:  DATA 44,7F
0228:  DATA 38,54
022A:  DATA 54,54
022C:  DATA 18,04
022E:  DATA 04,7E
0230:  DATA 05,05
0232:  DATA 08,54
0234:  DATA 54,54
0236:  DATA 3C,7F
0238:  DATA 08,04
023A:  DATA 04,78
023C:  DATA 00,44
023E:  DATA 7D,40
0240:  DATA 00,20
0242:  DATA 40,44
0244:  DATA 3D,00
0246:  DATA 7F,10
0248:  DATA 28,44
024A:  DATA 00,00
024C:  DATA 41,7F
024E:  DATA 40,00
0250:  DATA 7C,04
0252:  DATA 78,04
0254:  DATA 78,7C
0256:  DATA 08,04
0258:  DATA 04,78
025A:  DATA 38,44
025C:  DATA 44,44
025E:  DATA 38,7C
0260:  DATA 14,14
0262:  DATA 14,08
0264:  DATA 08,14
0266:  DATA 14,14
0268:  DATA 7C,00
026A:  DATA 7C,08
026C:  DATA 04,04
026E:  DATA 48,54
0270:  DATA 54,54
0272:  DATA 20,04
0274:  DATA 04,3F
0276:  DATA 44,44
0278:  DATA 3C,40
027A:  DATA 40,20
027C:  DATA 7C,1C
027E:  DATA 20,40
0280:  DATA 20,1C
0282:  DATA 3C,40
0284:  DATA 30,40
0286:  DATA 3C,44
0288:  DATA 28,10
028A:  DATA 28,44
028C:  DATA 0C,50
028E:  DATA 50,50
0290:  DATA 3C,44
0292:  DATA 64,54
0294:  DATA 4C,44
0296:  DATA 00,08
0298:  DATA 36,41
029A:  DATA 41,00
029C:  DATA 00,7F
029E:  DATA 00,00
02A0:  DATA 41,41
02A2:  DATA 36,08
02A4:  DATA 00,02
02A6:  DATA 01,02
02A8:  DATA 04,02
02AA:  ADDLW  B8
02AC:  MOVWF  FF6
02AE:  MOVLW  02
02B0:  ADDWFC FF7,F
02B2:  TBLRD*+
02B4:  MOVF   FF5,W
02B6:  RETURN 0
02B8:  DATA 00,00
02BA:  DATA 00,00
02BC:  DATA 00,00
02BE:  DATA 01,00
02C0:  DATA 00,00
02C2:  DATA 00,00
02C4:  DATA 00,00
02C6:  DATA 00,00
02C8:  DATA 00,00
02CA:  DATA 00,00
02CC:  DATA 00,00
02CE:  DATA 00,00
02D0:  DATA 01,00
02D2:  DATA 00,00
02D4:  DATA 00,00
02D6:  DATA 00,00
02D8:  DATA 00,01
02DA:  DATA 00,00
02DC:  DATA 00,00
02DE:  DATA 00,00
02E0:  DATA 00,00
02E2:  DATA 00,00
02E4:  DATA 00,00
02E6:  DATA 00,00
02E8:  DATA 02,00
02EA:  DATA 00,00
02EC:  DATA 00,00
02EE:  DATA 00,00
02F0:  DATA 00,00
02F2:  DATA 00,00
02F4:  DATA 00,00
02F6:  DATA 00,02
02F8:  DATA 00,00
02FA:  DATA 00,00
02FC:  DATA 00,00
02FE:  DATA 00,00
0300:  DATA 00,00
0302:  DATA 00,00
0304:  DATA 02,00
0306:  DATA 00,00
0308:  DATA 00,00
030A:  DATA 00,00
030C:  DATA 00,00
030E:  DATA 00,00
0310:  DATA 00,00
0312:  DATA 00,00
0314:  DATA 00,00
0316:  DATA 00,00
0318:  DATA 00,00
031A:  DATA 00,03
031C:  DATA 03,00
031E:  DATA 00,00
0320:  DATA 00,03
0322:  DATA 00,00
0324:  DATA 00,00
0326:  DATA 00,00
0328:  DATA 00,00
032A:  DATA 00,00
032C:  DATA 00,00
032E:  DATA 00,00
0330:  DATA 00,02
0332:  DATA 03,01
0334:  DATA 00,00
0336:  DATA 00,00
0338:  DATA 00,00
033A:  DATA 00,00
033C:  DATA 00,00
033E:  DATA 00,00
0340:  DATA 00,00
0342:  DATA 00,00
0344:  DATA 00,00
0346:  DATA 00,02
0348:  DATA 00,00
034A:  DATA 01,00
034C:  DATA 01,00
034E:  DATA 00,00
0350:  DATA 00,00
0352:  DATA 00,01
0354:  DATA 00,01
0356:  DATA 00,00
0358:  DATA 00,00
035A:  DATA 00,00
035C:  DATA 00,00
035E:  DATA 00,03
0360:  DATA 00,00
0362:  DATA 03,00
0364:  DATA 03,00
0366:  DATA 00,00
0368:  DATA 00,00
036A:  DATA 00,00
036C:  DATA 00,00
036E:  DATA 00,00
0370:  DATA 00,00
0372:  DATA 00,00
0374:  DATA 00,00
0376:  DATA 00,00
0378:  DATA 00,00
037A:  DATA 00,00
037C:  DATA 00,00
037E:  DATA 00,00
0380:  DATA 00,00
0382:  DATA 00,00
0384:  DATA 00,00
0386:  DATA 00,00
0388:  DATA 00,00
038A:  DATA 00,00
038C:  DATA 00,00
038E:  DATA 00,00
0390:  DATA 00,00
0392:  DATA 00,00
0394:  DATA 00,00
0396:  DATA 00,00
0398:  DATA 00,00
039A:  DATA 00,00
039C:  DATA 00,00
039E:  DATA 00,00
03A0:  DATA 00,00
03A2:  DATA 00,00
03A4:  DATA 00,00
03A6:  DATA 00,00
03A8:  DATA 00,00
03AA:  DATA 00,00
03AC:  DATA 00,00
03AE:  DATA 00,00
03B0:  DATA 00,00
03B2:  DATA 00,00
03B4:  DATA 00,00
03B6:  DATA 00,00
03B8:  DATA 00,00
03BA:  DATA 00,00
03BC:  DATA 00,00
03BE:  DATA 00,00
03C0:  DATA 00,00
03C2:  DATA 00,00
03C4:  DATA 00,00
03C6:  DATA 00,00
03C8:  DATA 00,00
03CA:  DATA 00,00
03CC:  DATA 00,00
03CE:  DATA 00,00
03D0:  DATA 00,00
03D2:  DATA 00,00
03D4:  DATA 00,00
03D6:  DATA 00,00
03D8:  DATA 00,00
03DA:  DATA 00,00
03DC:  DATA 00,00
03DE:  DATA 00,00
03E0:  DATA 00,00
03E2:  DATA 00,00
03E4:  DATA 00,00
03E6:  DATA 00,00
03E8:  DATA 00,00
03EA:  DATA 00,00
03EC:  DATA 00,00
03EE:  DATA 00,00
03F0:  DATA 00,00
03F2:  DATA 00,00
03F4:  DATA 00,00
03F6:  DATA 00,00
03F8:  DATA 00,00
03FA:  DATA 00,00
03FC:  DATA 00,00
03FE:  DATA 00,00
0400:  DATA 00,00
0402:  DATA 00,00
0404:  DATA 00,00
0406:  DATA 00,00
0408:  DATA 00,00
040A:  DATA 00,00
040C:  DATA 00,00
040E:  DATA 00,00
0410:  DATA 00,00
0412:  DATA 00,00
0414:  DATA 00,00
0416:  DATA 00,00
0418:  DATA 00,00
041A:  DATA 00,00
041C:  DATA 00,00
041E:  DATA 00,00
0420:  DATA 00,00
0422:  DATA 00,00
0424:  DATA 00,00
0426:  DATA 00,00
0428:  DATA 00,00
042A:  DATA 00,00
042C:  DATA 00,00
042E:  DATA 00,00
0430:  DATA 00,00
0432:  DATA 00,00
0434:  DATA 00,00
0436:  DATA 00,00
0438:  DATA 00,00
043A:  DATA 00,00
043C:  DATA 00,00
043E:  DATA 00,00
0440:  DATA 00,00
0442:  DATA 00,00
0444:  DATA 00,00
0446:  DATA 00,00
0448:  DATA 00,00
044A:  DATA 00,00
044C:  DATA 00,00
044E:  DATA 00,00
0450:  DATA 00,00
0452:  DATA 00,00
0454:  DATA 00,00
0456:  DATA 00,00
0458:  DATA 00,00
045A:  DATA 00,00
045C:  DATA 00,00
045E:  DATA 00,00
0460:  DATA 00,00
0462:  DATA 00,00
0464:  DATA 00,00
0466:  DATA 00,00
0468:  DATA 00,00
046A:  DATA 00,00
046C:  DATA 00,00
046E:  DATA 00,00
0470:  DATA 00,00
0472:  DATA 00,00
0474:  DATA 00,00
0476:  DATA 00,00
0478:  DATA 00,00
047A:  DATA 00,00
047C:  DATA 00,00
047E:  DATA 00,00
0480:  DATA 00,00
0482:  DATA 00,00
0484:  DATA 00,00
0486:  DATA 00,00
0488:  DATA 00,00
048A:  DATA 00,00
048C:  DATA 00,00
048E:  DATA 00,00
0490:  DATA 00,00
0492:  DATA 00,00
0494:  DATA 00,00
0496:  DATA 00,00
0498:  DATA 00,00
049A:  DATA 00,00
049C:  DATA 00,00
049E:  DATA 00,00
04A0:  DATA 00,00
04A2:  DATA 00,00
04A4:  DATA 00,00
04A6:  DATA 00,00
04A8:  DATA 00,00
04AA:  DATA 00,00
04AC:  DATA 00,00
04AE:  DATA 00,00
04B0:  DATA 00,00
04B2:  DATA 00,00
04B4:  DATA 00,00
04B6:  DATA 00,00
04B8:  DATA 00,00
04BA:  DATA 00,00
04BC:  DATA 00,00
04BE:  DATA 00,00
04C0:  DATA 00,00
04C2:  DATA 00,00
04C4:  DATA 00,00
04C6:  DATA 00,00
04C8:  DATA 00,00
04CA:  DATA 00,00
04CC:  DATA 00,00
04CE:  DATA 00,00
04D0:  DATA 00,00
04D2:  DATA 00,00
04D4:  DATA 00,00
04D6:  DATA 00,00
04D8:  DATA 00,00
04DA:  DATA 00,00
04DC:  DATA 00,00
04DE:  DATA 00,00
04E0:  DATA 00,00
04E2:  DATA 00,00
04E4:  DATA 00,00
04E6:  DATA 00,00
04E8:  DATA 00,00
04EA:  DATA 00,00
04EC:  DATA 00,00
04EE:  DATA 00,00
04F0:  DATA 00,00
04F2:  DATA 00,00
04F4:  DATA 00,00
04F6:  DATA 00,00
04F8:  DATA 00,00
04FA:  DATA 00,00
04FC:  DATA 00,00
04FE:  DATA 00,00
0500:  DATA 00,00
0502:  DATA 00,00
0504:  DATA 00,00
0506:  DATA 00,00
0508:  DATA 00,00
050A:  DATA 00,00
050C:  DATA 00,00
050E:  DATA 00,00
*
05C0:  ADDWF  FE8,W
05C2:  CLRF   FF7
05C4:  RLCF   FF7,F
05C6:  ADDLW  DB
05C8:  MOVWF  FF6
05CA:  MOVLW  05
05CC:  ADDWFC FF7,F
05CE:  TBLRD*-
05D0:  MOVF   FF5,W
05D2:  MOVWF  FFA
05D4:  TBLRD*
05D6:  MOVF   FF5,W
05D8:  MOVWF  FF9
05DA:  DATA 28,05
05DC:  DATA 30,05
05DE:  DATA 38,05
05E0:  DATA 40,05
05E2:  DATA 48,05
05E4:  DATA 50,05
05E6:  DATA 58,05
05E8:  DATA 60,05
05EA:  DATA 68,05
*
0786:  CLRF   00
0788:  CLRF   01
078A:  MOVLB  2
078C:  MOVF   xEE,W
078E:  BCF    FD8.0
0790:  BTFSC  xEF.0
0792:  ADDWF  00,F
0794:  RRCF   00,F
0796:  RRCF   01,F
0798:  BTFSC  xEF.1
079A:  ADDWF  00,F
079C:  RRCF   00,F
079E:  RRCF   01,F
07A0:  BTFSC  xEF.2
07A2:  ADDWF  00,F
07A4:  RRCF   00,F
07A6:  RRCF   01,F
07A8:  BTFSC  xEF.3
07AA:  ADDWF  00,F
07AC:  RRCF   00,F
07AE:  RRCF   01,F
07B0:  BTFSC  xEF.4
07B2:  ADDWF  00,F
07B4:  RRCF   00,F
07B6:  RRCF   01,F
07B8:  BTFSC  xEF.5
07BA:  ADDWF  00,F
07BC:  RRCF   00,F
07BE:  RRCF   01,F
07C0:  BTFSC  xEF.6
07C2:  ADDWF  00,F
07C4:  RRCF   00,F
07C6:  RRCF   01,F
07C8:  BTFSC  xEF.7
07CA:  ADDWF  00,F
07CC:  RRCF   00,F
07CE:  RRCF   01,F
07D0:  MOVLB  0
07D2:  RETURN 0
*
1974:  MOVLB  2
1976:  MOVF   x5B,W
1978:  MULWF  x5D
197A:  MOVFF  FF3,01
197E:  MOVFF  FF4,00
1982:  MULWF  x5E
1984:  MOVF   FF3,W
1986:  ADDWF  00,F
1988:  MOVF   x5C,W
198A:  MULWF  x5D
198C:  MOVF   FF3,W
198E:  ADDWFC 00,W
1990:  MOVWF  02
1992:  MOVLB  0
1994:  GOTO   319A (RETURN)
*
1A16:  MOVLW  8E
1A18:  MOVWF  00
1A1A:  MOVFF  290,01
1A1E:  MOVFF  28F,02
1A22:  CLRF   03
1A24:  MOVF   01,F
1A26:  BNZ   1A3A
1A28:  MOVFF  02,01
1A2C:  CLRF   02
1A2E:  MOVLW  08
1A30:  SUBWF  00,F
1A32:  MOVF   01,F
1A34:  BNZ   1A3A
1A36:  CLRF   00
1A38:  BRA    1A4A
1A3A:  BCF    FD8.0
1A3C:  BTFSC  01.7
1A3E:  BRA    1A48
1A40:  RLCF   02,F
1A42:  RLCF   01,F
1A44:  DECF   00,F
1A46:  BRA    1A3A
1A48:  BCF    01.7
1A4A:  RETURN 0
1A4C:  MOVLB  2
1A4E:  MOVF   x61,W
1A50:  BTFSC  FD8.2
1A52:  BRA    1B9E
1A54:  MOVWF  x6D
1A56:  MOVF   x65,W
1A58:  BTFSC  FD8.2
1A5A:  BRA    1B9E
1A5C:  SUBWF  x6D,F
1A5E:  BNC   1A6A
1A60:  MOVLW  7F
1A62:  ADDWF  x6D,F
1A64:  BTFSC  FD8.0
1A66:  BRA    1B9E
1A68:  BRA    1A76
1A6A:  MOVLW  81
1A6C:  SUBWF  x6D,F
1A6E:  BTFSS  FD8.0
1A70:  BRA    1B9E
1A72:  BTFSC  FD8.2
1A74:  BRA    1B9E
1A76:  MOVFF  26D,00
1A7A:  CLRF   01
1A7C:  CLRF   02
1A7E:  CLRF   03
1A80:  CLRF   x6C
1A82:  MOVFF  262,26B
1A86:  BSF    x6B.7
1A88:  MOVFF  263,26A
1A8C:  MOVFF  264,269
1A90:  MOVLW  19
1A92:  MOVWF  x6D
1A94:  MOVF   x68,W
1A96:  SUBWF  x69,F
1A98:  BC    1AB4
1A9A:  MOVLW  01
1A9C:  SUBWF  x6A,F
1A9E:  BC    1AB4
1AA0:  SUBWF  x6B,F
1AA2:  BC    1AB4
1AA4:  SUBWF  x6C,F
1AA6:  BC    1AB4
1AA8:  INCF   x6C,F
1AAA:  INCF   x6B,F
1AAC:  INCF   x6A,F
1AAE:  MOVF   x68,W
1AB0:  ADDWF  x69,F
1AB2:  BRA    1B04
1AB4:  MOVF   x67,W
1AB6:  SUBWF  x6A,F
1AB8:  BC    1ADE
1ABA:  MOVLW  01
1ABC:  SUBWF  x6B,F
1ABE:  BC    1ADE
1AC0:  SUBWF  x6C,F
1AC2:  BC    1ADE
1AC4:  INCF   x6C,F
1AC6:  INCF   x6B,F
1AC8:  MOVF   x67,W
1ACA:  ADDWF  x6A,F
1ACC:  MOVF   x68,W
1ACE:  ADDWF  x69,F
1AD0:  BNC   1B04
1AD2:  INCF   x6A,F
1AD4:  BNZ   1B04
1AD6:  INCF   x6B,F
1AD8:  BNZ   1B04
1ADA:  INCF   x6C,F
1ADC:  BRA    1B04
1ADE:  MOVF   x66,W
1AE0:  IORLW  80
1AE2:  SUBWF  x6B,F
1AE4:  BC    1B02
1AE6:  MOVLW  01
1AE8:  SUBWF  x6C,F
1AEA:  BC    1B02
1AEC:  INCF   x6C,F
1AEE:  MOVF   x66,W
1AF0:  IORLW  80
1AF2:  ADDWF  x6B,F
1AF4:  MOVF   x67,W
1AF6:  ADDWF  x6A,F
1AF8:  BNC   1ACC
1AFA:  INCF   x6B,F
1AFC:  BNZ   1ACC
1AFE:  INCF   x6C,F
1B00:  BRA    1ACC
1B02:  BSF    03.0
1B04:  DECFSZ x6D,F
1B06:  BRA    1B0A
1B08:  BRA    1B20
1B0A:  BCF    FD8.0
1B0C:  RLCF   x69,F
1B0E:  RLCF   x6A,F
1B10:  RLCF   x6B,F
1B12:  RLCF   x6C,F
1B14:  BCF    FD8.0
1B16:  RLCF   03,F
1B18:  RLCF   02,F
1B1A:  RLCF   01,F
1B1C:  RLCF   x6E,F
1B1E:  BRA    1A94
1B20:  BTFSS  x6E.0
1B22:  BRA    1B30
1B24:  BCF    FD8.0
1B26:  RRCF   01,F
1B28:  RRCF   02,F
1B2A:  RRCF   03,F
1B2C:  RRCF   x6E,F
1B2E:  BRA    1B34
1B30:  DECF   00,F
1B32:  BZ    1B9E
1B34:  BTFSC  x6E.7
1B36:  BRA    1B74
1B38:  BCF    FD8.0
1B3A:  RLCF   x69,F
1B3C:  RLCF   x6A,F
1B3E:  RLCF   x6B,F
1B40:  RLCF   x6C,F
1B42:  MOVF   x68,W
1B44:  SUBWF  x69,F
1B46:  BC    1B56
1B48:  MOVLW  01
1B4A:  SUBWF  x6A,F
1B4C:  BC    1B56
1B4E:  SUBWF  x6B,F
1B50:  BC    1B56
1B52:  SUBWF  x6C,F
1B54:  BNC   1B8A
1B56:  MOVF   x67,W
1B58:  SUBWF  x6A,F
1B5A:  BC    1B66
1B5C:  MOVLW  01
1B5E:  SUBWF  x6B,F
1B60:  BC    1B66
1B62:  SUBWF  x6C,F
1B64:  BNC   1B8A
1B66:  MOVF   x66,W
1B68:  IORLW  80
1B6A:  SUBWF  x6B,F
1B6C:  BC    1B74
1B6E:  MOVLW  01
1B70:  SUBWF  x6C,F
1B72:  BNC   1B8A
1B74:  INCF   03,F
1B76:  BNZ   1B8A
1B78:  INCF   02,F
1B7A:  BNZ   1B8A
1B7C:  INCF   01,F
1B7E:  BNZ   1B8A
1B80:  INCF   00,F
1B82:  BZ    1B9E
1B84:  RRCF   01,F
1B86:  RRCF   02,F
1B88:  RRCF   03,F
1B8A:  MOVFF  262,26D
1B8E:  MOVF   x66,W
1B90:  XORWF  x6D,F
1B92:  BTFSS  x6D.7
1B94:  BRA    1B9A
1B96:  BSF    01.7
1B98:  BRA    1BA6
1B9A:  BCF    01.7
1B9C:  BRA    1BA6
1B9E:  CLRF   00
1BA0:  CLRF   01
1BA2:  CLRF   02
1BA4:  CLRF   03
1BA6:  MOVLB  0
1BA8:  RETURN 0
1BAA:  MOVLW  8E
1BAC:  MOVWF  00
1BAE:  MOVLB  2
1BB0:  MOVF   x8B,W
1BB2:  SUBWF  00,F
1BB4:  MOVFF  28C,02
1BB8:  MOVFF  28D,01
1BBC:  BSF    02.7
1BBE:  MOVF   00,F
1BC0:  BZ    1BD4
1BC2:  BCF    FD8.0
1BC4:  MOVF   02,F
1BC6:  BNZ   1BCC
1BC8:  MOVF   01,F
1BCA:  BZ    1BD4
1BCC:  RRCF   02,F
1BCE:  RRCF   01,F
1BD0:  DECFSZ 00,F
1BD2:  BRA    1BC2
1BD4:  BTFSS  x8C.7
1BD6:  BRA    1BE2
1BD8:  COMF   01,F
1BDA:  COMF   02,F
1BDC:  INCF   01,F
1BDE:  BTFSC  FD8.2
1BE0:  INCF   02,F
1BE2:  MOVLB  0
1BE4:  RETURN 0
1BE6:  MOVLB  2
1BE8:  MOVF   x6A,W
1BEA:  CLRF   01
1BEC:  SUBWF  x69,W
1BEE:  BC    1BF6
1BF0:  MOVFF  269,00
1BF4:  BRA    1C0E
1BF6:  CLRF   00
1BF8:  MOVLW  08
1BFA:  MOVWF  x6B
1BFC:  RLCF   x69,F
1BFE:  RLCF   00,F
1C00:  MOVF   x6A,W
1C02:  SUBWF  00,W
1C04:  BTFSC  FD8.0
1C06:  MOVWF  00
1C08:  RLCF   01,F
1C0A:  DECFSZ x6B,F
1C0C:  BRA    1BFC
1C0E:  MOVLB  0
1C10:  RETURN 0
1C12:  MOVLW  80
1C14:  BTFSS  FD8.1
1C16:  BRA    1C1C
1C18:  MOVLB  2
1C1A:  XORWF  x94,F
1C1C:  MOVLB  2
1C1E:  CLRF   x99
1C20:  CLRF   x9A
1C22:  MOVFF  290,298
1C26:  MOVF   x94,W
1C28:  XORWF  x98,F
1C2A:  MOVF   x8F,W
1C2C:  BTFSC  FD8.2
1C2E:  BRA    1DEE
1C30:  MOVWF  x97
1C32:  MOVWF  00
1C34:  MOVF   x93,W
1C36:  BTFSC  FD8.2
1C38:  BRA    1E00
1C3A:  SUBWF  x97,F
1C3C:  BTFSC  FD8.2
1C3E:  BRA    1D46
1C40:  BNC   1CBE
1C42:  MOVFF  294,29D
1C46:  BSF    x9D.7
1C48:  MOVFF  295,29C
1C4C:  MOVFF  296,29B
1C50:  CLRF   x9A
1C52:  BCF    FD8.0
1C54:  RRCF   x9D,F
1C56:  RRCF   x9C,F
1C58:  RRCF   x9B,F
1C5A:  RRCF   x9A,F
1C5C:  DECFSZ x97,F
1C5E:  BRA    1C50
1C60:  BTFSS  x98.7
1C62:  BRA    1C6A
1C64:  BSF    x99.0
1C66:  BRA    1E28
1C68:  BCF    x99.0
1C6A:  BCF    x97.0
1C6C:  BSF    x99.4
1C6E:  MOVLW  02
1C70:  MOVWF  FEA
1C72:  MOVLW  92
1C74:  MOVWF  FE9
1C76:  BRA    1E4E
1C78:  BCF    x99.4
1C7A:  BTFSC  x98.7
1C7C:  BRA    1C92
1C7E:  BTFSS  x97.0
1C80:  BRA    1CA8
1C82:  RRCF   x9D,F
1C84:  RRCF   x9C,F
1C86:  RRCF   x9B,F
1C88:  RRCF   x9A,F
1C8A:  INCF   00,F
1C8C:  BTFSC  FD8.2
1C8E:  BRA    1E1E
1C90:  BRA    1CA8
1C92:  BTFSC  x9D.7
1C94:  BRA    1CAE
1C96:  BCF    FD8.0
1C98:  RLCF   x9A,F
1C9A:  RLCF   x9B,F
1C9C:  RLCF   x9C,F
1C9E:  RLCF   x9D,F
1CA0:  DECF   00,F
1CA2:  BTFSC  FD8.2
1CA4:  BRA    1E1E
1CA6:  BRA    1C92
1CA8:  BSF    x99.6
1CAA:  BRA    1D86
1CAC:  BCF    x99.6
1CAE:  MOVFF  290,298
1CB2:  BTFSS  x90.7
1CB4:  BRA    1CBA
1CB6:  BSF    x9D.7
1CB8:  BRA    1E10
1CBA:  BCF    x9D.7
1CBC:  BRA    1E10
1CBE:  MOVFF  293,297
1CC2:  MOVFF  293,00
1CC6:  MOVF   x8F,W
1CC8:  SUBWF  x97,F
1CCA:  MOVFF  290,29D
1CCE:  BSF    x9D.7
1CD0:  MOVFF  291,29C
1CD4:  MOVFF  292,29B
1CD8:  CLRF   x9A
1CDA:  BCF    FD8.0
1CDC:  RRCF   x9D,F
1CDE:  RRCF   x9C,F
1CE0:  RRCF   x9B,F
1CE2:  RRCF   x9A,F
1CE4:  DECFSZ x97,F
1CE6:  BRA    1CD8
1CE8:  BTFSS  x98.7
1CEA:  BRA    1CF2
1CEC:  BSF    x99.1
1CEE:  BRA    1E28
1CF0:  BCF    x99.1
1CF2:  BCF    x97.0
1CF4:  BSF    x99.5
1CF6:  MOVLW  02
1CF8:  MOVWF  FEA
1CFA:  MOVLW  96
1CFC:  MOVWF  FE9
1CFE:  BRA    1E4E
1D00:  BCF    x99.5
1D02:  BTFSC  x98.7
1D04:  BRA    1D1A
1D06:  BTFSS  x97.0
1D08:  BRA    1D30
1D0A:  RRCF   x9D,F
1D0C:  RRCF   x9C,F
1D0E:  RRCF   x9B,F
1D10:  RRCF   x9A,F
1D12:  INCF   00,F
1D14:  BTFSC  FD8.2
1D16:  BRA    1E1E
1D18:  BRA    1D30
1D1A:  BTFSC  x9D.7
1D1C:  BRA    1D36
1D1E:  BCF    FD8.0
1D20:  RLCF   x9A,F
1D22:  RLCF   x9B,F
1D24:  RLCF   x9C,F
1D26:  RLCF   x9D,F
1D28:  DECF   00,F
1D2A:  BTFSC  FD8.2
1D2C:  BRA    1E1E
1D2E:  BRA    1D1A
1D30:  BSF    x99.7
1D32:  BRA    1D86
1D34:  BCF    x99.7
1D36:  MOVFF  294,298
1D3A:  BTFSS  x94.7
1D3C:  BRA    1D42
1D3E:  BSF    x9D.7
1D40:  BRA    1E10
1D42:  BCF    x9D.7
1D44:  BRA    1E10
1D46:  MOVFF  294,29D
1D4A:  BSF    x9D.7
1D4C:  MOVFF  295,29C
1D50:  MOVFF  296,29B
1D54:  BTFSS  x98.7
1D56:  BRA    1D60
1D58:  BCF    x9D.7
1D5A:  BSF    x99.2
1D5C:  BRA    1E28
1D5E:  BCF    x99.2
1D60:  CLRF   x9A
1D62:  BCF    x97.0
1D64:  MOVLW  02
1D66:  MOVWF  FEA
1D68:  MOVLW  92
1D6A:  MOVWF  FE9
1D6C:  BRA    1E4E
1D6E:  BTFSC  x98.7
1D70:  BRA    1DAA
1D72:  MOVFF  290,298
1D76:  BTFSS  x97.0
1D78:  BRA    1D86
1D7A:  RRCF   x9D,F
1D7C:  RRCF   x9C,F
1D7E:  RRCF   x9B,F
1D80:  RRCF   x9A,F
1D82:  INCF   00,F
1D84:  BZ    1E1E
1D86:  BTFSS  x9A.7
1D88:  BRA    1DA0
1D8A:  INCF   x9B,F
1D8C:  BNZ   1DA0
1D8E:  INCF   x9C,F
1D90:  BNZ   1DA0
1D92:  INCF   x9D,F
1D94:  BNZ   1DA0
1D96:  RRCF   x9D,F
1D98:  RRCF   x9C,F
1D9A:  RRCF   x9B,F
1D9C:  INCF   00,F
1D9E:  BZ    1E1E
1DA0:  BTFSC  x99.6
1DA2:  BRA    1CAC
1DA4:  BTFSC  x99.7
1DA6:  BRA    1D34
1DA8:  BRA    1DE2
1DAA:  MOVLW  80
1DAC:  XORWF  x9D,F
1DAE:  BTFSS  x9D.7
1DB0:  BRA    1DBA
1DB2:  BRA    1E28
1DB4:  MOVFF  294,298
1DB8:  BRA    1DCE
1DBA:  MOVFF  290,298
1DBE:  MOVF   x9D,F
1DC0:  BNZ   1DCE
1DC2:  MOVF   x9C,F
1DC4:  BNZ   1DCE
1DC6:  MOVF   x9B,F
1DC8:  BNZ   1DCE
1DCA:  CLRF   00
1DCC:  BRA    1E10
1DCE:  BTFSC  x9D.7
1DD0:  BRA    1DE2
1DD2:  BCF    FD8.0
1DD4:  RLCF   x9A,F
1DD6:  RLCF   x9B,F
1DD8:  RLCF   x9C,F
1DDA:  RLCF   x9D,F
1DDC:  DECFSZ 00,F
1DDE:  BRA    1DCE
1DE0:  BRA    1E1E
1DE2:  BTFSS  x98.7
1DE4:  BRA    1DEA
1DE6:  BSF    x9D.7
1DE8:  BRA    1E10
1DEA:  BCF    x9D.7
1DEC:  BRA    1E10
1DEE:  MOVFF  293,00
1DF2:  MOVFF  294,29D
1DF6:  MOVFF  295,29C
1DFA:  MOVFF  296,29B
1DFE:  BRA    1E10
1E00:  MOVFF  28F,00
1E04:  MOVFF  290,29D
1E08:  MOVFF  291,29C
1E0C:  MOVFF  292,29B
1E10:  MOVFF  29D,01
1E14:  MOVFF  29C,02
1E18:  MOVFF  29B,03
1E1C:  BRA    1E86
1E1E:  CLRF   00
1E20:  CLRF   01
1E22:  CLRF   02
1E24:  CLRF   03
1E26:  BRA    1E86
1E28:  CLRF   x9A
1E2A:  COMF   x9B,F
1E2C:  COMF   x9C,F
1E2E:  COMF   x9D,F
1E30:  COMF   x9A,F
1E32:  INCF   x9A,F
1E34:  BNZ   1E40
1E36:  INCF   x9B,F
1E38:  BNZ   1E40
1E3A:  INCF   x9C,F
1E3C:  BNZ   1E40
1E3E:  INCF   x9D,F
1E40:  BTFSC  x99.0
1E42:  BRA    1C68
1E44:  BTFSC  x99.1
1E46:  BRA    1CF0
1E48:  BTFSC  x99.2
1E4A:  BRA    1D5E
1E4C:  BRA    1DB4
1E4E:  MOVF   FEF,W
1E50:  ADDWF  x9B,F
1E52:  BNC   1E5E
1E54:  INCF   x9C,F
1E56:  BNZ   1E5E
1E58:  INCF   x9D,F
1E5A:  BTFSC  FD8.2
1E5C:  BSF    x97.0
1E5E:  MOVF   FED,F
1E60:  MOVF   FEF,W
1E62:  ADDWF  x9C,F
1E64:  BNC   1E6C
1E66:  INCF   x9D,F
1E68:  BTFSC  FD8.2
1E6A:  BSF    x97.0
1E6C:  MOVF   FED,F
1E6E:  MOVF   FEF,W
1E70:  BTFSC  FEF.7
1E72:  BRA    1E76
1E74:  XORLW  80
1E76:  ADDWF  x9D,F
1E78:  BTFSC  FD8.0
1E7A:  BSF    x97.0
1E7C:  BTFSC  x99.4
1E7E:  BRA    1C78
1E80:  BTFSC  x99.5
1E82:  BRA    1D00
1E84:  BRA    1D6E
1E86:  MOVLB  0
1E88:  RETURN 0
*
1F52:  MOVLB  2
1F54:  MOVF   x8F,W
1F56:  BTFSC  FD8.2
1F58:  BRA    203C
1F5A:  MOVWF  00
1F5C:  MOVF   x93,W
1F5E:  BTFSC  FD8.2
1F60:  BRA    203C
1F62:  ADDWF  00,F
1F64:  BNC   1F6E
1F66:  MOVLW  81
1F68:  ADDWF  00,F
1F6A:  BC    203C
1F6C:  BRA    1F76
1F6E:  MOVLW  7F
1F70:  SUBWF  00,F
1F72:  BNC   203C
1F74:  BZ    203C
1F76:  MOVFF  290,297
1F7A:  MOVF   x94,W
1F7C:  XORWF  x97,F
1F7E:  BSF    x90.7
1F80:  BSF    x94.7
1F82:  MOVF   x92,W
1F84:  MULWF  x96
1F86:  MOVFF  FF4,299
1F8A:  MOVF   x91,W
1F8C:  MULWF  x95
1F8E:  MOVFF  FF4,03
1F92:  MOVFF  FF3,298
1F96:  MULWF  x96
1F98:  MOVF   FF3,W
1F9A:  ADDWF  x99,F
1F9C:  MOVF   FF4,W
1F9E:  ADDWFC x98,F
1FA0:  MOVLW  00
1FA2:  ADDWFC 03,F
1FA4:  MOVF   x92,W
1FA6:  MULWF  x95
1FA8:  MOVF   FF3,W
1FAA:  ADDWF  x99,F
1FAC:  MOVF   FF4,W
1FAE:  ADDWFC x98,F
1FB0:  MOVLW  00
1FB2:  CLRF   02
1FB4:  ADDWFC 03,F
1FB6:  ADDWFC 02,F
1FB8:  MOVF   x90,W
1FBA:  MULWF  x96
1FBC:  MOVF   FF3,W
1FBE:  ADDWF  x98,F
1FC0:  MOVF   FF4,W
1FC2:  ADDWFC 03,F
1FC4:  MOVLW  00
1FC6:  ADDWFC 02,F
1FC8:  MOVF   x90,W
1FCA:  MULWF  x95
1FCC:  MOVF   FF3,W
1FCE:  ADDWF  03,F
1FD0:  MOVF   FF4,W
1FD2:  ADDWFC 02,F
1FD4:  MOVLW  00
1FD6:  CLRF   01
1FD8:  ADDWFC 01,F
1FDA:  MOVF   x92,W
1FDC:  MULWF  x94
1FDE:  MOVF   FF3,W
1FE0:  ADDWF  x98,F
1FE2:  MOVF   FF4,W
1FE4:  ADDWFC 03,F
1FE6:  MOVLW  00
1FE8:  ADDWFC 02,F
1FEA:  ADDWFC 01,F
1FEC:  MOVF   x91,W
1FEE:  MULWF  x94
1FF0:  MOVF   FF3,W
1FF2:  ADDWF  03,F
1FF4:  MOVF   FF4,W
1FF6:  ADDWFC 02,F
1FF8:  MOVLW  00
1FFA:  ADDWFC 01,F
1FFC:  MOVF   x90,W
1FFE:  MULWF  x94
2000:  MOVF   FF3,W
2002:  ADDWF  02,F
2004:  MOVF   FF4,W
2006:  ADDWFC 01,F
2008:  INCF   00,F
200A:  BTFSC  01.7
200C:  BRA    2018
200E:  RLCF   x98,F
2010:  RLCF   03,F
2012:  RLCF   02,F
2014:  RLCF   01,F
2016:  DECF   00,F
2018:  MOVLW  00
201A:  BTFSS  x98.7
201C:  BRA    2032
201E:  INCF   03,F
2020:  ADDWFC 02,F
2022:  ADDWFC 01,F
2024:  MOVF   01,W
2026:  BNZ   2032
2028:  MOVF   02,W
202A:  BNZ   2032
202C:  MOVF   03,W
202E:  BNZ   2032
2030:  INCF   00,F
2032:  BTFSC  x97.7
2034:  BSF    01.7
2036:  BTFSS  x97.7
2038:  BCF    01.7
203A:  BRA    2044
203C:  CLRF   00
203E:  CLRF   01
2040:  CLRF   02
2042:  CLRF   03
2044:  MOVLB  0
2046:  RETURN 0
*
2134:  MOVFF  28C,293
2138:  MOVLB  2
213A:  MOVF   x90,W
213C:  XORWF  x93,F
213E:  BTFSS  x93.7
2140:  BRA    214C
2142:  BCF    FD8.2
2144:  BCF    FD8.0
2146:  BTFSC  x8C.7
2148:  BSF    FD8.0
214A:  BRA    21AA
214C:  MOVFF  28C,293
2150:  MOVFF  28F,294
2154:  MOVF   x8B,W
2156:  SUBWF  x94,F
2158:  BZ    2166
215A:  BTFSS  x93.7
215C:  BRA    21AA
215E:  MOVF   FD8,W
2160:  XORLW  01
2162:  MOVWF  FD8
2164:  BRA    21AA
2166:  MOVFF  290,294
216A:  MOVF   x8C,W
216C:  SUBWF  x94,F
216E:  BZ    217C
2170:  BTFSS  x93.7
2172:  BRA    21AA
2174:  MOVF   FD8,W
2176:  XORLW  01
2178:  MOVWF  FD8
217A:  BRA    21AA
217C:  MOVFF  291,294
2180:  MOVF   x8D,W
2182:  SUBWF  x94,F
2184:  BZ    2192
2186:  BTFSS  x93.7
2188:  BRA    21AA
218A:  MOVF   FD8,W
218C:  XORLW  01
218E:  MOVWF  FD8
2190:  BRA    21AA
2192:  MOVFF  292,294
2196:  MOVF   x8E,W
2198:  SUBWF  x94,F
219A:  BZ    21A8
219C:  BTFSS  x93.7
219E:  BRA    21AA
21A0:  MOVF   FD8,W
21A2:  XORLW  01
21A4:  MOVWF  FD8
21A6:  BRA    21AA
21A8:  BCF    FD8.0
21AA:  MOVLB  0
21AC:  RETURN 0
21AE:  MOVLB  2
21B0:  MOVF   x59,W
21B2:  ANDLW  07
21B4:  MOVWF  00
21B6:  RRCF   x59,W
21B8:  MOVWF  01
21BA:  RRCF   01,F
21BC:  RRCF   01,F
21BE:  MOVLW  1F
21C0:  ANDWF  01,F
21C2:  MOVF   01,W
21C4:  ADDWF  x5B,W
21C6:  MOVWF  FE9
21C8:  MOVLW  00
21CA:  ADDWFC x5C,W
21CC:  MOVWF  FEA
21CE:  CLRF   01
21D0:  INCF   01,F
21D2:  INCF   00,F
21D4:  BRA    21D8
21D6:  RLCF   01,F
21D8:  DECFSZ 00,F
21DA:  BRA    21D6
21DC:  MOVF   x5A,F
21DE:  BZ    21E6
21E0:  MOVF   01,W
21E2:  IORWF  FEF,F
21E4:  BRA    21EC
21E6:  COMF   01,F
21E8:  MOVF   01,W
21EA:  ANDWF  FEF,F
21EC:  MOVLB  0
21EE:  RETURN 0
*
25B6:  MOVLB  2
25B8:  MOVF   x59,W
25BA:  ANDLW  07
25BC:  MOVWF  00
25BE:  RRCF   x59,W
25C0:  MOVWF  01
25C2:  RRCF   01,F
25C4:  RRCF   01,F
25C6:  MOVLW  1F
25C8:  ANDWF  01,F
25CA:  MOVF   01,W
25CC:  ADDWF  x5A,W
25CE:  MOVWF  FE9
25D0:  MOVLW  00
25D2:  ADDWFC x5B,W
25D4:  MOVWF  FEA
25D6:  MOVFF  FEF,01
25DA:  INCF   00,F
25DC:  BRA    25E0
25DE:  RRCF   01,F
25E0:  DECFSZ 00,F
25E2:  BRA    25DE
25E4:  MOVLW  01
25E6:  ANDWF  01,F
25E8:  MOVLB  0
25EA:  RETURN 0
*
28AC:  MOVFF  21B,FEA
28B0:  MOVFF  21A,FE9
28B4:  MOVLB  2
28B6:  MOVFF  270,FEF
28BA:  INCF   FE9,F
28BC:  BTFSC  FD8.2
28BE:  INCF   FEA,F
28C0:  CLRF   FEF
28C2:  INCF   x1A,F
28C4:  BTFSC  FD8.2
28C6:  INCF   x1B,F
28C8:  MOVLB  0
28CA:  RETURN 0
28CC:  MOVFF  FEA,26F
28D0:  MOVFF  FE9,26E
28D4:  MOVLB  2
28D6:  SWAPF  x68,W
28D8:  IORLW  F0
28DA:  MOVWF  x6A
28DC:  ADDWF  x6A,F
28DE:  ADDLW  E2
28E0:  MOVWF  x6B
28E2:  ADDLW  32
28E4:  MOVWF  x6D
28E6:  MOVF   x68,W
28E8:  ANDLW  0F
28EA:  ADDWF  x6B,F
28EC:  ADDWF  x6B,F
28EE:  ADDWF  x6D,F
28F0:  ADDLW  E9
28F2:  MOVWF  x6C
28F4:  ADDWF  x6C,F
28F6:  ADDWF  x6C,F
28F8:  SWAPF  x67,W
28FA:  ANDLW  0F
28FC:  ADDWF  x6C,F
28FE:  ADDWF  x6D,F
2900:  RLCF   x6C,F
2902:  RLCF   x6D,F
2904:  COMF   x6D,F
2906:  RLCF   x6D,F
2908:  MOVF   x67,W
290A:  ANDLW  0F
290C:  ADDWF  x6D,F
290E:  RLCF   x6A,F
2910:  MOVLW  07
2912:  MOVWF  x69
2914:  MOVLW  0A
2916:  DECF   x6C,F
2918:  ADDWF  x6D,F
291A:  BNC   2916
291C:  DECF   x6B,F
291E:  ADDWF  x6C,F
2920:  BNC   291C
2922:  DECF   x6A,F
2924:  ADDWF  x6B,F
2926:  BNC   2922
2928:  DECF   x69,F
292A:  ADDWF  x6A,F
292C:  BNC   2928
292E:  MOVLW  02
2930:  MOVWF  FEA
2932:  MOVLW  69
2934:  MOVWF  FE9
2936:  MOVLW  07
2938:  ANDWF  x6E,W
293A:  BCF    x6E.6
293C:  ADDWF  FE9,F
293E:  MOVLW  00
2940:  ADDWFC FEA,F
2942:  MOVF   FE9,W
2944:  SUBLW  6D
2946:  BNZ   2950
2948:  MOVF   FEA,W
294A:  SUBLW  02
294C:  BNZ   2950
294E:  BSF    x6E.6
2950:  MOVF   FEF,W
2952:  MOVWF  00
2954:  BNZ   2966
2956:  BTFSC  x6E.6
2958:  BRA    2966
295A:  BTFSC  x6E.4
295C:  BRA    2988
295E:  BTFSC  x6E.3
2960:  BRA    2966
2962:  MOVLW  20
2964:  BRA    296C
2966:  BSF    x6E.3
2968:  BCF    x6E.4
296A:  MOVLW  30
296C:  ADDWF  00,F
296E:  MOVFF  FEA,268
2972:  MOVFF  FE9,267
2976:  MOVFF  00,270
297A:  MOVLB  0
297C:  RCALL  28AC
297E:  MOVFF  268,FEA
2982:  MOVFF  267,FE9
2986:  MOVLB  2
2988:  MOVF   FEE,W
298A:  BTFSS  x6E.6
298C:  BRA    2942
298E:  MOVLB  0
2990:  GOTO   2A40 (RETURN)
2994:  MOVF   01,W
2996:  MOVFF  267,269
299A:  MOVLW  64
299C:  MOVLB  2
299E:  MOVWF  x6A
29A0:  MOVLB  0
29A2:  CALL   1BE6
29A6:  MOVFF  00,267
29AA:  MOVF   01,W
29AC:  MOVLW  30
29AE:  BNZ   29C0
29B0:  MOVLB  2
29B2:  BTFSS  x68.1
29B4:  BRA    29D4
29B6:  BTFSC  x68.3
29B8:  BRA    29D4
29BA:  BTFSC  x68.4
29BC:  MOVLW  20
29BE:  BRA    29C8
29C0:  MOVLB  2
29C2:  BCF    x68.3
29C4:  BCF    x68.4
29C6:  BSF    x68.0
29C8:  ADDWF  01,F
29CA:  MOVFF  01,270
29CE:  MOVLB  0
29D0:  RCALL  28AC
29D2:  MOVLB  2
29D4:  MOVFF  267,269
29D8:  MOVLW  0A
29DA:  MOVWF  x6A
29DC:  MOVLB  0
29DE:  CALL   1BE6
29E2:  MOVFF  00,267
29E6:  MOVF   01,W
29E8:  MOVLW  30
29EA:  BNZ   29FC
29EC:  MOVLB  2
29EE:  BTFSC  x68.3
29F0:  BRA    2A06
29F2:  BTFSS  x68.0
29F4:  BRA    2A06
29F6:  BTFSC  x68.4
29F8:  MOVLW  20
29FA:  MOVLB  0
29FC:  ADDWF  01,F
29FE:  MOVFF  01,270
2A02:  RCALL  28AC
2A04:  MOVLB  2
2A06:  MOVLW  30
2A08:  ADDWF  x67,F
2A0A:  MOVFF  267,270
2A0E:  MOVLB  0
2A10:  RCALL  28AC
2A12:  GOTO   2A86 (RETURN)
*
4D04:  ADDWF  FE8,W
4D06:  CLRF   FF7
4D08:  RLCF   FF7,F
4D0A:  ADDLW  1F
4D0C:  MOVWF  FF6
4D0E:  MOVLW  4D
4D10:  ADDWFC FF7,F
4D12:  TBLRD*-
4D14:  MOVF   FF5,W
4D16:  MOVWF  FFA
4D18:  TBLRD*
4D1A:  MOVF   FF5,W
4D1C:  MOVWF  FF9
4D1E:  DATA 32,47
4D20:  DATA 32,47
4D22:  DATA 52,47
4D24:  DATA 70,47
4D26:  DATA 8E,47
4D28:  ADDWF  FE8,W
4D2A:  CLRF   FF7
4D2C:  RLCF   FF7,F
4D2E:  ADDLW  43
4D30:  MOVWF  FF6
4D32:  MOVLW  4D
4D34:  ADDWFC FF7,F
4D36:  TBLRD*-
4D38:  MOVF   FF5,W
4D3A:  MOVWF  FFA
4D3C:  TBLRD*
4D3E:  MOVF   FF5,W
4D40:  MOVWF  FF9
4D42:  DATA E4,47
4D44:  DATA E4,47
4D46:  DATA 46,48
4D48:  DATA A6,48
4D4A:  DATA 06,49
4D4C:  ADDWF  FE8,W
4D4E:  CLRF   FF7
4D50:  RLCF   FF7,F
4D52:  ADDLW  67
4D54:  MOVWF  FF6
4D56:  MOVLW  4D
4D58:  ADDWFC FF7,F
4D5A:  TBLRD*-
4D5C:  MOVF   FF5,W
4D5E:  MOVWF  FFA
4D60:  TBLRD*
4D62:  MOVF   FF5,W
4D64:  MOVWF  FF9
4D66:  DATA A0,49
4D68:  DATA A0,49
4D6A:  DATA C0,49
4D6C:  DATA DE,49
4D6E:  DATA FC,49
4D70:  ADDWF  FE8,W
4D72:  CLRF   FF7
4D74:  RLCF   FF7,F
4D76:  ADDLW  8B
4D78:  MOVWF  FF6
4D7A:  MOVLW  4D
4D7C:  ADDWFC FF7,F
4D7E:  TBLRD*-
4D80:  MOVF   FF5,W
4D82:  MOVWF  FFA
4D84:  TBLRD*
4D86:  MOVF   FF5,W
4D88:  MOVWF  FF9
4D8A:  DATA 52,4A
4D8C:  DATA 52,4A
4D8E:  DATA B2,4A
4D90:  DATA 10,4B
4D92:  DATA 6E,4B
.................... 
.................... #list
.................... 
.................... 
.................... #fuses NOLVP, NOPROTECT, NOMCLR, NOWDT
.................... #use delay(clock = 20M, crystal = 20M)
*
05EC:  MOVLW  02
05EE:  MOVWF  FEA
05F0:  MOVLW  79
05F2:  MOVWF  FE9
05F4:  MOVF   FEF,W
05F6:  BZ    0612
05F8:  MOVLW  06
05FA:  MOVWF  01
05FC:  CLRF   00
05FE:  DECFSZ 00,F
0600:  BRA    05FE
0602:  DECFSZ 01,F
0604:  BRA    05FC
0606:  MOVLW  7B
0608:  MOVWF  00
060A:  DECFSZ 00,F
060C:  BRA    060A
060E:  DECFSZ FEF,F
0610:  BRA    05F8
0612:  RETURN 0
.................... 
.................... #include <HDM64GS12.c>
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                           HDM64GS12.c                           ////
.................... ////                                                                 ////
.................... //// This file contains drivers for using a Hantronix HDM64GS12 with ////
.................... //// a KS0108 display controller. The HDM64GS12 is 128 by 64 pixels. ////
.................... //// The driver treats the upper left pixel as (0,0).                ////
.................... ////                                                                 ////
.................... //// Use #define FAST_GLCD if the target chip has at least 1k of RAM ////
.................... //// to decrease the time it takes to update the display.            ////
.................... //// glcd_update() must then be called to update the display after   ////
.................... //// changing the pixel information.                                 ////
.................... //// See ex_glcd.c for suggested usage.                              ////
.................... //// See KS0108.c for controlling a single 64 by 64 display          ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                                                                 ////
.................... //// LCD Pin connections:                                            ////
.................... //// (These can be changed as needed in the following defines).      ////
.................... ////  * 1: VSS is connected to GND                                   ////
.................... ////  * 2: VDD is connected to +5V                                   ////
.................... ////  * 3: V0  - LCD operating voltage (Contrast adjustment)         ////
.................... ////  * 4: D/I - Data or Instruction is connected to B2              ////
.................... ////  * 5: R/W - Read or Write is connected to B4                    ////
.................... ////  * 6: Enable is connected to B5                                 ////
.................... ////  *7-14: Data Bus 0 to 7 is connected to port d                  ////
.................... ////  *15: Chip Select 1 is connected to B0                          ////
.................... ////  *16: Chip Select 2 is connected to B1                          ////
.................... ////  *17: Reset is connected to C0                                  ////
.................... ////  *18: Negative voltage is also connected to the 20k Ohm POT     ////
.................... ////  *19: Positive voltage for LED backlight is connected to +5V    ////
.................... ////  *20: Negative voltage for LED backlight is connected to GND    ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                                                                 ////
.................... ////  glcd_init(mode)                                                ////
.................... ////     * Must be called before any other function.                 ////
.................... ////       - mode can be ON or OFF to turn the LCD on or off         ////
.................... ////                                                                 ////
.................... ////  glcd_pixel(x,y,color)                                          ////
.................... ////     * Sets the pixel to the given color.                        ////
.................... ////       - color can be ON or OFF                                  ////
.................... ////                                                                 ////
.................... ////  glcd_fillScreen(color)                                         ////
.................... ////     * Fills the entire LCD with the given color.                ////
.................... ////       - color can be ON or OFF                                  ////
.................... ////                                                                 ////
.................... ////  glcd_update()                                                  ////
.................... ////     * Write the display data stored in RAM to the LCD           ////
.................... ////     * Only available if FAST_GLCD is defined                    ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////  Version History                                                ////
.................... ////                                                                 ////
.................... ////  05/01/20 - Added defines to selecting the data bus port or     ////
.................... ////             pins used with this driver.                         ////
.................... ////                                                                 ////
.................... ////             GLCD_PORT - to assign the port to use for the GLCD  ////
.................... ////                 data bus pins, for example:                     ////
.................... ////                    #define GLCD_PORT    c                       ////
.................... ////                                                                 ////
.................... ////                 The above assigns it to use PORTC for the data  ////
.................... ////                 bus pins.  Driver defaults to PORTD if          ////
.................... ////                 GLCD_PORT and GLCD_DATA0 are not defined before ////
.................... ////                 this driver is included in project.             ////
.................... ////                                                                 ////
.................... ////             GLCD_DATA0 - to assign the data bus 0 pin.          ////
.................... ////                                                                 ////
.................... ////             GLCD_DATA1 - to assign the data bus 1 pin.          ////
.................... ////                                                                 ////
.................... ////             GLCD_DATA2 - to assign the data bus 2 pin.          ////
.................... ////                                                                 ////
.................... ////             GLCD_DATA3 - to assign the data bus 3 pin.          ////
.................... ////                                                                 ////
.................... ////             GLCD_DATA4 - to assign the data bus 4 pin.          ////
.................... ////                                                                 ////
.................... ////             GLCD_DATA5 - to assign the data bus 5 pin.          ////
.................... ////                                                                 ////
.................... ////             GLCD_DATA6 - to assign the data bus 6 pin.          ////
.................... ////                                                                 ////
.................... ////             GLCD_DATA7 - to assign the data bus 7 pin.          ////
.................... ////                                                                 ////
.................... ////     The defines GLCD_DATA0 to GLCD_DATA7 can only be used to    ////
.................... ////     assign the pins if GLCD_PORT is not defined.  All eight     ////
.................... ////     defines must be defined before this driver is included in   ////
.................... ////     project to make assignments.  No default defines are made   ////
.................... ////     for GLCD_DATA0 to GLCD_DATA7.                               ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services        ////
.................... //// This source code may only be used by licensed users of the CCS  ////
.................... //// C compiler.  This source code may only be distributed to other  ////
.................... //// licensed users of the CCS C compiler.  No other use,            ////
.................... //// reproduction or distribution is permitted without written       ////
.................... //// permission.  Derivative programs created using this software    ////
.................... //// in object code form are not restricted in any way.              ////
.................... /////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef HDM64GS12
.................... #define HDM64GS12
.................... 
.................... #ifndef concat
....................  #define concat(x,y)    x####y
.................... #endif
.................... 
.................... #ifndef GLCD_WIDTH
....................  #define GLCD_WIDTH     128
.................... #endif
.................... 
.................... #ifndef GLCD_CS1
....................  #define GLCD_CS1       PIN_B0   // Chip Selection 1
.................... #endif
.................... 
.................... #ifndef GLCD_CS2
....................  #define GLCD_CS2       PIN_B1   // Chip Selection 2
.................... #endif
.................... 
.................... #ifndef GLCD_DI
....................  #define GLCD_DI        PIN_B2   // Data or Instruction input
.................... #endif
.................... 
.................... #ifndef GLCD_RW
....................  #define GLCD_RW        PIN_B4   // Read/Write
.................... #endif
.................... 
.................... #ifndef GLCD_E
....................  #define GLCD_E         PIN_B5   // Enable
.................... #endif
.................... 
.................... #ifndef GLCD_RST
....................  #define GLCD_RST       PIN_C0   // Reset
.................... #endif
.................... 
.................... #if !defined(GLCD_PORT) && !defined(GLCD_DATA0)
....................  #define GLCD_PORT      d
.................... #elif !defined(GLCD_PORT) && defined(GLCD_DATA0)
....................  #if !defined(GLCD_DATA1) || !defined(GLCD_DATA2) || !defined(GLCD_DATA3) || !defined(GLCD_DATA4) || \
....................      !defined(GLCD_DATA5) || !defined(GLCD_DATA6) || !defined(GLCD_DATA7)
....................   #error not all GLCD Data pins defined.
....................  #endif
.................... #endif
.................... 
.................... #define GLCD_LEFT       0
.................... #define GLCD_RIGHT      1
.................... 
.................... #ifndef ON
....................  #define ON             1
.................... #endif
.................... 
.................... #ifndef OFF
....................  #define OFF            0
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////
.................... // Function Prototypes
.................... /////////////////////////////////////////////////////////////////////////
.................... void glcd_init(int1 mode);
.................... void glcd_pixel(unsigned int8 x, unsigned int8 y, int1 color);
.................... void glcd_fillScreen(int1 color);
.................... void glcd_writeByte(int1 side, BYTE data);
.................... BYTE glcd_readByte(int1 side);
.................... void glcd_update();
.................... /////////////////////////////////////////////////////////////////////////
.................... 
.................... #if defined(GLCD_PORT)
....................  #define WritePort(v)   concat(output_, GLCD_PORT(v))
....................  #define ReadPort()     concat(input_, GLCD_PORT())
....................  #define TrisPort(v)    concat(set_tris_, GLCD_PORT(v))
.................... #else
....................  #define TrisPort(v)
.................... 
....................  void WritePort(unsigned int8 value)
....................  {
....................    output_bit(GLCD_DATA0, bit_test(value, 0));
....................    output_bit(GLCD_DATA1, bit_test(value, 1));
....................    output_bit(GLCD_DATA2, bit_test(value, 2));
....................    output_bit(GLCD_DATA3, bit_test(value, 3));
....................    output_bit(GLCD_DATA4, bit_test(value, 4));
....................    output_bit(GLCD_DATA5, bit_test(value, 5));
....................    output_bit(GLCD_DATA6, bit_test(value, 6));
....................    output_bit(GLCD_DATA7, bit_test(value, 7));
....................  }
....................  
....................  unsigned int8 ReadPort(void)
....................  {
....................    union
....................    {
....................       unsigned int8 b;
....................       int1 bit[8];
....................    } Result;
....................    
....................    Result.bit[0] = input(GLCD_DATA0);
....................    Result.bit[1] = input(GLCD_DATA1);
....................    Result.bit[2] = input(GLCD_DATA2);
....................    Result.bit[3] = input(GLCD_DATA3);
....................    Result.bit[4] = input(GLCD_DATA4);
....................    Result.bit[5] = input(GLCD_DATA5);
....................    Result.bit[6] = input(GLCD_DATA6);
....................    Result.bit[7] = input(GLCD_DATA7);
....................    
....................    return(Result.b);
....................  } 
.................... #endif
.................... 
.................... #ifdef FAST_GLCD
.................... struct
.................... {
....................    unsigned int8 left[512];
....................    unsigned int8 right[512];
.................... } displayData;
.................... #endif
.................... 
.................... 
.................... // Purpose:       Initialize the LCD.
.................... //                Call before using any other LCD function.
.................... // Inputs:        OFF - Turns the LCD off
.................... //                ON  - Turns the LCD on
.................... void glcd_init(int1 mode)
.................... {
....................    // Initialize some pins
....................    output_high(GLCD_RST);
*
06DE:  BCF    F94.0
06E0:  BSF    F8B.0
....................    output_low(GLCD_E);
06E2:  BCF    F93.5
06E4:  BCF    F8A.5
....................    output_low(GLCD_CS1);
06E6:  BCF    F93.0
06E8:  BCF    F8A.0
....................    output_low(GLCD_CS2);
06EA:  BCF    F93.1
06EC:  BCF    F8A.1
.................... 
....................    output_low(GLCD_DI);                 // Set for instruction
06EE:  BCF    F93.2
06F0:  BCF    F8A.2
....................    glcd_writeByte(GLCD_LEFT,  0xC0);    // Specify first RAM line at the top
06F2:  MOVLB  2
06F4:  CLRF   xF8
06F6:  MOVLW  C0
06F8:  MOVWF  xF9
06FA:  MOVLB  0
06FC:  RCALL  0614
....................    glcd_writeByte(GLCD_RIGHT, 0xC0);    //   of the screen
06FE:  MOVLW  01
0700:  MOVLB  2
0702:  MOVWF  xF8
0704:  MOVLW  C0
0706:  MOVWF  xF9
0708:  MOVLB  0
070A:  RCALL  0614
....................    glcd_writeByte(GLCD_LEFT,  0x40);    // Set the column address to 0
070C:  MOVLB  2
070E:  CLRF   xF8
0710:  MOVLW  40
0712:  MOVWF  xF9
0714:  MOVLB  0
0716:  RCALL  0614
....................    glcd_writeByte(GLCD_RIGHT, 0x40);
0718:  MOVLW  01
071A:  MOVLB  2
071C:  MOVWF  xF8
071E:  MOVLW  40
0720:  MOVWF  xF9
0722:  MOVLB  0
0724:  RCALL  0614
....................    glcd_writeByte(GLCD_LEFT,  0xB8);    // Set the page address to 0
0726:  MOVLB  2
0728:  CLRF   xF8
072A:  MOVLW  B8
072C:  MOVWF  xF9
072E:  MOVLB  0
0730:  RCALL  0614
....................    glcd_writeByte(GLCD_RIGHT, 0xB8);
0732:  MOVLW  01
0734:  MOVLB  2
0736:  MOVWF  xF8
0738:  MOVLW  B8
073A:  MOVWF  xF9
073C:  MOVLB  0
073E:  RCALL  0614
.................... 
....................    if(mode == ON)
0740:  MOVLB  2
0742:  DECFSZ x59,W
0744:  BRA    0762
....................    {
....................       glcd_writeByte(GLCD_LEFT,  0x3F); // Turn the display on
0746:  CLRF   xF8
0748:  MOVLW  3F
074A:  MOVWF  xF9
074C:  MOVLB  0
074E:  RCALL  0614
....................       glcd_writeByte(GLCD_RIGHT, 0x3F);
0750:  MOVLW  01
0752:  MOVLB  2
0754:  MOVWF  xF8
0756:  MOVLW  3F
0758:  MOVWF  xF9
075A:  MOVLB  0
075C:  RCALL  0614
....................    }
075E:  BRA    077A
0760:  MOVLB  2
....................    else
....................    {
....................       glcd_writeByte(GLCD_LEFT,  0x3E); // Turn the display off
0762:  CLRF   xF8
0764:  MOVLW  3E
0766:  MOVWF  xF9
0768:  MOVLB  0
076A:  RCALL  0614
....................       glcd_writeByte(GLCD_RIGHT, 0x3E);
076C:  MOVLW  01
076E:  MOVLB  2
0770:  MOVWF  xF8
0772:  MOVLW  3E
0774:  MOVWF  xF9
0776:  MOVLB  0
0778:  RCALL  0614
....................    }
.................... 
....................    glcd_fillScreen(OFF);                // Clear the display
077A:  MOVLB  2
077C:  CLRF   x78
077E:  MOVLB  0
0780:  RCALL  0658
.................... 
....................    #ifdef FAST_GLCD
0782:  GOTO   2F56 (RETURN)
....................    glcd_update();
....................    #endif
.................... }
.................... 
.................... 
.................... // Purpose:    Update the LCD with data from the display arrays
.................... #ifdef FAST_GLCD
.................... void glcd_update()
.................... {
....................    unsigned int8 i, j;
....................    unsigned int8 *p1, *p2;
.................... 
....................    p1 = displayData.left;
....................    p2 = displayData.right;
.................... 
....................    // Loop through the vertical pages
....................    for(i = 0; i < 8; ++i)
....................    {
....................       output_low(GLCD_DI);                      // Set for instruction
....................       glcd_writeByte(GLCD_LEFT, 0x40);          // Set horizontal address to 0
....................       glcd_writeByte(GLCD_RIGHT, 0x40);
....................       glcd_writeByte(GLCD_LEFT, i | 0xB8);      // Set page address
....................       glcd_writeByte(GLCD_RIGHT, i | 0xB8);
....................       output_high(GLCD_DI);                     // Set for data
.................... 
....................       // Loop through the horizontal sections
....................       for(j = 0; j < 64; ++j)
....................       {
....................          glcd_writeByte(GLCD_LEFT, *p1++);      // Turn pixels on or off
....................          glcd_writeByte(GLCD_RIGHT, *p2++);     // Turn pixels on or off
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... 
.................... // Purpose:    Turn a pixel on a graphic LCD on or off
.................... // Inputs:     1) x - the x coordinate of the pixel
.................... //             2) y - the y coordinate of the pixel
.................... //             3) color - ON or OFF
.................... void glcd_pixel(unsigned int8 x, unsigned int8 y, int1 color)
.................... #ifdef FAST_GLCD
*
0816:  MOVLB  2
0818:  BCF    xF5.0
.................... {
....................    unsigned int8* p;
....................    unsigned int16 temp;
....................    temp =  y/8;
....................    temp *= 64;
....................    temp += x;
.................... 
....................    if(x > 63)
....................    {
....................       p = displayData.right + temp - 64;
....................    }
....................    else
....................    {
....................       p = displayData.left + temp;
....................    }
.................... 
....................    if(color)
....................    {
....................       bit_set(*p, y%8);
....................    }
....................    else
....................    {
....................       bit_clear(*p, y%8);
....................    }
.................... }
.................... #else
.................... {
....................    BYTE data;
....................    int1 side = GLCD_LEFT;  // Stores which chip to use on the LCD
.................... 
....................    if(x > 63)              // Check for first or second display area
081A:  MOVF   xF1,W
081C:  SUBLW  3F
081E:  BC    0826
....................    {
....................       x -= 64;
0820:  MOVLW  40
0822:  SUBWF  xF1,F
....................       side = GLCD_RIGHT;
0824:  BSF    xF5.0
....................    }
.................... 
....................    output_low(GLCD_DI);                         // Set for instruction
0826:  BCF    F93.2
0828:  BCF    F8A.2
....................    bit_clear(x,7);                              // Clear the MSB. Part of an instruction code
082A:  BCF    xF1.7
....................    bit_set(x,6);                                // Set bit 6. Also part of an instruction code
082C:  BSF    xF1.6
....................    glcd_writeByte(side, x);                     // Set the horizontal address
082E:  MOVLW  00
0830:  BTFSC  xF5.0
0832:  MOVLW  01
0834:  MOVWF  xF6
0836:  MOVWF  xF8
0838:  MOVFF  2F1,2F9
083C:  MOVLB  0
083E:  RCALL  0614
....................    glcd_writeByte(side, (y/8 & 0xBF) | 0xB8);   // Set the vertical page address
0840:  MOVLW  00
0842:  MOVLB  2
0844:  BTFSC  xF5.0
0846:  MOVLW  01
0848:  MOVWF  xF6
084A:  RRCF   xF2,W
084C:  MOVWF  00
084E:  RRCF   00,F
0850:  RRCF   00,F
0852:  MOVLW  1F
0854:  ANDWF  00,F
0856:  MOVF   00,W
0858:  ANDLW  BF
085A:  IORLW  B8
085C:  MOVWF  xF7
085E:  MOVFF  2F6,2F8
0862:  MOVWF  xF9
0864:  MOVLB  0
0866:  RCALL  0614
....................    output_high(GLCD_DI);                        // Set for data
0868:  BCF    F93.2
086A:  BSF    F8A.2
....................    glcd_readByte(side);                         // Need two reads to get data
086C:  MOVLW  00
086E:  MOVLB  2
0870:  BTFSC  xF5.0
0872:  MOVLW  01
0874:  MOVWF  xF6
0876:  MOVWF  xF7
0878:  MOVLB  0
087A:  RCALL  07D4
....................    data = glcd_readByte(side);                  //  at new address
087C:  MOVLW  00
087E:  MOVLB  2
0880:  BTFSC  xF5.0
0882:  MOVLW  01
0884:  MOVWF  xF6
0886:  MOVWF  xF7
0888:  MOVLB  0
088A:  RCALL  07D4
088C:  MOVFF  01,2F4
.................... 
....................    if(color == ON)
0890:  MOVLB  2
0892:  DECFSZ xF3,W
0894:  BRA    08B4
....................       bit_set(data, y%8);        // Turn the pixel on
0896:  MOVF   xF2,W
0898:  ANDLW  07
089A:  MOVWF  xF6
089C:  MOVLW  01
089E:  MOVWF  00
08A0:  MOVF   xF6,W
08A2:  MOVWF  01
08A4:  BZ    08AE
08A6:  BCF    FD8.0
08A8:  RLCF   00,F
08AA:  DECFSZ 01,F
08AC:  BRA    08A6
08AE:  MOVF   00,W
08B0:  IORWF  xF4,F
08B2:  BRA    08D2
....................    else                          // or
....................       bit_clear(data, y%8);      // turn the pixel off
08B4:  MOVF   xF2,W
08B6:  ANDLW  07
08B8:  MOVWF  xF6
08BA:  MOVLW  01
08BC:  MOVWF  00
08BE:  MOVF   xF6,W
08C0:  MOVWF  01
08C2:  BZ    08CC
08C4:  BCF    FD8.0
08C6:  RLCF   00,F
08C8:  DECFSZ 01,F
08CA:  BRA    08C4
08CC:  MOVF   00,W
08CE:  XORLW  FF
08D0:  ANDWF  xF4,F
.................... 
....................    output_low(GLCD_DI);          // Set for instruction
08D2:  BCF    F93.2
08D4:  BCF    F8A.2
....................    glcd_writeByte(side, x);      // Set the horizontal address
08D6:  MOVLW  00
08D8:  BTFSC  xF5.0
08DA:  MOVLW  01
08DC:  MOVWF  xF6
08DE:  MOVWF  xF8
08E0:  MOVFF  2F1,2F9
08E4:  MOVLB  0
08E6:  RCALL  0614
....................    output_high(GLCD_DI);         // Set for data
08E8:  BCF    F93.2
08EA:  BSF    F8A.2
....................    glcd_writeByte(side, data);   // Write the pixel data
08EC:  MOVLW  00
08EE:  MOVLB  2
08F0:  BTFSC  xF5.0
08F2:  MOVLW  01
08F4:  MOVWF  xF6
08F6:  MOVWF  xF8
08F8:  MOVFF  2F4,2F9
08FC:  MOVLB  0
08FE:  RCALL  0614
0900:  RETURN 0
.................... }
.................... #endif
.................... 
.................... 
.................... // Purpose:    Fill the LCD screen with the passed in color
.................... // Inputs:     ON  - turn all the pixels on
.................... //             OFF - turn all the pixels off
.................... void glcd_fillScreen(int1 color)
.................... #ifdef FAST_GLCD
.................... {
....................    unsigned int8  data;
....................    unsigned int8  *p1, *p2;
....................    unsigned int16 i;
.................... 
....................    p1 = displayData.left;
....................    p2 = displayData.right;
....................    data = 0xFF * color;
.................... 
....................    for(i=0; i<512; ++i)
....................    {
....................       *p1++ = data;
....................       *p2++ = data;
....................    }
.................... }
.................... #else
.................... {
....................    unsigned int8 i, j;
.................... 
....................    // Loop through the vertical pages
....................    for(i = 0; i < 8; ++i)
*
0658:  MOVLB  2
065A:  CLRF   x79
065C:  MOVF   x79,W
065E:  SUBLW  07
0660:  BNC   06DA
....................    {
....................       output_low(GLCD_DI);                      // Set for instruction
0662:  BCF    F93.2
0664:  BCF    F8A.2
....................       glcd_writeByte(GLCD_LEFT, 0b01000000);    // Set horizontal address to 0
0666:  CLRF   xF8
0668:  MOVLW  40
066A:  MOVWF  xF9
066C:  MOVLB  0
066E:  RCALL  0614
....................       glcd_writeByte(GLCD_RIGHT, 0b01000000);
0670:  MOVLW  01
0672:  MOVLB  2
0674:  MOVWF  xF8
0676:  MOVLW  40
0678:  MOVWF  xF9
067A:  MOVLB  0
067C:  RCALL  0614
....................       glcd_writeByte(GLCD_LEFT, i | 0b10111000);// Set page address
067E:  MOVLB  2
0680:  MOVF   x79,W
0682:  IORLW  B8
0684:  MOVWF  x7B
0686:  CLRF   xF8
0688:  MOVWF  xF9
068A:  MOVLB  0
068C:  RCALL  0614
....................       glcd_writeByte(GLCD_RIGHT, i | 0b10111000);
068E:  MOVLB  2
0690:  MOVF   x79,W
0692:  IORLW  B8
0694:  MOVWF  x7B
0696:  MOVLW  01
0698:  MOVWF  xF8
069A:  MOVFF  27B,2F9
069E:  MOVLB  0
06A0:  RCALL  0614
....................       output_high(GLCD_DI);                     // Set for data
06A2:  BCF    F93.2
06A4:  BSF    F8A.2
.................... 
....................       // Loop through the horizontal sections
....................       for(j = 0; j < 64; ++j)
06A6:  MOVLB  2
06A8:  CLRF   x7A
06AA:  MOVF   x7A,W
06AC:  SUBLW  3F
06AE:  BNC   06D6
....................       {
....................          glcd_writeByte(GLCD_LEFT, 0xFF*color);  // Turn pixels on or off
06B0:  MOVF   x78,W
06B2:  MULLW  FF
06B4:  MOVFF  FF3,2F9
06B8:  CLRF   xF8
06BA:  MOVLB  0
06BC:  RCALL  0614
....................          glcd_writeByte(GLCD_RIGHT, 0xFF*color); // Turn pixels on or off
06BE:  MOVLB  2
06C0:  MOVF   x78,W
06C2:  MULLW  FF
06C4:  MOVFF  FF3,2F9
06C8:  MOVLW  01
06CA:  MOVWF  xF8
06CC:  MOVLB  0
06CE:  RCALL  0614
06D0:  MOVLB  2
06D2:  INCF   x7A,F
06D4:  BRA    06AA
....................       }
06D6:  INCF   x79,F
06D8:  BRA    065C
....................    }
06DA:  MOVLB  0
06DC:  RETURN 0
.................... }
.................... #endif
.................... 
.................... 
.................... // Purpose:    Write a byte of data to the specified chip
.................... // Inputs:     1) chipSelect - which chip to write the data to
.................... //             2) data - the byte of data to write
.................... void glcd_writeByte(int1 side, BYTE data)
.................... {
....................    TrisPort(0x00);
*
0614:  MOVLW  00
0616:  MOVWF  F95
....................    
....................    output_low(GLCD_RW);       // Set for writing
0618:  BCF    F93.4
061A:  BCF    F8A.4
.................... 
....................     if(side)                   // Choose which side to write to
061C:  MOVLB  2
061E:  MOVF   xF8,F
0620:  BZ    0628
....................       output_high(GLCD_CS2);
0622:  BCF    F93.1
0624:  BSF    F8A.1
0626:  BRA    062C
....................    else
....................       output_high(GLCD_CS1);
0628:  BCF    F93.0
062A:  BSF    F8A.0
.................... 
....................     delay_us(1);
062C:  BRA    062E
062E:  BRA    0630
0630:  NOP   
.................... 
....................    WritePort(data);           // Put the data on the port
0632:  CLRF   F95
0634:  MOVFF  2F9,F8C
....................    delay_us(1);
0638:  BRA    063A
063A:  BRA    063C
063C:  NOP   
....................    output_high(GLCD_E);       // Pulse the enable pin
063E:  BCF    F93.5
0640:  BSF    F8A.5
....................    delay_us(1);
0642:  BRA    0644
0644:  BRA    0646
0646:  NOP   
....................    output_low(GLCD_E);
0648:  BCF    F93.5
064A:  BCF    F8A.5
.................... 
....................    output_low(GLCD_CS1);      // Reset the chip select lines
064C:  BCF    F93.0
064E:  BCF    F8A.0
....................    output_low(GLCD_CS2);
0650:  BCF    F93.1
0652:  BCF    F8A.1
0654:  MOVLB  0
0656:  RETURN 0
.................... }
.................... 
.................... 
.................... // Purpose:    Reads a byte of data from the specified chip
.................... // Outputs:     A byte of data read from the chip
.................... BYTE glcd_readByte(int1 side)
.................... {
....................    BYTE data;                 // Stores the data read from the LCD
.................... 
....................    TrisPort(0xFF);            // Set port to input
*
07D4:  MOVLW  FF
07D6:  MOVWF  F95
....................    output_high(GLCD_RW);      // Set for reading
07D8:  BCF    F93.4
07DA:  BSF    F8A.4
.................... 
....................    if(side)                   // Choose which side to write to
07DC:  MOVLB  2
07DE:  MOVF   xF7,F
07E0:  BZ    07E8
....................       output_high(GLCD_CS2);
07E2:  BCF    F93.1
07E4:  BSF    F8A.1
07E6:  BRA    07EC
....................    else
....................       output_high(GLCD_CS1);
07E8:  BCF    F93.0
07EA:  BSF    F8A.0
.................... 
....................    delay_us(1);
07EC:  BRA    07EE
07EE:  BRA    07F0
07F0:  NOP   
....................    output_high(GLCD_E);       // Pulse the enable pin
07F2:  BCF    F93.5
07F4:  BSF    F8A.5
....................    delay_us(1);
07F6:  BRA    07F8
07F8:  BRA    07FA
07FA:  NOP   
....................    data = ReadPort();        // Get the data from the display's output register
07FC:  SETF   F95
07FE:  MOVFF  F83,2F8
....................    output_low(GLCD_E);
0802:  BCF    F93.5
0804:  BCF    F8A.5
.................... 
....................    output_low(GLCD_CS1);      // Reset the chip select lines
0806:  BCF    F93.0
0808:  BCF    F8A.0
....................    output_low(GLCD_CS2);
080A:  BCF    F93.1
080C:  BCF    F8A.1
....................    return data;               // Return the read data
080E:  MOVFF  2F8,01
0812:  MOVLB  0
0814:  RETURN 0
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
*
21F0:  MOVLB  2
21F2:  CLRF   x70
21F4:  CLRF   x6F
21F6:  CLRF   x6E
21F8:  MOVLW  7F
21FA:  MOVWF  x6D
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
21FC:  MOVLW  7E
21FE:  MOVWF  x77
2200:  MOVLW  80
2202:  MOVWF  x78
2204:  CLRF   x79
2206:  CLRF   x7A
2208:  MOVLW  7A
220A:  MOVWF  x7B
220C:  MOVLW  2A
220E:  MOVWF  x7C
2210:  MOVLW  AA
2212:  MOVWF  x7D
2214:  MOVLW  A3
2216:  MOVWF  x7E
2218:  MOVLW  75
221A:  MOVWF  x7F
221C:  MOVLW  B6
221E:  MOVWF  x80
2220:  MOVLW  09
2222:  MOVWF  x81
2224:  MOVLW  B4
2226:  MOVWF  x82
2228:  MOVLW  6F
222A:  MOVWF  x83
222C:  MOVLW  4F
222E:  MOVWF  x84
2230:  MOVLW  B6
2232:  MOVWF  x85
2234:  MOVLW  AA
2236:  MOVWF  x86
2238:  MOVLW  69
223A:  MOVWF  x87
223C:  MOVLW  8B
223E:  MOVWF  x88
2240:  MOVLW  F6
2242:  MOVWF  x89
2244:  MOVLW  E8
2246:  MOVWF  x8A
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
2248:  MOVFF  264,28E
224C:  MOVFF  263,28D
2250:  MOVFF  262,28C
2254:  MOVFF  261,28B
2258:  CLRF   x92
225A:  CLRF   x91
225C:  CLRF   x90
225E:  CLRF   x8F
2260:  MOVLB  0
2262:  RCALL  2134
2264:  BNC   2270
2266:  MOVLB  2
2268:  MOVF   x62,W
226A:  XORLW  80
226C:  MOVWF  x62
226E:  MOVLB  0
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
2270:  MOVFF  264,292
2274:  MOVFF  263,291
2278:  MOVFF  262,290
227C:  MOVFF  261,28F
2280:  MOVLW  83
2282:  MOVLB  2
2284:  MOVWF  x96
2286:  MOVLW  F9
2288:  MOVWF  x95
228A:  MOVLW  22
228C:  MOVWF  x94
228E:  MOVLW  7E
2290:  MOVWF  x93
2292:  MOVLB  0
2294:  RCALL  1F52
2296:  MOVFF  03,28E
229A:  MOVFF  02,28D
229E:  MOVFF  01,28C
22A2:  MOVFF  00,28B
22A6:  RCALL  1BAA
22A8:  MOVFF  01,271
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
22AC:  MOVFF  264,292
22B0:  MOVFF  263,291
22B4:  MOVFF  262,290
22B8:  MOVFF  261,28F
22BC:  MOVLW  83
22BE:  MOVLB  2
22C0:  MOVWF  x96
22C2:  MOVLW  F9
22C4:  MOVWF  x95
22C6:  MOVLW  22
22C8:  MOVWF  x94
22CA:  MOVLW  7E
22CC:  MOVWF  x93
22CE:  MOVLB  0
22D0:  RCALL  1F52
22D2:  MOVFF  03,28E
22D6:  MOVFF  02,28D
22DA:  MOVFF  01,28C
22DE:  MOVFF  00,28B
22E2:  MOVLB  2
22E4:  CLRF   x90
22E6:  MOVFF  271,28F
22EA:  MOVLB  0
22EC:  CALL   1A16
22F0:  BSF    FD8.1
22F2:  MOVFF  28E,292
22F6:  MOVFF  28D,291
22FA:  MOVFF  28C,290
22FE:  MOVFF  28B,28F
2302:  MOVFF  03,296
2306:  MOVFF  02,295
230A:  MOVFF  01,294
230E:  MOVFF  00,293
2312:  RCALL  1C12
2314:  MOVFF  03,276
2318:  MOVFF  02,275
231C:  MOVFF  01,274
2320:  MOVFF  00,273
....................    quad = quad % 4;                    // quadrant (0 to 3)
2324:  MOVLW  03
2326:  MOVLB  2
2328:  ANDWF  x71,F
.................... 
....................    if (quad == 0 || quad == 2)
232A:  MOVF   x71,F
232C:  BZ    2334
232E:  MOVF   x71,W
2330:  SUBLW  02
2332:  BNZ   236C
....................       t = frac * PI_DIV_BY_TWO;
2334:  MOVFF  276,292
2338:  MOVFF  275,291
233C:  MOVFF  274,290
2340:  MOVFF  273,28F
2344:  MOVLW  DB
2346:  MOVWF  x96
2348:  MOVLW  0F
234A:  MOVWF  x95
234C:  MOVLW  49
234E:  MOVWF  x94
2350:  MOVLW  7F
2352:  MOVWF  x93
2354:  MOVLB  0
2356:  RCALL  1F52
2358:  MOVFF  03,26C
235C:  MOVFF  02,26B
2360:  MOVFF  01,26A
2364:  MOVFF  00,269
2368:  BRA    2440
236A:  MOVLB  2
....................    else if (quad == 1)
236C:  DECFSZ x71,W
236E:  BRA    23DA
....................       t = (1-frac) * PI_DIV_BY_TWO;
2370:  BSF    FD8.1
2372:  CLRF   x92
2374:  CLRF   x91
2376:  CLRF   x90
2378:  MOVLW  7F
237A:  MOVWF  x8F
237C:  MOVFF  276,296
2380:  MOVFF  275,295
2384:  MOVFF  274,294
2388:  MOVFF  273,293
238C:  MOVLB  0
238E:  RCALL  1C12
2390:  MOVFF  03,28E
2394:  MOVFF  02,28D
2398:  MOVFF  01,28C
239C:  MOVFF  00,28B
23A0:  MOVFF  03,292
23A4:  MOVFF  02,291
23A8:  MOVFF  01,290
23AC:  MOVFF  00,28F
23B0:  MOVLW  DB
23B2:  MOVLB  2
23B4:  MOVWF  x96
23B6:  MOVLW  0F
23B8:  MOVWF  x95
23BA:  MOVLW  49
23BC:  MOVWF  x94
23BE:  MOVLW  7F
23C0:  MOVWF  x93
23C2:  MOVLB  0
23C4:  RCALL  1F52
23C6:  MOVFF  03,26C
23CA:  MOVFF  02,26B
23CE:  MOVFF  01,26A
23D2:  MOVFF  00,269
23D6:  BRA    2440
23D8:  MOVLB  2
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
23DA:  BSF    FD8.1
23DC:  MOVFF  276,292
23E0:  MOVFF  275,291
23E4:  MOVFF  274,290
23E8:  MOVFF  273,28F
23EC:  CLRF   x96
23EE:  CLRF   x95
23F0:  CLRF   x94
23F2:  MOVLW  7F
23F4:  MOVWF  x93
23F6:  MOVLB  0
23F8:  RCALL  1C12
23FA:  MOVFF  03,28E
23FE:  MOVFF  02,28D
2402:  MOVFF  01,28C
2406:  MOVFF  00,28B
240A:  MOVFF  03,292
240E:  MOVFF  02,291
2412:  MOVFF  01,290
2416:  MOVFF  00,28F
241A:  MOVLW  DB
241C:  MOVLB  2
241E:  MOVWF  x96
2420:  MOVLW  0F
2422:  MOVWF  x95
2424:  MOVLW  49
2426:  MOVWF  x94
2428:  MOVLW  7F
242A:  MOVWF  x93
242C:  MOVLB  0
242E:  RCALL  1F52
2430:  MOVFF  03,26C
2434:  MOVFF  02,26B
2438:  MOVFF  01,26A
243C:  MOVFF  00,269
.................... 
....................    y = 1.0;
2440:  MOVLB  2
2442:  CLRF   x68
2444:  CLRF   x67
2446:  CLRF   x66
2448:  MOVLW  7F
244A:  MOVWF  x65
....................    t = t * t;
244C:  MOVFF  26C,292
2450:  MOVFF  26B,291
2454:  MOVFF  26A,290
2458:  MOVFF  269,28F
245C:  MOVFF  26C,296
2460:  MOVFF  26B,295
2464:  MOVFF  26A,294
2468:  MOVFF  269,293
246C:  MOVLB  0
246E:  RCALL  1F52
2470:  MOVFF  03,26C
2474:  MOVFF  02,26B
2478:  MOVFF  01,26A
247C:  MOVFF  00,269
....................    for (i = 0; i <= 4; i++)
2480:  MOVLB  2
2482:  CLRF   x72
2484:  MOVF   x72,W
2486:  SUBLW  04
2488:  BNC   2542
....................    {
....................       t2 = t2 * t;
248A:  MOVFF  270,292
248E:  MOVFF  26F,291
2492:  MOVFF  26E,290
2496:  MOVFF  26D,28F
249A:  MOVFF  26C,296
249E:  MOVFF  26B,295
24A2:  MOVFF  26A,294
24A6:  MOVFF  269,293
24AA:  MOVLB  0
24AC:  RCALL  1F52
24AE:  MOVFF  03,270
24B2:  MOVFF  02,26F
24B6:  MOVFF  01,26E
24BA:  MOVFF  00,26D
....................       y = y + p[i] * t2;
24BE:  MOVLB  2
24C0:  MOVF   x72,W
24C2:  MULLW  04
24C4:  MOVF   FF3,W
24C6:  CLRF   03
24C8:  ADDLW  77
24CA:  MOVWF  FE9
24CC:  MOVLW  02
24CE:  ADDWFC 03,W
24D0:  MOVWF  FEA
24D2:  MOVFF  FEF,28F
24D6:  MOVFF  FEC,290
24DA:  MOVFF  FEC,291
24DE:  MOVFF  FEC,292
24E2:  MOVFF  270,296
24E6:  MOVFF  26F,295
24EA:  MOVFF  26E,294
24EE:  MOVFF  26D,293
24F2:  MOVLB  0
24F4:  RCALL  1F52
24F6:  MOVFF  FEA,28C
24FA:  MOVFF  FE9,28B
24FE:  BCF    FD8.1
2500:  MOVFF  268,292
2504:  MOVFF  267,291
2508:  MOVFF  266,290
250C:  MOVFF  265,28F
2510:  MOVFF  03,296
2514:  MOVFF  02,295
2518:  MOVFF  01,294
251C:  MOVFF  00,293
2520:  CALL   1C12
2524:  MOVFF  28C,FEA
2528:  MOVFF  28B,FE9
252C:  MOVFF  03,268
2530:  MOVFF  02,267
2534:  MOVFF  01,266
2538:  MOVFF  00,265
253C:  MOVLB  2
253E:  INCF   x72,F
2540:  BRA    2484
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
2542:  MOVF   x71,W
2544:  SUBLW  02
2546:  BZ    254C
2548:  DECFSZ x71,W
254A:  BRA    2552
....................       y = -y;  // correct sign
254C:  MOVF   x66,W
254E:  XORLW  80
2550:  MOVWF  x66
.................... 
....................    return (y);
2552:  MOVFF  265,00
2556:  MOVFF  266,01
255A:  MOVFF  267,02
255E:  MOVFF  268,03
2562:  MOVLB  0
2564:  RETURN 0
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
2566:  BSF    FD8.1
2568:  MOVFF  25C,292
256C:  MOVFF  25B,291
2570:  MOVFF  25A,290
2574:  MOVFF  259,28F
2578:  MOVLW  DB
257A:  MOVLB  2
257C:  MOVWF  x96
257E:  MOVLW  0F
2580:  MOVWF  x95
2582:  MOVLW  49
2584:  MOVWF  x94
2586:  MOVLW  7F
2588:  MOVWF  x93
258A:  MOVLB  0
258C:  CALL   1C12
2590:  MOVFF  03,260
2594:  MOVFF  02,25F
2598:  MOVFF  01,25E
259C:  MOVFF  00,25D
25A0:  MOVFF  03,264
25A4:  MOVFF  02,263
25A8:  MOVFF  01,262
25AC:  MOVFF  00,261
25B0:  RCALL  21F0
25B2:  GOTO   3CC0 (RETURN)
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... #include <stdlibm.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... /*********************************************************************/
.................... #ifndef _STDLIBM
.................... #define _STDLIBM
.................... 
.................... /* Memory Management Functions*/
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #if defined(__PCB__)
.................... typedef struct nodet {
....................    unsigned int8 size;
....................    unsigned int8 next; }node_t;
.................... #elif defined(__PCM__)
.................... typedef struct nodet {
....................    unsigned int8 size;
....................    unsigned int16 next; }node_t;
.................... #elif defined(__PCH__)
.................... typedef struct nodet {
....................    unsigned int16 size;
....................    unsigned int16 next; }node_t;
.................... #elif defined(__PCD__)
.................... typedef struct nodet {
....................    unsigned int16 size;
....................    unsigned int16 next; }node_t;
.................... #endif
.................... 
.................... #if !defined(STDLIBM_MANUAL_DYNAMIC_MEMORY)
....................    #USE DYNAMIC_MEMORY
.................... #endif
.................... 
.................... #ifndef debug_stdlibm
....................    #define debug_stdlibm(s)
.................... #else
....................    #define __DO_DEBUG_STDLIBM
....................    
....................    char g_DebugStdlibmStr[50];
....................    
....................    #if defined(__PCD__)
....................       #if (defined(__PIC24E__)||defined(__dsPIC33E__))
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x800)) || bit_test(x, 0))
....................       #else
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x1000)) || bit_test(x, 0))
....................       #endif
....................    #else
....................       #define INVALID_MEMORY_LOCATION(x) (x >= getenv("RAM"))
....................    #endif
.................... #endif
.................... 
.................... #if defined(STDLIBM_TRACK_WORST_CASE)
....................    static size_t _g_StdlibmCurrentBytesUsed = 0;
....................    static size_t _g_StdlibmWorstCaseBytesUsed = 0;
....................    
....................    #define _STDLIBM_TRACK_WORST_INC(_x) \
....................       _g_StdlibmCurrentBytesUsed += _x;   \
....................       if (_g_StdlibmCurrentBytesUsed > _g_StdlibmWorstCaseBytesUsed) \
....................          _g_StdlibmWorstCaseBytesUsed = _g_StdlibmCurrentBytesUsed
....................    
....................    #define _STDLIBM_TRACK_WORST_DEC(_x) _g_StdlibmCurrentBytesUsed-=_x
.................... #else
....................    #define _STDLIBM_TRACK_WORST_INC(_x)
....................    #define _STDLIBM_TRACK_WORST_DEC(_x)
.................... #endif
.................... 
.................... #include <memmgmt.c>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #if defined(__PCH__)
....................  #define _MEMMGMT_CSIZE 32768
....................  #define _MEMMGMT_POS 15
.................... #elif defined(__PCD__)
....................    #define _MEMMGMT_CSIZE 32768
....................    #define _MEMMGMT_POS 15
.................... #else
....................    #define _MEMMGMT_CSIZE 127
....................    #define _MEMMGMT_POS 7
.................... #endif
.................... 
.................... node_t * create_node(unsigned int16 size, node_t *ptr) // create node at given location
.................... {
....................    node_t *result;
....................    result =ptr;
....................    result->size=size;
....................    result->next = NULL;
....................    return result;
.................... }
.................... void update_node(node_t *node, unsigned int16 size) // update the size of given node
.................... {
....................    node->size=size;
.................... }
.................... 
.................... /* Insert node immediately after place */ //old,new
.................... void insert_node_after(node_t *place, node_t *node)// place the node after another given node
.................... {
....................     if (place->next==NULL)
....................        node->next= NULL;
....................     else
....................        node->next=place->next;
....................     place->next=node;
.................... }
.................... 
.................... /////////////////////////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... void remove_node(node_t *node) {// remove the given node from the memlist
....................    node_t *ptr;
....................    for(ptr=__DYNAMIC_HEAD;ptr->next!=node;ptr=ptr->next);
....................    ptr->next=node->next;
....................    node=NULL;
.................... }
.................... 
.................... /////////////////////////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... #if defined(__DO_DEBUG_STDLIBM)
.................... void print_list() { // print the current memlist
....................     node_t *node;
....................     debug_stdlibm("\r\nThe list is \n\r");
....................     for(node = __DYNAMIC_HEAD; node != NULL; node = node->next)
....................     {
....................         sprintf(g_DebugStdlibmStr, "H:0x%lx S:0x%lx N:0x%lx\n\r", node, node->size, node->next);
....................         debug_stdlibm(g_DebugStdlibmStr);
....................         if (INVALID_MEMORY_LOCATION(node->next))
....................         {
....................            debug_stdlibm("Breaking because of invalid next node\r\n");
....................            break;
....................         }   
....................     }
....................     sprintf(g_DebugStdlibmStr, "size of node_t %u\r\n",sizeof(node_t));
....................     debug_stdlibm(g_DebugStdlibmStr);
.................... }
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... void traverse()
.................... {
....................    node_t *node,*temp;
....................    unsigned int16 nsize,nextsize;
....................    node=__DYNAMIC_HEAD;
....................    while(node!=NULL)
....................    {
....................      #if defined(__DO_DEBUG_STDLIBM)
....................       if (INVALID_MEMORY_LOCATION(node))
....................       {
....................          sprintf(g_DebugStdlibmStr, "traverse() invalid node (0x%LX)\r\n", node);
....................          debug_stdlibm(g_DebugStdlibmStr);
....................          break;
....................       }   
....................      #endif
....................      if(!bit_test(node->size,_MEMMGMT_POS))// node free
....................       {
....................          nsize=node->size;
....................          temp=(unsigned int16)node->next;
....................         #if defined(__DO_DEBUG_STDLIBM)
....................          if (INVALID_MEMORY_LOCATION(temp))
....................          {
....................             sprintf(g_DebugStdlibmStr, "traverse() invalid temp (0x%LX)\r\n", node);
....................             debug_stdlibm(g_DebugStdlibmStr);
....................             break;
....................          }
....................         #endif
....................          if(!bit_test(temp->size,_MEMMGMT_POS)&& (temp==((unsigned int16)node+nsize+sizeof(node_t))))//next node free and consecutive, so combine
....................          {
....................             nextsize=temp->size;
....................             nsize+=nextsize+sizeof(node_t);
....................             remove_node(temp);
....................             update_node(node,nsize);
....................          }
....................          else
....................          node=node->next;
....................       }
....................       else
....................       node=node->next;
....................    }
.................... }
.................... 
.................... char *malloc(size_t size)
.................... {
....................    node_t *node,*new;
....................    unsigned int16 nsize;
....................    #if defined(__PCD__)
....................    if (size % 2)
....................       size++;
....................    #endif
....................    node=__DYNAMIC_HEAD;
....................    
....................   #if defined(__DO_DEBUG_STDLIBM)
....................    sprintf(g_DebugStdlibmStr, "malloc() size=%lu ", size);
....................    debug_stdlibm(g_DebugStdlibmStr);
....................   #endif
....................         
....................    while(node!=NULL) // chk until end of memlist
....................    {
....................      #if defined(__DO_DEBUG_STDLIBM)
....................       if (INVALID_MEMORY_LOCATION(node))
....................       {
....................          sprintf(g_DebugStdlibmStr, " invalid node (0x%LX)\r\n", node);
....................          debug_stdlibm(g_DebugStdlibmStr);
....................          print_list();
....................          return(0);
....................       }
....................      #endif
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=size) // node is free and > = req size
....................       {
....................          nsize=node->size;    //nsize = size of the node that "node" being pointed at
....................          if(nsize>size +sizeof(node_t)) //node > req size, so split and add new node to memlist
....................          {
....................             new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size);
....................             insert_node_after(node,new);
....................             update_node(node,size+_MEMMGMT_CSIZE);
....................          }
....................          else//not enough space for new node so use original size
....................          update_node(node,nsize+_MEMMGMT_CSIZE);
....................          //end if
....................          break;
....................       }//end if
....................       node=node->next;
....................    }//end while
....................    if(node==NULL)// reached end without finding an appropriate node
....................    {
....................       debug_stdlibm("Not enough memory for mallocation\r\n");
....................       return NULL;
....................    }
....................    else
....................    {
....................      #if defined(__DO_DEBUG_STDLIBM)
....................       sprintf(g_DebugStdlibmStr, "%LX\r\n", (char *)node+sizeof(node_t));
....................       debug_stdlibm(g_DebugStdlibmStr);
....................      #endif
....................       _STDLIBM_TRACK_WORST_INC(size);
....................       return (char *)node+sizeof(node_t); // return pounsigned int8er to allocated space
....................    }
.................... }
.................... 
.................... char *calloc(size_t nmemb,size_t size)
.................... {
....................    node_t *node,*new;
....................    unsigned int16 nsize,resize;
....................    node=__DYNAMIC_HEAD;
....................    resize=nmemb*size;
....................    #if defined(__PCD__)
....................    if(resize%2)
....................       resize++;
....................    #endif
....................    while(node!=NULL) // chk until end of memlist
....................    {
....................      #if defined(__DO_DEBUG_STDLIBM)
....................       if (INVALID_MEMORY_LOCATION(node))
....................       {
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node);
....................          debug_stdlibm(g_DebugStdlibmStr);
....................          print_list();
....................          return(0);
....................       }
....................      #endif
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=resize)// node is free and > = req size
....................       {
....................          nsize=node->size;
....................          if(nsize>resize+sizeof(node_t))//node > req size, so split and add new node to memlist
....................          {
....................             new=create_node(nsize-resize-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+resize);
....................             insert_node_after(node,new);
....................             update_node(node,resize+_MEMMGMT_CSIZE);
....................          }
....................          else//not enough space for new node so use original size
....................          update_node(node,nsize+_MEMMGMT_CSIZE);
....................          //end if
....................          break;
....................       }//end if
....................       node=node->next;
....................    }//end while
....................    if(node==NULL)// reached end without finding an appropriate node
....................    {
....................       debug_stdlibm("Not enough memory for callocation\r\n");
....................       return NULL;
....................    }
....................    else
....................    {
....................       memset((unsigned int16)node+sizeof(node_t),0,resize);// initialize to 0
....................       _STDLIBM_TRACK_WORST_INC(resize);
....................       return (char *)(unsigned int16)node+sizeof(node_t);// return pounsigned int8er to allocated space
....................    }
.................... }
.................... void free( void * ptr)
.................... {
....................    node_t *node;
....................    unsigned int16 nsize;
.................... 
....................   #if defined(__DO_DEBUG_STDLIBM)
....................    sprintf(g_DebugStdlibmStr, "free() 0x%LX\r\n", ptr);
....................    debug_stdlibm(g_DebugStdlibmStr);
....................   #endif
.................... 
....................    if(ptr==NULL) // not a valid pounsigned int8er
....................       return;
....................    else
....................    {
....................       node=ptr-sizeof(node_t);
....................       if(bit_test(node->size,_MEMMGMT_POS))// node occupied
....................       {
....................          nsize=node->size-_MEMMGMT_CSIZE;
....................          update_node(node,nsize);
....................          ptr=NULL;
....................          _STDLIBM_TRACK_WORST_DEC(nsize);
....................       }
....................       else // wrong input, return
....................       {
....................          ptr=NULL;
....................          return;
....................       }
....................    }
....................    traverse();
.................... }
.................... 
.................... char *realloc(void *ptr,size_t size)
.................... {
....................    node_t *node,*new,*temp;
....................    unsigned int16 nsize,nextsize;
....................    char *newptr;
....................    #if defined(__PCD__)
....................    if(size %2)
....................       size++;
....................    #endif
....................    if(ptr==NULL)// null pounsigned int8er, so malloc the req memory
....................       return(malloc(size));
....................    else if(size==0)
....................    {
....................       free(ptr);
....................       return(NULL);
....................    }
....................    else
....................    {
....................       node=ptr-sizeof(node_t);
....................       if(bit_test(node->size,_MEMMGMT_POS))// chk if valid pounsigned int8er
....................       {
....................          nsize=node->size-_MEMMGMT_CSIZE;
....................          temp=(unsigned int16)node->next;
....................          if(nsize>size)// block > req size
....................          {
....................        
....................                if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive
....................                {
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block
....................                   nextsize=temp->size;
....................                   remove_node(temp);
....................                   new=create_node(nextsize+(nsize-size),(unsigned int16)node+size+sizeof(node_t));
....................                   insert_node_after(node,new);
....................                   _STDLIBM_TRACK_WORST_DEC(nsize);
....................                   _STDLIBM_TRACK_WORST_INC(size);
....................                }
....................                else if (nsize>size +sizeof(node_t))//node > req size, so split and add new node to memlist
....................                {
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block
....................                   new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size);
....................                   insert_node_after(node,new);
....................                   _STDLIBM_TRACK_WORST_DEC(nsize);
....................                   _STDLIBM_TRACK_WORST_INC(size);
....................                }
....................                else//not enough space for new node so use original size
....................                update_node(node,nsize+_MEMMGMT_CSIZE); // update block
.................... 
....................          }
....................          else // block < req size
....................          {
....................             if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive
....................             {
....................                nextsize=temp->size;
....................                if(nextsize>=size-nsize) // next block >=difference
....................                {
....................                   if(nextsize>size-nsize+sizeof(node_t))//next node > req size, so split and add new node to memlist
....................                   {
....................                       update_node(node,size+_MEMMGMT_CSIZE);// update block
....................                       remove_node(temp);
....................                       new=create_node(nextsize-(size-nsize),(unsigned int16)node+size+sizeof(node_t));
....................                       insert_node_after(node,new);
....................                      _STDLIBM_TRACK_WORST_DEC(nsize);
....................                      _STDLIBM_TRACK_WORST_INC(size);
....................                   }
....................                   else//not enough space for new node in next node, so use original size
....................                   {
....................                       update_node(node,nsize+nextsize+_MEMMGMT_CSIZE);// update block
....................                       remove_node(temp);
....................                   }
....................                }
....................                else  //next block free but too small for new size
....................                {
....................                   newptr = malloc(size);  //use malloc to find new block
....................                   if(newptr == NULL)
....................                      return(NULL);        //return NULL if malloc was unable to find new block
....................                    
....................                   memcpy(newptr, ptr, nsize);   //copy original data to new block
....................                   free(ptr);                    //free original block
....................                   return(newptr);               //return new pointer
....................                }
....................             }
....................             else  //next block not free
....................             {
....................                newptr = malloc(size);  //use malloc to find new block
....................                if(newptr == NULL)      
....................                   return(NULL);        //return NULL if malloc was unable to find new block
....................                
....................                memcpy(newptr, ptr, nsize);   //copy original data to new block
....................                free(ptr);                    //free original block
....................                return(newptr);               //return new pointer
....................             }
....................          }
....................          return (char *)node+sizeof(node_t); // return pounsigned int8er to the reallocated block
....................       }
....................       else // not allocated use malloc
....................       {
....................          return(malloc(size));
....................       }
....................    }
....................  }
....................  
.................... typedef struct
.................... {
....................    size_t bytesUsed;
....................    size_t largestUsedSeg;
....................    int segmentsUsed;
....................    size_t bytesFree;
....................    size_t largestFreeSeg;
....................    int segmentsFree;
....................   #if defined(STDLIBM_TRACK_WORST_CASE)
....................    size_t worstCaseBytesUsed;
....................   #endif
.................... } heap_status_t;
.................... 
.................... void GetHeapStatus(heap_status_t *pHeapStatus)
.................... {
....................    heap_status_t status;
....................    node_t *node;
....................    unsigned int16 nsize;
....................    
....................    node=__DYNAMIC_HEAD;
....................    
....................    memset(&status, 0, sizeof(status));
.................... 
....................    while(node!=NULL)
....................    {
....................       nsize = node->size;
....................       node = node->next;
....................       
....................       if(!bit_test(nsize, _MEMMGMT_POS)) // node free
....................       {
....................          status.bytesFree += nsize;
....................          
....................          status.segmentsFree++;
....................          
....................          if (nsize > status.largestFreeSeg)
....................          {
....................             status.largestFreeSeg = nsize;
....................          }
....................       }
....................       else
....................       {
....................          bit_clear(nsize, _MEMMGMT_POS);
....................          
....................          status.bytesUsed += nsize;
....................          
....................          status.segmentsUsed++;
....................          
....................          if (nsize > status.largestUsedSeg)
....................          {
....................             status.largestUsedSeg = nsize;
....................          }
....................       }
....................    }
.................... 
....................   #if defined(STDLIBM_TRACK_WORST_CASE)
....................    status.worstCaseBytesUsed = _g_StdlibmWorstCaseBytesUsed;
....................   #endif
.................... 
....................    memcpy(pHeapStatus, &status, sizeof(heap_status_t));
.................... }
.................... #ENDIF
.................... 
.................... 
.................... #include "setup_disp.h"
.................... 
.................... const BYTE TEXT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // !
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // "
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // #
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // %
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // &
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // '
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // (
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // )
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // *
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // +
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // ,
....................                          0x08, 0x08, 0x08, 0x08, 0x08, // -
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // .
....................                          0x20, 0x10, 0x08, 0x04, 0x02, // /
....................                          0x3E, 0x51, 0x49, 0x45, 0x3E, // 0
....................                          0x04, 0x02, 0x7F, 0x00, 0x00, // 1
....................                          0x42, 0x61, 0x51, 0x49, 0x46, // 2
....................                          0x22, 0x41, 0x49, 0x49, 0x36, // 3
....................                          0x18, 0x14, 0x12, 0x7F, 0x10, // 4
....................                          0x27, 0x45, 0x45, 0x45, 0x39, // 5
....................                          0x3E, 0x49, 0x49, 0x49, 0x32, // 6
....................                          0x01, 0x01, 0x71, 0x09, 0x07, // 7
....................                          0x36, 0x49, 0x49, 0x49, 0x36, // 8
....................                          0x26, 0x49, 0x49, 0x49, 0x3E, // 9
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // :
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ;
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // <
....................                          0x14, 0x14, 0x14, 0x14, 0x14, // =
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // >
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ?
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @
....................                          0x7E, 0x09, 0x09, 0x09, 0x7E, // A
....................                          0x7F, 0x49, 0x49, 0x49, 0x36, // B
....................                          0x3E, 0x41, 0x41, 0x41, 0x22, // C
....................                          0x7F, 0x41, 0x41, 0x41, 0x3E, // D
....................                          0x7F, 0x49, 0x49, 0x49, 0x41, // E
....................                          0x7F, 0x09, 0x09, 0x09, 0x01, // F
....................                          0x3E, 0x41, 0x41, 0x49, 0x3A, // G
....................                          0x7F, 0x08, 0x08, 0x08, 0x7F, // H
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I
....................                          0x30, 0x40, 0x40, 0x40, 0x3F, // J
....................                          0x7F, 0x08, 0x14, 0x22, 0x41, // K
....................                          0x7F, 0x40, 0x40, 0x40, 0x40, // L
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N
....................                          0x3E, 0x41, 0x41, 0x41, 0x3E, // O
....................                          0x7F, 0x09, 0x09, 0x09, 0x06, // P
....................                          0x1E, 0x21, 0x21, 0x21, 0x5E, // Q
....................                          0x7F, 0x09, 0x09, 0x09, 0x76};// R
.................... 
.................... const BYTE TEXT2[44][5]={0x26, 0x49, 0x49, 0x49, 0x32, // S
....................                          0x01, 0x01, 0x7F, 0x01, 0x01, // T
....................                          0x3F, 0x40, 0x40, 0x40, 0x3F, // U
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y
....................                          0x61, 0x51, 0x49, 0x45, 0x43, // Z
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ]
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^
....................                          0x40, 0x40, 0x40, 0x40, 0x40, // _
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // `
....................                          0x20, 0x54, 0x54, 0x54, 0x78, // a
....................                          0x7F, 0x44, 0x44, 0x44, 0x38, // b
....................                          0x38, 0x44, 0x44, 0x44, 0x44, // c
....................                          0x38, 0x44, 0x44, 0x44, 0x7F, // d
....................                          0x38, 0x54, 0x54, 0x54, 0x18, // e
....................                          0x04, 0x04, 0x7E, 0x05, 0x05, // f
....................                          0x08, 0x54, 0x54, 0x54, 0x3C, // g
....................                          0x7F, 0x08, 0x04, 0x04, 0x78, // h
....................                          0x00, 0x44, 0x7D, 0x40, 0x00, // i
....................                          0x20, 0x40, 0x44, 0x3D, 0x00, // j
....................                          0x7F, 0x10, 0x28, 0x44, 0x00, // k
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m
....................                          0x7C, 0x08, 0x04, 0x04, 0x78, // n
....................                          0x38, 0x44, 0x44, 0x44, 0x38, // o
....................                          0x7C, 0x14, 0x14, 0x14, 0x08, // p
....................                          0x08, 0x14, 0x14, 0x14, 0x7C, // q
....................                          0x00, 0x7C, 0x08, 0x04, 0x04, // r
....................                          0x48, 0x54, 0x54, 0x54, 0x20, // s
....................                          0x04, 0x04, 0x3F, 0x44, 0x44, // t
....................                          0x3C, 0x40, 0x40, 0x20, 0x7C, // u
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x
....................                          0x0C, 0x50, 0x50, 0x50, 0x3C, // y
....................                          0x44, 0x64, 0x54, 0x4C, 0x44, // z
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // {
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // |
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // }
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~
.................... 
.................... int personaje[16][16] = {
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0},
....................     {0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0},
....................     {0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0},
....................     {0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0},
....................     {0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0},
....................     {0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0},
....................     {0,0,0,1,1,1,1,0,0,1,1,1,1,0,0,0},
....................     {0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0},
....................     {0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0},
....................     {0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0},
....................     {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},
....................     {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... const int levels[30][20] = {
....................     {0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
....................     {3,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,2,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,2,0,0,1,0,1,0,0,0,0,0,0,1,0,1,0,0},
....................     {0,0,0,0,0,0,0,3,0,0,3,0,3,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... 
.................... 
.................... #use rs232(rcv = pin_c7, xmit = pin_c6, baud = 9600, bits = 8, parity = n)
.................... 
.................... // nave
.................... float last_ship_angle_1 = 0;
.................... float ship_angle_1 = 0;
.................... int last_x_pos_1;
.................... int last_y_pos_1;
.................... int x_pos_1 = 64;
.................... int y_pos_1 = 32;
.................... float dx_1 = 0;
.................... float dy_1 = 0;
.................... 
.................... float last_ship_angle_2 = 0;
.................... float ship_angle_2 = 0;
.................... int last_x_pos_2;
.................... int last_y_pos_2;
.................... int x_pos_2 = 64;
.................... int y_pos_2 = 32;
.................... float dx_2 = 0;
.................... float dy_2 = 0;
.................... 
.................... int1 shoot_1 = 1;
.................... int cooldown_1 = 20;
.................... int aiming_1 = 0;
.................... 
.................... void rect(int x1, int y1, int x2, int y2);
.................... 
.................... int1 shoot_2 = 1;
.................... int cooldown_2 = 20;
.................... int aiming_2 = 0;
.................... 
.................... float last_ship_angle = 0;
.................... float ship_angle = 0;
.................... int last_x_pos;
.................... int last_y_pos;
.................... int x_pos = 64;
.................... int y_pos = 32;
.................... float dx = 0;
.................... float dy = 0;
.................... 
.................... void explic_s();
.................... void explic_m();
.................... // bala
.................... int1 bullet = 0;
.................... signed int last_last_bullet_x_pos;
.................... signed int last_last_bullet_y_pos;
.................... signed int last_bullet_x_pos;
.................... signed int last_bullet_y_pos;
.................... signed int16 bullet_x_pos;
.................... signed int16 bullet_y_pos;
.................... float bullet_dx = 0;
.................... float bullet_dy = 0;
.................... const float bullet_speed = 6;
.................... 
.................... int1 bullet_1 = 0;
.................... signed int last_last_bullet_x_pos_1;
.................... signed int last_last_bullet_y_pos_1;
.................... signed int last_bullet_x_pos_1;
.................... signed int last_bullet_y_pos_1;
.................... signed int16 bullet_x_pos_1;
.................... signed int16 bullet_y_pos_1;
.................... float bullet_dx_1 = 0;
.................... float bullet_dy_1 = 0;
.................... int1 bullet_collision_1 = 0;
.................... 
.................... int1 bullet_2 = 0;
.................... signed int last_last_bullet_x_pos_2;
.................... signed int last_last_bullet_y_pos_2;
.................... signed int last_bullet_x_pos_2;
.................... signed int last_bullet_y_pos_2;
.................... signed int16 bullet_x_pos_2;
.................... signed int16 bullet_y_pos_2;
.................... float bullet_dx_2 = 0;
.................... float bullet_dy_2 = 0;
.................... int1 bullet_collision_2 = 0;
.................... // asteroides
.................... 
.................... int last_asteroids_x_pos[20];
.................... int last_asteroids_y_pos[20];
.................... unsigned int asteroids_x_pos[20];
.................... unsigned int asteroids_y_pos[20];
.................... signed int asteroids_dx[20] = {-2, 1, -3, 3, -2, 3, -1, 2, -3, 3, -2, 2, -1, 2, -1, 2, -2, 3, -2, -1};
.................... signed int asteroids_dy[20] = {2, -1, -2, 3, -2, 2, -1, 1, -2, 3, -1, 3, -2, -1, 2, -3, -3, 3, -2, 1};
.................... 
.................... unsigned int level = 0;
.................... unsigned int best_level = 0;
.................... int1 new_level = 1;
.................... unsigned int16 score = 0;
.................... unsigned int16 best_score = 0;
.................... unsigned int16 last_score = 10;
.................... unsigned int last_level = 10;
.................... 
.................... const float internal_angle = (2 * (float)PI) / 3.0f;
.................... // dibujar
.................... void glcd_line(int x1, int y1, int x2, int y2, int1 color);
.................... void draw_triangle(int x, int y, float starting_angle, int1 color);
.................... void glcd_lineTracing(int *xx, int *yy, int n_points, int1 color);
.................... void draw_asteroid(int x, int y, int life, int1 color);
.................... void glcd_text57(int x, int y, char *textptr, int size, int1 color);
.................... void inicio(int sec);
.................... void scores(unsigned int16 scr, unsigned int lvl, int1 color);
.................... void single_menu(int1 play);
.................... int laser_waza(int x, int y);
.................... 
.................... float get_ship_angle(int x, int y);
.................... float get_x_vel();
.................... float get_y_vel();
.................... 
.................... char dataRS232;
.................... 
.................... char mode = 'i';
.................... char mode_inic = 't';
.................... 
.................... int1 flagg = 1;
.................... int1 flag_rec = 0;
.................... 
.................... int current_data = 0;
.................... 
.................... unsigned int p1_pot_x = 125;
.................... unsigned int p1_pot_y = 125;
.................... unsigned int p1_pot_xx = 125;
.................... unsigned int p1_pot_yy = 125;
.................... int1 p1_L = 0;
.................... int1 p1_R = 0;
.................... 
.................... float calc_ang_x(int x, int y);
.................... float calc_ang_y(int x, int y);
.................... 
.................... float get_d(unsigned int pp)
.................... {
....................    return (float)((float)pp - 127.0f) / 30.0f;
*
2AA6:  MOVLB  2
2AA8:  CLRF   x90
2AAA:  MOVFF  259,28F
2AAE:  MOVLB  0
2AB0:  CALL   1A16
2AB4:  MOVFF  03,25D
2AB8:  MOVFF  02,25C
2ABC:  MOVFF  01,25B
2AC0:  MOVFF  00,25A
2AC4:  BSF    FD8.1
2AC6:  MOVFF  03,292
2ACA:  MOVFF  02,291
2ACE:  MOVFF  01,290
2AD2:  MOVFF  00,28F
2AD6:  MOVLB  2
2AD8:  CLRF   x96
2ADA:  CLRF   x95
2ADC:  MOVLW  7E
2ADE:  MOVWF  x94
2AE0:  MOVLW  85
2AE2:  MOVWF  x93
2AE4:  MOVLB  0
2AE6:  CALL   1C12
2AEA:  MOVFF  03,25D
2AEE:  MOVFF  02,25C
2AF2:  MOVFF  01,25B
2AF6:  MOVFF  00,25A
2AFA:  MOVFF  03,264
2AFE:  MOVFF  02,263
2B02:  MOVFF  01,262
2B06:  MOVFF  00,261
2B0A:  MOVLB  2
2B0C:  CLRF   x68
2B0E:  CLRF   x67
2B10:  MOVLW  70
2B12:  MOVWF  x66
2B14:  MOVLW  83
2B16:  MOVWF  x65
2B18:  MOVLB  0
2B1A:  CALL   1A4C
2B1E:  RETURN 0
.................... }
.................... 
.................... unsigned int p2_pot_x = 125;
.................... unsigned int p2_pot_y = 125;
.................... unsigned int p2_pot_xx = 125;
.................... unsigned int p2_pot_yy = 125;
.................... int1 p2_L = 0;
.................... int1 p2_R = 0;
.................... 
.................... #int_rda
.................... void rcv_data()
.................... {
.................... 
....................    dataRS232 = getch();
*
0510:  BTFSS  F9E.5
0512:  BRA    0510
0514:  MOVFF  FAE,20D
0518:  MOVLB  2
.................... 
....................    switch (current_data)
051A:  MOVF   x11,W
051C:  ADDLW  F7
051E:  BC    05AE
0520:  ADDLW  09
0522:  MOVLB  0
0524:  GOTO   05C0
....................    {
....................    case 0:
....................       p1_pot_y = dataRS232; // x
0528:  MOVFF  20D,213
....................       break;
052C:  MOVLB  2
052E:  BRA    05AE
....................    case 1:
....................       p1_pot_x = dataRS232; // y
0530:  MOVFF  20D,212
....................       break;
0534:  MOVLB  2
0536:  BRA    05AE
....................    case 2:
....................       p1_pot_xx = dataRS232;
0538:  MOVFF  20D,214
....................       break;
053C:  MOVLB  2
053E:  BRA    05AE
....................    case 3:
....................       p1_pot_yy = dataRS232;
0540:  MOVFF  20D,215
....................       break;
0544:  MOVLB  2
0546:  BRA    05AE
....................    case 4:
....................       p2_pot_y = dataRS232;
0548:  MOVFF  20D,217
....................       break;
054C:  MOVLB  2
054E:  BRA    05AE
....................    case 5:
....................       p2_pot_x = dataRS232;
0550:  MOVFF  20D,216
....................       break;
0554:  MOVLB  2
0556:  BRA    05AE
....................    case 6:
....................       p2_pot_xx = dataRS232;
0558:  MOVFF  20D,218
....................       break;
055C:  MOVLB  2
055E:  BRA    05AE
....................    case 7:
....................       p2_pot_yy = dataRS232;
0560:  MOVFF  20D,219
....................       break;
0564:  MOVLB  2
0566:  BRA    05AE
....................    case 8:
....................       p1_L = (dataRS232 & 0x01) ? 1 : 0;
0568:  MOVLB  2
056A:  BTFSS  x0D.0
056C:  BRA    0572
056E:  MOVLW  01
0570:  BRA    0574
0572:  MOVLW  00
0574:  BCF    x10.2
0576:  BTFSC  FE8.0
0578:  BSF    x10.2
....................       p1_R = (dataRS232 & 0x02) ? 1 : 0;
057A:  BTFSS  x0D.1
057C:  BRA    0582
057E:  MOVLW  01
0580:  BRA    0584
0582:  MOVLW  00
0584:  BCF    x10.3
0586:  BTFSC  FE8.0
0588:  BSF    x10.3
....................       p2_L = (dataRS232 & 0x04) ? 1 : 0;
058A:  BTFSS  x0D.2
058C:  BRA    0592
058E:  MOVLW  01
0590:  BRA    0594
0592:  MOVLW  00
0594:  BCF    x10.4
0596:  BTFSC  FE8.0
0598:  BSF    x10.4
....................       p2_R = (dataRS232 & 0x08) ? 1 : 0;
059A:  BTFSS  x0D.3
059C:  BRA    05A2
059E:  MOVLW  01
05A0:  BRA    05A4
05A2:  MOVLW  00
05A4:  BCF    x10.5
05A6:  BTFSC  FE8.0
05A8:  BSF    x10.5
....................       break;
05AA:  BRA    05AE
05AC:  MOVLB  2
....................    }
.................... 
....................    current_data++;
05AE:  INCF   x11,F
....................    if (current_data == 9)
05B0:  MOVF   x11,W
05B2:  SUBLW  09
05B4:  BNZ   05B8
....................       current_data = 0;
05B6:  CLRF   x11
05B8:  BCF    F9E.5
05BA:  MOVLB  0
05BC:  GOTO   0060
.................... }
.................... 
.................... void draw_cuadrito(int x, int y, int1 col);
.................... 
.................... void draw_win(int1 w){
....................    if(w){
*
2B5E:  MOVLB  2
2B60:  MOVF   x59,F
2B62:  BZ    2BDE
....................       glcd_fillScreen(1);
2B64:  MOVLW  01
2B66:  MOVWF  x78
2B68:  MOVLB  0
2B6A:  CALL   0658
....................       char text_asteroids[] = "PLAYER 1 WINS!";
2B6E:  MOVLW  50
2B70:  MOVLB  2
2B72:  MOVWF  x5A
2B74:  MOVLW  4C
2B76:  MOVWF  x5B
2B78:  MOVLW  41
2B7A:  MOVWF  x5C
2B7C:  MOVLW  59
2B7E:  MOVWF  x5D
2B80:  MOVLW  45
2B82:  MOVWF  x5E
2B84:  MOVLW  52
2B86:  MOVWF  x5F
2B88:  MOVLW  20
2B8A:  MOVWF  x60
2B8C:  MOVLW  31
2B8E:  MOVWF  x61
2B90:  MOVLW  20
2B92:  MOVWF  x62
2B94:  MOVLW  57
2B96:  MOVWF  x63
2B98:  MOVLW  49
2B9A:  MOVWF  x64
2B9C:  MOVLW  4E
2B9E:  MOVWF  x65
2BA0:  MOVLW  53
2BA2:  MOVWF  x66
2BA4:  MOVLW  21
2BA6:  MOVWF  x67
2BA8:  CLRF   x68
....................       glcd_text57(29, 22, text_asteroids, 1, 0);
2BAA:  MOVLW  1D
2BAC:  MOVWF  xDF
2BAE:  MOVLW  16
2BB0:  MOVWF  xE0
2BB2:  MOVLW  02
2BB4:  MOVWF  xE2
2BB6:  MOVLW  5A
2BB8:  MOVWF  xE1
2BBA:  MOVLW  01
2BBC:  MOVWF  xE3
2BBE:  CLRF   xE4
2BC0:  MOVLB  0
2BC2:  CALL   0B0C
....................       delay_ms(500);
2BC6:  MOVLW  02
2BC8:  MOVLB  2
2BCA:  MOVWF  x78
2BCC:  MOVLW  FA
2BCE:  MOVWF  x79
2BD0:  MOVLB  0
2BD2:  CALL   05EC
2BD6:  MOVLB  2
2BD8:  DECFSZ x78,F
2BDA:  BRA    2BCC
....................    }
2BDC:  BRA    2C56
....................    else{
....................       glcd_fillScreen(1);
2BDE:  MOVLW  01
2BE0:  MOVWF  x78
2BE2:  MOVLB  0
2BE4:  CALL   0658
....................       char text_asteroids[] = "PLAYER 2 WINS!";
2BE8:  MOVLW  50
2BEA:  MOVLB  2
2BEC:  MOVWF  x69
2BEE:  MOVLW  4C
2BF0:  MOVWF  x6A
2BF2:  MOVLW  41
2BF4:  MOVWF  x6B
2BF6:  MOVLW  59
2BF8:  MOVWF  x6C
2BFA:  MOVLW  45
2BFC:  MOVWF  x6D
2BFE:  MOVLW  52
2C00:  MOVWF  x6E
2C02:  MOVLW  20
2C04:  MOVWF  x6F
2C06:  MOVLW  32
2C08:  MOVWF  x70
2C0A:  MOVLW  20
2C0C:  MOVWF  x71
2C0E:  MOVLW  57
2C10:  MOVWF  x72
2C12:  MOVLW  49
2C14:  MOVWF  x73
2C16:  MOVLW  4E
2C18:  MOVWF  x74
2C1A:  MOVLW  53
2C1C:  MOVWF  x75
2C1E:  MOVLW  21
2C20:  MOVWF  x76
2C22:  CLRF   x77
....................       glcd_text57(29, 22, text_asteroids, 1, 0);
2C24:  MOVLW  1D
2C26:  MOVWF  xDF
2C28:  MOVLW  16
2C2A:  MOVWF  xE0
2C2C:  MOVLW  02
2C2E:  MOVWF  xE2
2C30:  MOVLW  69
2C32:  MOVWF  xE1
2C34:  MOVLW  01
2C36:  MOVWF  xE3
2C38:  CLRF   xE4
2C3A:  MOVLB  0
2C3C:  CALL   0B0C
....................       delay_ms(500);
2C40:  MOVLW  02
2C42:  MOVLB  2
2C44:  MOVWF  x78
2C46:  MOVLW  FA
2C48:  MOVWF  x79
2C4A:  MOVLB  0
2C4C:  CALL   05EC
2C50:  MOVLB  2
2C52:  DECFSZ x78,F
2C54:  BRA    2C46
....................    }
2C56:  MOVLB  0
2C58:  RETURN 0
.................... }
.................... 
.................... void restart_screen()
.................... {
....................    glcd_fillScreen(0);
*
1998:  MOVLB  2
199A:  CLRF   x78
199C:  MOVLB  0
199E:  CALL   0658
....................    char text_asteroids[] = "Presiona para restart";
19A2:  MOVLW  50
19A4:  MOVLB  2
19A6:  MOVWF  x59
19A8:  MOVLW  72
19AA:  MOVWF  x5A
19AC:  MOVLW  65
19AE:  MOVWF  x5B
19B0:  MOVLW  73
19B2:  MOVWF  x5C
19B4:  MOVLW  69
19B6:  MOVWF  x5D
19B8:  MOVLW  6F
19BA:  MOVWF  x5E
19BC:  MOVLW  6E
19BE:  MOVWF  x5F
19C0:  MOVLW  61
19C2:  MOVWF  x60
19C4:  MOVLW  20
19C6:  MOVWF  x61
19C8:  MOVLW  70
19CA:  MOVWF  x62
19CC:  MOVLW  61
19CE:  MOVWF  x63
19D0:  MOVLW  72
19D2:  MOVWF  x64
19D4:  MOVLW  61
19D6:  MOVWF  x65
19D8:  MOVLW  20
19DA:  MOVWF  x66
19DC:  MOVLW  72
19DE:  MOVWF  x67
19E0:  MOVLW  65
19E2:  MOVWF  x68
19E4:  MOVLW  73
19E6:  MOVWF  x69
19E8:  MOVLW  74
19EA:  MOVWF  x6A
19EC:  MOVLW  61
19EE:  MOVWF  x6B
19F0:  MOVLW  72
19F2:  MOVWF  x6C
19F4:  MOVLW  74
19F6:  MOVWF  x6D
19F8:  CLRF   x6E
....................    glcd_text57(0, 0, text_asteroids, 1, 1);
19FA:  CLRF   xDF
19FC:  CLRF   xE0
19FE:  MOVLW  02
1A00:  MOVWF  xE2
1A02:  MOVLW  59
1A04:  MOVWF  xE1
1A06:  MOVLW  01
1A08:  MOVWF  xE3
1A0A:  MOVWF  xE4
1A0C:  MOVLB  0
1A0E:  CALL   0B0C
1A12:  GOTO   31CE (RETURN)
.................... }
.................... void grafico_control();
.................... 
.................... void main()
*
2D24:  CLRF   FF8
2D26:  BCF    FD0.7
2D28:  BSF    07.7
2D2A:  BSF    FB8.3
2D2C:  MOVLW  08
2D2E:  MOVWF  FAF
2D30:  MOVLW  02
2D32:  MOVWF  FB0
2D34:  MOVLW  A6
2D36:  MOVWF  FAC
2D38:  MOVLW  90
2D3A:  MOVWF  FAB
2D3C:  MOVLB  1
2D3E:  CLRF   x1E
2D40:  CLRF   x1D
2D42:  CLRF   x1C
2D44:  CLRF   x1B
2D46:  CLRF   x22
2D48:  CLRF   x21
2D4A:  CLRF   x20
2D4C:  CLRF   x1F
2D4E:  MOVLW  40
2D50:  MOVWF  x25
2D52:  MOVLW  20
2D54:  MOVWF  x26
2D56:  CLRF   x2A
2D58:  CLRF   x29
2D5A:  CLRF   x28
2D5C:  CLRF   x27
2D5E:  CLRF   x2E
2D60:  CLRF   x2D
2D62:  CLRF   x2C
2D64:  CLRF   x2B
2D66:  CLRF   x32
2D68:  CLRF   x31
2D6A:  CLRF   x30
2D6C:  CLRF   x2F
2D6E:  CLRF   x36
2D70:  CLRF   x35
2D72:  CLRF   x34
2D74:  CLRF   x33
2D76:  MOVLW  40
2D78:  MOVWF  x39
2D7A:  MOVLW  20
2D7C:  MOVWF  x3A
2D7E:  CLRF   x3E
2D80:  CLRF   x3D
2D82:  CLRF   x3C
2D84:  CLRF   x3B
2D86:  CLRF   x42
2D88:  CLRF   x41
2D8A:  CLRF   x40
2D8C:  CLRF   x3F
2D8E:  BSF    x43.0
2D90:  MOVLW  14
2D92:  MOVWF  x44
2D94:  CLRF   x45
2D96:  BSF    x43.1
2D98:  MOVWF  x46
2D9A:  CLRF   x47
2D9C:  CLRF   x4B
2D9E:  CLRF   x4A
2DA0:  CLRF   x49
2DA2:  CLRF   x48
2DA4:  CLRF   x4F
2DA6:  CLRF   x4E
2DA8:  CLRF   x4D
2DAA:  CLRF   x4C
2DAC:  MOVLW  40
2DAE:  MOVWF  x52
2DB0:  MOVLW  20
2DB2:  MOVWF  x53
2DB4:  CLRF   x57
2DB6:  CLRF   x56
2DB8:  CLRF   x55
2DBA:  CLRF   x54
2DBC:  CLRF   x5B
2DBE:  CLRF   x5A
2DC0:  CLRF   x59
2DC2:  CLRF   x58
2DC4:  BCF    x43.2
2DC6:  CLRF   x67
2DC8:  CLRF   x66
2DCA:  CLRF   x65
2DCC:  CLRF   x64
2DCE:  CLRF   x6B
2DD0:  CLRF   x6A
2DD2:  CLRF   x69
2DD4:  CLRF   x68
2DD6:  BCF    x43.3
2DD8:  CLRF   x77
2DDA:  CLRF   x76
2DDC:  CLRF   x75
2DDE:  CLRF   x74
2DE0:  CLRF   x7B
2DE2:  CLRF   x7A
2DE4:  CLRF   x79
2DE6:  CLRF   x78
2DE8:  BCF    x43.4
2DEA:  BCF    x43.5
2DEC:  CLRF   x87
2DEE:  CLRF   x86
2DF0:  CLRF   x85
2DF2:  CLRF   x84
2DF4:  CLRF   x8B
2DF6:  CLRF   x8A
2DF8:  CLRF   x89
2DFA:  CLRF   x88
2DFC:  BCF    x43.6
2DFE:  MOVLB  2
2E00:  CLRF   x04
2E02:  CLRF   x05
2E04:  MOVLB  1
2E06:  BSF    x43.7
2E08:  MOVLB  2
2E0A:  CLRF   x07
2E0C:  CLRF   x06
2E0E:  CLRF   x09
2E10:  CLRF   x08
2E12:  CLRF   x0B
2E14:  MOVLW  0A
2E16:  MOVWF  x0A
2E18:  MOVWF  x0C
2E1A:  MOVLW  69
2E1C:  MOVWF  x0E
2E1E:  MOVLW  74
2E20:  MOVWF  x0F
2E22:  BSF    x10.0
2E24:  BCF    x10.1
2E26:  CLRF   x11
2E28:  MOVLW  7D
2E2A:  MOVWF  x12
2E2C:  MOVWF  x13
2E2E:  MOVWF  x14
2E30:  MOVWF  x15
2E32:  BCF    x10.2
2E34:  BCF    x10.3
2E36:  MOVWF  x16
2E38:  MOVWF  x17
2E3A:  MOVWF  x18
2E3C:  MOVWF  x19
2E3E:  BCF    x10.4
2E40:  BCF    x10.5
2E42:  CLRF   x1B
2E44:  CLRF   x1A
2E46:  MOVF   FC1,W
2E48:  ANDLW  C0
2E4A:  IORLW  0F
2E4C:  MOVWF  FC1
2E4E:  MOVLW  07
2E50:  MOVWF  FB4
2E52:  MOVLW  02
2E54:  MOVWF  1A
2E56:  MOVLW  FA
2E58:  MOVWF  19
2E5A:  MOVLW  05
2E5C:  MOVWF  xFB
2E5E:  MOVLW  02
2E60:  MOVWF  xFA
2E62:  CLRF   xFD
2E64:  CLRF   xFC
2E66:  MOVLB  0
2E68:  BRA    2EFA
2E6A:  DATA 16,40
2E6C:  DATA 1B,00
2E6E:  DATA 04,C0
2E70:  DATA 01,0B
2E72:  DATA C0,00
2E74:  DATA 06,C0
2E76:  DATA 01,09
2E78:  DATA C0,00
2E7A:  DATA 08,C0
2E7C:  DATA 01,08
2E7E:  DATA C0,00
2E80:  DATA 08,C0
2E82:  DATA 01,09
2E84:  DATA C0,00
2E86:  DATA 06,C0
2E88:  DATA 01,0B
2E8A:  DATA C0,00
2E8C:  DATA 04,C0
2E8E:  DATA 01,1A
2E90:  DATA C0,00
2E92:  DATA 02,80
2E94:  DATA 01,01
2E96:  DATA 04,C0
2E98:  DATA 00,02
2E9A:  DATA 80,01
2E9C:  DATA 01,07
2E9E:  DATA C0,00
2EA0:  DATA 04,C0
2EA2:  DATA 01,02
2EA4:  DATA 80,00
2EA6:  DATA 00,04
2EA8:  DATA C0,01
2EAA:  DATA 06,C0
2EAC:  DATA 00,0A
2EAE:  DATA C0,01
2EB0:  DATA 05,C0
2EB2:  DATA 00,0C
2EB4:  DATA C0,01
2EB6:  DATA 04,C0
2EB8:  DATA 00,0C
2EBA:  DATA C0,01
2EBC:  DATA 03,80
2EBE:  DATA 00,00
2EC0:  DATA 00,0E
2EC2:  DATA C0,01
2EC4:  DATA 02,80
2EC6:  DATA 00,00
2EC8:  DATA 0E,C0
2ECA:  DATA 01,11
2ECC:  DATA C0,00
2ECE:  DATA 28,01
2ED0:  DATA DC,FE
2ED2:  DATA 01,FD
2ED4:  DATA 03,FE
2ED6:  DATA 03,FF
2ED8:  DATA 02,FD
2EDA:  DATA 03,FE
2EDC:  DATA 02,FF
2EDE:  DATA 02,FF
2EE0:  DATA 02,FE
2EE2:  DATA 03,FE
2EE4:  DATA FF,02
2EE6:  DATA FF,FE
2EE8:  DATA 03,FE
2EEA:  DATA 02,FF
2EEC:  DATA 01,FE
2EEE:  DATA 03,FF
2EF0:  DATA 03,FE
2EF2:  DATA FF,02
2EF4:  DATA FD,FD
2EF6:  DATA 03,FE
2EF8:  DATA 01,00
2EFA:  MOVLW  00
2EFC:  MOVWF  FF8
2EFE:  MOVLW  2E
2F00:  MOVWF  FF7
2F02:  MOVLW  6A
2F04:  MOVWF  FF6
2F06:  TBLRD*+
2F08:  MOVF   FF5,W
2F0A:  MOVWF  00
2F0C:  XORLW  00
2F0E:  BZ    2F36
2F10:  TBLRD*+
2F12:  MOVF   FF5,W
2F14:  MOVWF  01
2F16:  BTFSC  FE8.7
2F18:  BRA    2F24
2F1A:  ANDLW  3F
2F1C:  MOVWF  FEA
2F1E:  TBLRD*+
2F20:  MOVF   FF5,W
2F22:  MOVWF  FE9
2F24:  BTFSC  01.6
2F26:  TBLRD*+
2F28:  BTFSS  01.6
2F2A:  TBLRD*+
2F2C:  MOVF   FF5,W
2F2E:  MOVWF  FEE
2F30:  DCFSNZ 00,F
2F32:  BRA    2F06
2F34:  BRA    2F28
2F36:  CLRF   FF8
.................... {
.................... 
....................    enable_interrupts(GLOBAL);
2F38:  MOVLW  C0
2F3A:  IORWF  FF2,F
....................    enable_interrupts(int_rda);
2F3C:  BSF    F9D.5
.................... 
....................    delay_ms(100);
2F3E:  MOVLW  64
2F40:  MOVLB  2
2F42:  MOVWF  x79
2F44:  MOVLB  0
2F46:  CALL   05EC
.................... 
....................    glcd_init(ON);
2F4A:  MOVLW  01
2F4C:  MOVLB  2
2F4E:  MOVWF  x59
2F50:  MOVLB  0
2F52:  GOTO   06DE
....................    glcd_fillScreen(0);
2F56:  MOVLB  2
2F58:  CLRF   x78
2F5A:  MOVLB  0
2F5C:  CALL   0658
.................... 
....................    int inic_men = 0;
....................    int last_inic_men = 0;
.................... 
....................    int single_men = 0;
....................    int last_single_men = 0;
.................... 
....................    
.................... 
....................    int1 win = 0;
....................    int1 who = 0;
.................... 
....................    int1 bullet_collision = 0;
....................    int sfx_time;
.................... 
....................    int asteroids_lifes[20]; // puede haber hasta 20 asteroides en la pantalla;
....................    int1 asteroid_lost_a_life[20] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
*
2F70:  CLRF   x36
2F72:  CLRF   x37
2F74:  CLRF   x38
.................... 
....................    int temp = 0;
....................    int1 new_game = 0;
*
2F60:  MOVLB  2
2F62:  CLRF   x1C
2F64:  CLRF   x1D
2F66:  CLRF   x1E
2F68:  CLRF   x1F
2F6A:  BCF    x20.0
2F6C:  BCF    x20.1
2F6E:  BCF    x20.2
*
2F76:  CLRF   x39
2F78:  BCF    x20.3
.................... 
....................    grafico_control();
2F7A:  MOVLB  0
2F7C:  GOTO   0C7C
....................    delay_ms(5000);
2F80:  MOVLW  14
2F82:  MOVLB  2
2F84:  MOVWF  x59
2F86:  MOVLW  FA
2F88:  MOVWF  x79
2F8A:  MOVLB  0
2F8C:  CALL   05EC
2F90:  MOVLB  2
2F92:  DECFSZ x59,F
2F94:  BRA    2F86
.................... 
....................    inicio(1);
2F96:  MOVLW  01
2F98:  MOVWF  x59
2F9A:  MOVLB  0
2F9C:  CALL   0DDE
.................... 
....................    while (TRUE)
....................    {
....................       switch (mode)
2FA0:  MOVLB  2
2FA2:  MOVF   x0E,W
2FA4:  XORLW  69
2FA6:  MOVLB  0
2FA8:  BZ    2FC6
2FAA:  XORLW  1A
2FAC:  BZ    305A
2FAE:  XORLW  1E
2FB0:  BTFSC  FD8.2
2FB2:  BRA    30E0
2FB4:  XORLW  07
2FB6:  BTFSC  FD8.2
2FB8:  BRA    3168
2FBA:  XORLW  20
2FBC:  BTFSC  FD8.2
2FBE:  GOTO   425E
2FC2:  GOTO   4CF4
....................       {
....................       case 'i':
....................       { // inicio
....................          if (p1_pot_y > 125)
2FC6:  MOVLB  2
2FC8:  MOVF   x13,W
2FCA:  SUBLW  7D
2FCC:  BC    2FD2
....................          {
....................             inic_men = 0;
2FCE:  CLRF   x1C
....................          }
2FD0:  BRA    2FE2
....................          else
....................          {
....................             if (p1_pot_x > 125)
2FD2:  MOVF   x12,W
2FD4:  SUBLW  7D
2FD6:  BC    2FDE
....................             {
....................                inic_men = 2;
2FD8:  MOVLW  02
2FDA:  MOVWF  x1C
....................             }
2FDC:  BRA    2FE2
....................             else
....................             {
....................                inic_men = 1;
2FDE:  MOVLW  01
2FE0:  MOVWF  x1C
....................             }
....................          }
.................... 
....................          if (inic_men != last_inic_men)
2FE2:  MOVF   x1D,W
2FE4:  SUBWF  x1C,W
2FE6:  BZ    2FFA
....................          {
....................             glcd_fillScreen(0);
2FE8:  CLRF   x78
2FEA:  MOVLB  0
2FEC:  CALL   0658
....................             inicio(inic_men);
2FF0:  MOVFF  21C,259
2FF4:  CALL   0DDE
2FF8:  MOVLB  2
....................          }
....................          if (p1_R)
2FFA:  BTFSS  x10.3
2FFC:  BRA    3050
....................          {
....................             switch (inic_men)
2FFE:  MOVF   x1C,W
3000:  XORLW  01
3002:  MOVLB  0
3004:  BZ    300C
3006:  XORLW  03
3008:  BZ    3028
300A:  BRA    3044
....................             {
....................             case 1:
....................                mode = 's';
300C:  MOVLW  73
300E:  MOVLB  2
3010:  MOVWF  x0E
....................                glcd_fillScreen(0);
3012:  CLRF   x78
3014:  MOVLB  0
3016:  CALL   0658
....................                single_menu(1);
301A:  MOVLW  01
301C:  MOVLB  2
301E:  MOVWF  x59
3020:  MOVLB  0
3022:  CALL   13C6
....................                break;
3026:  BRA    304E
....................             case 2:
....................                mode = 'm';
3028:  MOVLW  6D
302A:  MOVLB  2
302C:  MOVWF  x0E
....................                glcd_fillScreen(0);
302E:  CLRF   x78
3030:  MOVLB  0
3032:  CALL   0658
....................                single_menu(1);
3036:  MOVLW  01
3038:  MOVLB  2
303A:  MOVWF  x59
303C:  MOVLB  0
303E:  CALL   13C6
....................                break;
3042:  BRA    304E
....................             default:
....................                mode = 'i';
3044:  MOVLW  69
3046:  MOVLB  2
3048:  MOVWF  x0E
....................                new_game = 1;
304A:  BSF    x20.3
....................                break;
304C:  MOVLB  0
304E:  MOVLB  2
....................             }
....................          }
.................... 
....................          last_inic_men = inic_men;
3050:  MOVFF  21C,21D
....................          break;
3054:  GOTO   4CF6
3058:  MOVLB  0
....................       }
....................       case 's':
....................       { // single
....................          if (p1_pot_y >= 125)
305A:  MOVLB  2
305C:  MOVF   x13,W
305E:  SUBLW  7C
3060:  BC    3068
....................          {
....................             single_men = 1;
3062:  MOVLW  01
3064:  MOVWF  x1E
....................          }
3066:  BRA    306A
....................          else
....................          {
....................             single_men = 0;
3068:  CLRF   x1E
....................          }
.................... 
....................          if (single_men != last_single_men)
306A:  MOVF   x1F,W
306C:  SUBWF  x1E,W
306E:  BZ    3082
....................          {
....................             glcd_fillScreen(0);
3070:  CLRF   x78
3072:  MOVLB  0
3074:  CALL   0658
....................             single_menu(single_men);
3078:  MOVFF  21E,259
307C:  CALL   13C6
3080:  MOVLB  2
....................          }
.................... 
....................          if (p1_L)
3082:  BTFSS  x10.2
3084:  BRA    30D6
....................          {
....................             switch (single_men)
3086:  MOVF   x1E,W
3088:  XORLW  00
308A:  MOVLB  0
308C:  BZ    3094
308E:  XORLW  01
3090:  BZ    30A4
3092:  BRA    30D4
....................             {
....................             case 0:
....................                mode = 'i';
3094:  MOVLW  69
3096:  MOVLB  2
3098:  MOVWF  x0E
....................                glcd_fillScreen(0);
309A:  CLRF   x78
309C:  MOVLB  0
309E:  CALL   0658
....................                break;
30A2:  BRA    30D4
....................             case 1:
....................                mode = 'j';
30A4:  MOVLW  6A
30A6:  MOVLB  2
30A8:  MOVWF  x0E
....................                glcd_fillScreen(0);
30AA:  CLRF   x78
30AC:  MOVLB  0
30AE:  CALL   0658
....................                explic_s();
30B2:  GOTO   1684
....................                delay_ms(3000);
30B6:  MOVLW  0C
30B8:  MOVLB  2
30BA:  MOVWF  x59
30BC:  MOVLW  FA
30BE:  MOVWF  x79
30C0:  MOVLB  0
30C2:  CALL   05EC
30C6:  MOVLB  2
30C8:  DECFSZ x59,F
30CA:  BRA    30BC
....................                glcd_fillScreen(0);
30CC:  CLRF   x78
30CE:  MOVLB  0
30D0:  CALL   0658
....................                break;
30D4:  MOVLB  2
....................             }
....................          }
.................... 
....................          last_single_men = single_men;
30D6:  MOVFF  21E,21F
....................          break;
30DA:  GOTO   4CF6
30DE:  MOVLB  0
....................       }
....................       case 'm':
....................       { // multiplayer
....................          if (p1_pot_y >= 125)
30E0:  MOVLB  2
30E2:  MOVF   x13,W
30E4:  SUBLW  7C
30E6:  BC    30EE
....................          {
....................             single_men = 1;
30E8:  MOVLW  01
30EA:  MOVWF  x1E
....................          }
30EC:  BRA    30F0
....................          else
....................          {
....................             single_men = 0;
30EE:  CLRF   x1E
....................          }
.................... 
....................          if (single_men != last_single_men)
30F0:  MOVF   x1F,W
30F2:  SUBWF  x1E,W
30F4:  BZ    3108
....................          {
....................             glcd_fillScreen(0);
30F6:  CLRF   x78
30F8:  MOVLB  0
30FA:  CALL   0658
....................             single_menu(single_men);
30FE:  MOVFF  21E,259
3102:  CALL   13C6
3106:  MOVLB  2
....................          }
.................... 
....................          if (p1_L)
3108:  BTFSS  x10.2
310A:  BRA    315E
....................          {
....................             switch (single_men)
310C:  MOVF   x1E,W
310E:  XORLW  00
3110:  MOVLB  0
3112:  BZ    311A
3114:  XORLW  01
3116:  BZ    312A
3118:  BRA    315C
....................             {
....................             case 0:
....................                mode = 'i';
311A:  MOVLW  69
311C:  MOVLB  2
311E:  MOVWF  x0E
....................                glcd_fillScreen(0);
3120:  CLRF   x78
3122:  MOVLB  0
3124:  CALL   0658
....................                break;
3128:  BRA    315C
....................             case 1:
....................                mode = 'J';
312A:  MOVLW  4A
312C:  MOVLB  2
312E:  MOVWF  x0E
....................                new_game = 1;
3130:  BSF    x20.3
....................                glcd_fillScreen(0);
3132:  CLRF   x78
3134:  MOVLB  0
3136:  CALL   0658
....................                explic_m();
313A:  GOTO   17FC
....................                delay_ms(3000);
313E:  MOVLW  0C
3140:  MOVLB  2
3142:  MOVWF  x59
3144:  MOVLW  FA
3146:  MOVWF  x79
3148:  MOVLB  0
314A:  CALL   05EC
314E:  MOVLB  2
3150:  DECFSZ x59,F
3152:  BRA    3144
....................                glcd_fillScreen(0);
3154:  CLRF   x78
3156:  MOVLB  0
3158:  CALL   0658
....................                break;
315C:  MOVLB  2
....................             }
....................          }
.................... 
....................          last_single_men = single_men;
315E:  MOVFF  21E,21F
....................          break;
3162:  GOTO   4CF6
3166:  MOVLB  0
....................       }
....................       case 'j':
....................       { // jugnado single
....................          if (new_level)
3168:  MOVLB  1
316A:  BTFSS  x43.7
316C:  BRA    331A
....................          {
....................             new_level = 0;
316E:  BCF    x43.7
....................             for (int i = 0; i < 20; i++)
3170:  MOVLB  2
3172:  CLRF   x3A
3174:  MOVF   x3A,W
3176:  SUBLW  13
3178:  BNC   31C4
....................             {
....................                asteroids_lifes[i] = levels[level][i];
317A:  CLRF   03
317C:  MOVF   x3A,W
317E:  ADDLW  22
3180:  MOVWF  FE9
3182:  MOVLW  02
3184:  ADDWFC 03,W
3186:  MOVWF  FEA
3188:  CLRF   x5C
318A:  MOVFF  204,25B
318E:  CLRF   x5E
3190:  MOVLW  14
3192:  MOVWF  x5D
3194:  MOVLB  0
3196:  GOTO   1974
319A:  MOVFF  02,25C
319E:  MOVFF  01,25B
31A2:  MOVLB  2
31A4:  MOVF   x3A,W
31A6:  ADDWF  01,W
31A8:  MOVWF  01
31AA:  MOVLW  00
31AC:  ADDWFC 02,W
31AE:  MOVWF  03
31B0:  MOVF   01,W
31B2:  MOVFF  03,FF7
31B6:  MOVLB  0
31B8:  CALL   02AA
31BC:  MOVWF  FEF
31BE:  MOVLB  2
31C0:  INCF   x3A,F
31C2:  BRA    3174
....................             }
....................             if (!level)
31C4:  MOVF   x04,F
31C6:  BNZ   31DA
....................             {
....................                restart_screen();
31C8:  MOVLB  0
31CA:  GOTO   1998
....................                // while(!p1_R);
....................                x_pos = 63;
31CE:  MOVLW  3F
31D0:  MOVLB  1
31D2:  MOVWF  x52
....................                y_pos = 31;
31D4:  MOVLW  1F
31D6:  MOVWF  x53
31D8:  MOVLB  2
....................             }
....................             level++;
31DA:  INCF   x04,F
....................             for (unsigned int i = 0; i < 20; i++)
31DC:  CLRF   x3B
31DE:  MOVF   x3B,W
31E0:  SUBLW  13
31E2:  BTFSS  FD8.0
31E4:  BRA    330C
....................             { // inicializar la posicion de los asteroides a la esquina superior izquierda de manera random
....................                asteroids_x_pos[i] = (int)(((float)i) / 2.0f) % 10;
31E6:  CLRF   03
31E8:  MOVF   x3B,W
31EA:  ADDLW  B4
31EC:  MOVWF  FE9
31EE:  MOVLW  01
31F0:  ADDWFC 03,W
31F2:  MOVWF  FEA
31F4:  CLRF   x90
31F6:  MOVFF  23B,28F
31FA:  MOVLB  0
31FC:  CALL   1A16
3200:  MOVFF  03,25E
3204:  MOVFF  02,25D
3208:  MOVFF  01,25C
320C:  MOVFF  00,25B
3210:  MOVFF  03,264
3214:  MOVFF  02,263
3218:  MOVFF  01,262
321C:  MOVFF  00,261
3220:  MOVLB  2
3222:  CLRF   x68
3224:  CLRF   x67
3226:  CLRF   x66
3228:  MOVLW  80
322A:  MOVWF  x65
322C:  MOVLB  0
322E:  CALL   1A4C
3232:  MOVFF  03,28E
3236:  MOVFF  02,28D
323A:  MOVFF  01,28C
323E:  MOVFF  00,28B
3242:  CALL   1BAA
3246:  MOVFF  01,269
324A:  MOVLW  0A
324C:  MOVLB  2
324E:  MOVWF  x6A
3250:  MOVLB  0
3252:  CALL   1BE6
3256:  MOVFF  00,FEF
....................                asteroids_x_pos[i] = (int)((20.0f - (float)i) / 2.0f) % 10;
325A:  CLRF   03
325C:  MOVLB  2
325E:  MOVF   x3B,W
3260:  ADDLW  B4
3262:  MOVWF  FE9
3264:  MOVLW  01
3266:  ADDWFC 03,W
3268:  MOVWF  FEA
326A:  CLRF   x90
326C:  MOVFF  23B,28F
3270:  MOVLB  0
3272:  CALL   1A16
3276:  MOVFF  FEA,25C
327A:  MOVFF  FE9,25B
327E:  BSF    FD8.1
3280:  MOVLB  2
3282:  CLRF   x92
3284:  CLRF   x91
3286:  MOVLW  20
3288:  MOVWF  x90
328A:  MOVLW  83
328C:  MOVWF  x8F
328E:  MOVFF  03,296
3292:  MOVFF  02,295
3296:  MOVFF  01,294
329A:  MOVFF  00,293
329E:  MOVLB  0
32A0:  CALL   1C12
32A4:  MOVFF  25C,FEA
32A8:  MOVFF  25B,FE9
32AC:  MOVFF  03,260
32B0:  MOVFF  02,25F
32B4:  MOVFF  01,25E
32B8:  MOVFF  00,25D
32BC:  MOVFF  03,264
32C0:  MOVFF  02,263
32C4:  MOVFF  01,262
32C8:  MOVFF  00,261
32CC:  MOVLB  2
32CE:  CLRF   x68
32D0:  CLRF   x67
32D2:  CLRF   x66
32D4:  MOVLW  80
32D6:  MOVWF  x65
32D8:  MOVLB  0
32DA:  CALL   1A4C
32DE:  MOVFF  03,28E
32E2:  MOVFF  02,28D
32E6:  MOVFF  01,28C
32EA:  MOVFF  00,28B
32EE:  CALL   1BAA
32F2:  MOVFF  01,269
32F6:  MOVLW  0A
32F8:  MOVLB  2
32FA:  MOVWF  x6A
32FC:  MOVLB  0
32FE:  CALL   1BE6
3302:  MOVFF  00,FEF
3306:  MOVLB  2
3308:  INCF   x3B,F
330A:  BRA    31DE
....................             }
....................             glcd_fillScreen(0);
330C:  CLRF   x78
330E:  MOVLB  0
3310:  CALL   0658
....................          }
3314:  GOTO   4256
3318:  MOVLB  1
....................          else
....................          {
....................             ship_angle = (get_ship_angle(p1_pot_xx,p1_pot_yy) * 3.1416f) / 180.0f; // potenciometros angulos
331A:  MOVFF  214,259
331E:  MOVFF  215,25A
3322:  MOVLB  0
3324:  GOTO   1E8A
3328:  MOVFF  03,25C
332C:  MOVFF  02,25B
3330:  MOVFF  01,25A
3334:  MOVFF  00,259
3338:  MOVFF  03,292
333C:  MOVFF  02,291
3340:  MOVFF  01,290
3344:  MOVFF  00,28F
3348:  MOVLW  F9
334A:  MOVLB  2
334C:  MOVWF  x96
334E:  MOVLW  0F
3350:  MOVWF  x95
3352:  MOVLW  49
3354:  MOVWF  x94
3356:  MOVLW  80
3358:  MOVWF  x93
335A:  MOVLB  0
335C:  CALL   1F52
3360:  MOVFF  03,25C
3364:  MOVFF  02,25B
3368:  MOVFF  01,25A
336C:  MOVFF  00,259
3370:  MOVFF  03,264
3374:  MOVFF  02,263
3378:  MOVFF  01,262
337C:  MOVFF  00,261
3380:  MOVLB  2
3382:  CLRF   x68
3384:  CLRF   x67
3386:  MOVLW  34
3388:  MOVWF  x66
338A:  MOVLW  86
338C:  MOVWF  x65
338E:  MOVLB  0
3390:  CALL   1A4C
3394:  MOVFF  03,14F
3398:  MOVFF  02,14E
339C:  MOVFF  01,14D
33A0:  MOVFF  00,14C
.................... 
....................             dx = get_x_vel();          // potenciometro movimiento
33A4:  GOTO   2048
33A8:  MOVFF  03,157
33AC:  MOVFF  02,156
33B0:  MOVFF  01,155
33B4:  MOVFF  00,154
....................             dy = get_y_vel();          // potenciometro movimiento
33B8:  GOTO   20BE
33BC:  MOVFF  03,15B
33C0:  MOVFF  02,15A
33C4:  MOVFF  01,159
33C8:  MOVFF  00,158
....................             if ((float)x_pos + dx < 0) // mover jugador
33CC:  MOVLB  2
33CE:  CLRF   x90
33D0:  MOVFF  152,28F
33D4:  MOVLB  0
33D6:  CALL   1A16
33DA:  MOVFF  03,25C
33DE:  MOVFF  02,25B
33E2:  MOVFF  01,25A
33E6:  MOVFF  00,259
33EA:  BCF    FD8.1
33EC:  MOVFF  03,292
33F0:  MOVFF  02,291
33F4:  MOVFF  01,290
33F8:  MOVFF  00,28F
33FC:  MOVFF  157,296
3400:  MOVFF  156,295
3404:  MOVFF  155,294
3408:  MOVFF  154,293
340C:  CALL   1C12
3410:  MOVFF  03,25C
3414:  MOVFF  02,25B
3418:  MOVFF  01,25A
341C:  MOVFF  00,259
3420:  MOVFF  03,28E
3424:  MOVFF  02,28D
3428:  MOVFF  01,28C
342C:  MOVFF  00,28B
3430:  MOVLB  2
3432:  CLRF   x92
3434:  CLRF   x91
3436:  CLRF   x90
3438:  CLRF   x8F
343A:  MOVLB  0
343C:  CALL   2134
3440:  BNC   34A6
....................                x_pos = 127 + (int)((float)x_pos + dx);
3442:  MOVLB  2
3444:  CLRF   x90
3446:  MOVFF  152,28F
344A:  MOVLB  0
344C:  CALL   1A16
3450:  MOVFF  03,25C
3454:  MOVFF  02,25B
3458:  MOVFF  01,25A
345C:  MOVFF  00,259
3460:  BCF    FD8.1
3462:  MOVFF  03,292
3466:  MOVFF  02,291
346A:  MOVFF  01,290
346E:  MOVFF  00,28F
3472:  MOVFF  157,296
3476:  MOVFF  156,295
347A:  MOVFF  155,294
347E:  MOVFF  154,293
3482:  CALL   1C12
3486:  MOVFF  03,28E
348A:  MOVFF  02,28D
348E:  MOVFF  01,28C
3492:  MOVFF  00,28B
3496:  CALL   1BAA
349A:  MOVLW  7F
349C:  ADDWF  01,W
349E:  MOVLB  1
34A0:  MOVWF  x52
34A2:  BRA    34D6
34A4:  MOVLB  0
....................             else
....................                x_pos = (x_pos + (int)dx) % 127;
34A6:  MOVFF  157,28E
34AA:  MOVFF  156,28D
34AE:  MOVFF  155,28C
34B2:  MOVFF  154,28B
34B6:  CALL   1BAA
34BA:  MOVF   01,W
34BC:  MOVLB  1
34BE:  ADDWF  x52,W
34C0:  MOVLB  2
34C2:  MOVWF  x5A
34C4:  MOVWF  x69
34C6:  MOVLW  7F
34C8:  MOVWF  x6A
34CA:  MOVLB  0
34CC:  CALL   1BE6
34D0:  MOVFF  00,152
34D4:  MOVLB  1
.................... 
....................             if ((float)y_pos - dy < 0) // mover jugador
34D6:  MOVLB  2
34D8:  CLRF   x90
34DA:  MOVFF  153,28F
34DE:  MOVLB  0
34E0:  CALL   1A16
34E4:  MOVFF  03,25C
34E8:  MOVFF  02,25B
34EC:  MOVFF  01,25A
34F0:  MOVFF  00,259
34F4:  BSF    FD8.1
34F6:  MOVFF  03,292
34FA:  MOVFF  02,291
34FE:  MOVFF  01,290
3502:  MOVFF  00,28F
3506:  MOVFF  15B,296
350A:  MOVFF  15A,295
350E:  MOVFF  159,294
3512:  MOVFF  158,293
3516:  CALL   1C12
351A:  MOVFF  03,25C
351E:  MOVFF  02,25B
3522:  MOVFF  01,25A
3526:  MOVFF  00,259
352A:  MOVFF  03,28E
352E:  MOVFF  02,28D
3532:  MOVFF  01,28C
3536:  MOVFF  00,28B
353A:  MOVLB  2
353C:  CLRF   x92
353E:  CLRF   x91
3540:  CLRF   x90
3542:  CLRF   x8F
3544:  MOVLB  0
3546:  CALL   2134
354A:  BNC   35B0
....................                y_pos = 63 + (int)((float)y_pos - dy);
354C:  MOVLB  2
354E:  CLRF   x90
3550:  MOVFF  153,28F
3554:  MOVLB  0
3556:  CALL   1A16
355A:  MOVFF  03,25C
355E:  MOVFF  02,25B
3562:  MOVFF  01,25A
3566:  MOVFF  00,259
356A:  BSF    FD8.1
356C:  MOVFF  03,292
3570:  MOVFF  02,291
3574:  MOVFF  01,290
3578:  MOVFF  00,28F
357C:  MOVFF  15B,296
3580:  MOVFF  15A,295
3584:  MOVFF  159,294
3588:  MOVFF  158,293
358C:  CALL   1C12
3590:  MOVFF  03,28E
3594:  MOVFF  02,28D
3598:  MOVFF  01,28C
359C:  MOVFF  00,28B
35A0:  CALL   1BAA
35A4:  MOVLW  3F
35A6:  ADDWF  01,W
35A8:  MOVLB  1
35AA:  MOVWF  x53
35AC:  BRA    35E0
35AE:  MOVLB  0
....................             else
....................                y_pos = (y_pos - (int)dy) % 63;
35B0:  MOVFF  15B,28E
35B4:  MOVFF  15A,28D
35B8:  MOVFF  159,28C
35BC:  MOVFF  158,28B
35C0:  CALL   1BAA
35C4:  MOVF   01,W
35C6:  MOVLB  1
35C8:  SUBWF  x53,W
35CA:  MOVLB  2
35CC:  MOVWF  x5A
35CE:  MOVWF  x69
35D0:  MOVLW  3F
35D2:  MOVWF  x6A
35D4:  MOVLB  0
35D6:  CALL   1BE6
35DA:  MOVFF  00,153
35DE:  MOVLB  1
.................... 
....................             for (unsigned int i = 0; i < 20; i++)
35E0:  MOVLB  2
35E2:  CLRF   x3C
35E4:  MOVF   x3C,W
35E6:  SUBLW  13
35E8:  BTFSS  FD8.0
35EA:  BRA    3824
....................             { // mover asteroides
....................                if ((signed int)asteroids_x_pos[i] + asteroids_dx[i] < 0)
35EC:  CLRF   03
35EE:  MOVF   x3C,W
35F0:  ADDLW  B4
35F2:  MOVWF  FE9
35F4:  MOVLW  01
35F6:  ADDWFC 03,W
35F8:  MOVWF  FEA
35FA:  MOVFF  FEF,259
35FE:  CLRF   03
3600:  MOVF   x3C,W
3602:  ADDLW  DC
3604:  MOVWF  FE9
3606:  MOVLW  01
3608:  ADDWFC 03,W
360A:  MOVWF  FEA
360C:  MOVF   FEF,W
360E:  ADDWF  x59,W
3610:  MOVWF  00
3612:  BTFSS  FE8.7
3614:  BRA    365E
....................                   asteroids_x_pos[i] = 127 + ((signed int)asteroids_x_pos[i] + asteroids_dx[i]);
3616:  CLRF   03
3618:  MOVF   x3C,W
361A:  ADDLW  B4
361C:  MOVWF  01
361E:  MOVLW  01
3620:  ADDWFC 03,F
3622:  MOVFF  01,259
3626:  MOVFF  03,25A
362A:  CLRF   03
362C:  MOVF   x3C,W
362E:  ADDLW  B4
3630:  MOVWF  FE9
3632:  MOVLW  01
3634:  ADDWFC 03,W
3636:  MOVWF  FEA
3638:  MOVFF  FEF,25B
363C:  CLRF   03
363E:  MOVF   x3C,W
3640:  ADDLW  DC
3642:  MOVWF  FE9
3644:  MOVLW  01
3646:  ADDWFC 03,W
3648:  MOVWF  FEA
364A:  MOVF   FEF,W
364C:  ADDWF  x5B,W
364E:  ADDLW  7F
3650:  MOVWF  x5B
3652:  MOVFF  25A,FEA
3656:  MOVFF  01,FE9
365A:  MOVWF  FEF
365C:  BRA    3706
....................                else if (asteroids_x_pos[i] + (unsigned int)asteroids_dx[i] > 127)
365E:  CLRF   03
3660:  MOVF   x3C,W
3662:  ADDLW  B4
3664:  MOVWF  FE9
3666:  MOVLW  01
3668:  ADDWFC 03,W
366A:  MOVWF  FEA
366C:  MOVFF  FEF,259
3670:  CLRF   03
3672:  MOVF   x3C,W
3674:  ADDLW  DC
3676:  MOVWF  FE9
3678:  MOVLW  01
367A:  ADDWFC 03,W
367C:  MOVWF  FEA
367E:  MOVF   FEF,W
3680:  ADDWF  x59,W
3682:  SUBLW  7F
3684:  BC    36CE
....................                   asteroids_x_pos[i] = 0 + ((asteroids_x_pos[i] + (unsigned int)asteroids_dx[i]) - 127);
3686:  CLRF   03
3688:  MOVF   x3C,W
368A:  ADDLW  B4
368C:  MOVWF  01
368E:  MOVLW  01
3690:  ADDWFC 03,F
3692:  MOVFF  01,259
3696:  MOVFF  03,25A
369A:  CLRF   03
369C:  MOVF   x3C,W
369E:  ADDLW  B4
36A0:  MOVWF  FE9
36A2:  MOVLW  01
36A4:  ADDWFC 03,W
36A6:  MOVWF  FEA
36A8:  MOVFF  FEF,25B
36AC:  CLRF   03
36AE:  MOVF   x3C,W
36B0:  ADDLW  DC
36B2:  MOVWF  FE9
36B4:  MOVLW  01
36B6:  ADDWFC 03,W
36B8:  MOVWF  FEA
36BA:  MOVF   FEF,W
36BC:  ADDWF  x5B,W
36BE:  ADDLW  81
36C0:  MOVWF  x5B
36C2:  MOVFF  25A,FEA
36C6:  MOVFF  01,FE9
36CA:  MOVWF  FEF
36CC:  BRA    3706
....................                else
....................                   asteroids_x_pos[i] += asteroids_dx[i];
36CE:  CLRF   03
36D0:  MOVF   x3C,W
36D2:  ADDLW  B4
36D4:  MOVWF  01
36D6:  MOVLW  01
36D8:  ADDWFC 03,F
36DA:  MOVFF  03,25A
36DE:  MOVFF  03,FEA
36E2:  MOVFF  01,FE9
36E6:  MOVFF  FEF,25B
36EA:  CLRF   03
36EC:  MOVF   x3C,W
36EE:  ADDLW  DC
36F0:  MOVWF  FE9
36F2:  MOVLW  01
36F4:  ADDWFC 03,W
36F6:  MOVWF  FEA
36F8:  MOVF   FEF,W
36FA:  ADDWF  x5B,W
36FC:  MOVFF  25A,FEA
3700:  MOVFF  01,FE9
3704:  MOVWF  FEF
.................... 
....................                if ((signed int)asteroids_y_pos[i] + asteroids_dy[i] < 0)
3706:  CLRF   03
3708:  MOVF   x3C,W
370A:  ADDLW  C8
370C:  MOVWF  FE9
370E:  MOVLW  01
3710:  ADDWFC 03,W
3712:  MOVWF  FEA
3714:  MOVFF  FEF,259
3718:  CLRF   03
371A:  MOVF   x3C,W
371C:  ADDLW  F0
371E:  MOVWF  FE9
3720:  MOVLW  01
3722:  ADDWFC 03,W
3724:  MOVWF  FEA
3726:  MOVF   FEF,W
3728:  ADDWF  x59,W
372A:  MOVWF  00
372C:  BTFSS  FE8.7
372E:  BRA    3778
....................                   asteroids_y_pos[i] = 63 + ((signed int)asteroids_y_pos[i] + asteroids_dy[i]);
3730:  CLRF   03
3732:  MOVF   x3C,W
3734:  ADDLW  C8
3736:  MOVWF  01
3738:  MOVLW  01
373A:  ADDWFC 03,F
373C:  MOVFF  01,259
3740:  MOVFF  03,25A
3744:  CLRF   03
3746:  MOVF   x3C,W
3748:  ADDLW  C8
374A:  MOVWF  FE9
374C:  MOVLW  01
374E:  ADDWFC 03,W
3750:  MOVWF  FEA
3752:  MOVFF  FEF,25B
3756:  CLRF   03
3758:  MOVF   x3C,W
375A:  ADDLW  F0
375C:  MOVWF  FE9
375E:  MOVLW  01
3760:  ADDWFC 03,W
3762:  MOVWF  FEA
3764:  MOVF   FEF,W
3766:  ADDWF  x5B,W
3768:  ADDLW  3F
376A:  MOVWF  x5B
376C:  MOVFF  25A,FEA
3770:  MOVFF  01,FE9
3774:  MOVWF  FEF
3776:  BRA    3820
....................                else if (asteroids_y_pos[i] + (unsigned int)asteroids_dy[i] > 63)
3778:  CLRF   03
377A:  MOVF   x3C,W
377C:  ADDLW  C8
377E:  MOVWF  FE9
3780:  MOVLW  01
3782:  ADDWFC 03,W
3784:  MOVWF  FEA
3786:  MOVFF  FEF,259
378A:  CLRF   03
378C:  MOVF   x3C,W
378E:  ADDLW  F0
3790:  MOVWF  FE9
3792:  MOVLW  01
3794:  ADDWFC 03,W
3796:  MOVWF  FEA
3798:  MOVF   FEF,W
379A:  ADDWF  x59,W
379C:  SUBLW  3F
379E:  BC    37E8
....................                   asteroids_y_pos[i] = 0 + ((asteroids_y_pos[i] + (unsigned int)asteroids_dy[i]) - 63);
37A0:  CLRF   03
37A2:  MOVF   x3C,W
37A4:  ADDLW  C8
37A6:  MOVWF  01
37A8:  MOVLW  01
37AA:  ADDWFC 03,F
37AC:  MOVFF  01,259
37B0:  MOVFF  03,25A
37B4:  CLRF   03
37B6:  MOVF   x3C,W
37B8:  ADDLW  C8
37BA:  MOVWF  FE9
37BC:  MOVLW  01
37BE:  ADDWFC 03,W
37C0:  MOVWF  FEA
37C2:  MOVFF  FEF,25B
37C6:  CLRF   03
37C8:  MOVF   x3C,W
37CA:  ADDLW  F0
37CC:  MOVWF  FE9
37CE:  MOVLW  01
37D0:  ADDWFC 03,W
37D2:  MOVWF  FEA
37D4:  MOVF   FEF,W
37D6:  ADDWF  x5B,W
37D8:  ADDLW  C1
37DA:  MOVWF  x5B
37DC:  MOVFF  25A,FEA
37E0:  MOVFF  01,FE9
37E4:  MOVWF  FEF
37E6:  BRA    3820
....................                else
....................                   asteroids_y_pos[i] += asteroids_dy[i];
37E8:  CLRF   03
37EA:  MOVF   x3C,W
37EC:  ADDLW  C8
37EE:  MOVWF  01
37F0:  MOVLW  01
37F2:  ADDWFC 03,F
37F4:  MOVFF  03,25A
37F8:  MOVFF  03,FEA
37FC:  MOVFF  01,FE9
3800:  MOVFF  FEF,25B
3804:  CLRF   03
3806:  MOVF   x3C,W
3808:  ADDLW  F0
380A:  MOVWF  FE9
380C:  MOVLW  01
380E:  ADDWFC 03,W
3810:  MOVWF  FEA
3812:  MOVF   FEF,W
3814:  ADDWF  x5B,W
3816:  MOVFF  25A,FEA
381A:  MOVFF  01,FE9
381E:  MOVWF  FEF
3820:  INCF   x3C,F
3822:  BRA    35E4
....................             }
.................... 
....................             for (unsigned int i = 0; i < 20; i++)
3824:  CLRF   x3D
3826:  MOVF   x3D,W
3828:  SUBLW  13
382A:  BTFSS  FD8.0
382C:  BRA    398C
....................             { // checar si la posicion del jugador coincide con algun asteroide
....................                if (asteroids_lifes[i])
382E:  CLRF   03
3830:  MOVF   x3D,W
3832:  ADDLW  22
3834:  MOVWF  FE9
3836:  MOVLW  02
3838:  ADDWFC 03,W
383A:  MOVWF  FEA
383C:  MOVF   FEF,F
383E:  BTFSC  FD8.2
3840:  BRA    3984
....................                {
....................                   if (((x_pos > asteroids_x_pos[i]) && (x_pos < (asteroids_x_pos[i] + asteroids_lifes[i] * 8))) && ((y_pos > asteroids_y_pos[i]) && (y_pos < (asteroids_y_pos[i] + asteroids_lifes[i] * 8))))
3842:  CLRF   03
3844:  MOVF   x3D,W
3846:  ADDLW  B4
3848:  MOVWF  FE9
384A:  MOVLW  01
384C:  ADDWFC 03,W
384E:  MOVWF  FEA
3850:  MOVF   FEF,W
3852:  MOVLB  1
3854:  SUBWF  x52,W
3856:  BTFSC  FD8.2
3858:  BRA    3986
385A:  BTFSS  FD8.0
385C:  BRA    3986
385E:  CLRF   03
3860:  MOVLB  2
3862:  MOVF   x3D,W
3864:  ADDLW  B4
3866:  MOVWF  FE9
3868:  MOVLW  01
386A:  ADDWFC 03,W
386C:  MOVWF  FEA
386E:  MOVFF  FEF,259
3872:  CLRF   03
3874:  MOVF   x3D,W
3876:  ADDLW  22
3878:  MOVWF  FE9
387A:  MOVLW  02
387C:  ADDWFC 03,W
387E:  MOVWF  FEA
3880:  MOVF   FEF,W
3882:  MULLW  08
3884:  MOVF   FF3,W
3886:  ADDWF  x59,W
3888:  MOVLB  1
388A:  SUBWF  x52,W
388C:  BTFSC  FD8.0
388E:  BRA    3986
3890:  CLRF   03
3892:  MOVLB  2
3894:  MOVF   x3D,W
3896:  ADDLW  C8
3898:  MOVWF  FE9
389A:  MOVLW  01
389C:  ADDWFC 03,W
389E:  MOVWF  FEA
38A0:  MOVF   FEF,W
38A2:  MOVLB  1
38A4:  SUBWF  x53,W
38A6:  BZ    3986
38A8:  BNC   3986
38AA:  CLRF   03
38AC:  MOVLB  2
38AE:  MOVF   x3D,W
38B0:  ADDLW  C8
38B2:  MOVWF  FE9
38B4:  MOVLW  01
38B6:  ADDWFC 03,W
38B8:  MOVWF  FEA
38BA:  MOVFF  FEF,259
38BE:  CLRF   03
38C0:  MOVF   x3D,W
38C2:  ADDLW  22
38C4:  MOVWF  FE9
38C6:  MOVLW  02
38C8:  ADDWFC 03,W
38CA:  MOVWF  FEA
38CC:  MOVF   FEF,W
38CE:  MULLW  08
38D0:  MOVF   FF3,W
38D2:  ADDWF  x59,W
38D4:  MOVLB  1
38D6:  SUBWF  x53,W
38D8:  BC    3986
....................                   { // perder
....................                      mode = 'i';
38DA:  MOVLW  69
38DC:  MOVLB  2
38DE:  MOVWF  x0E
....................                      new_level = 1;
38E0:  MOVLB  1
38E2:  BSF    x43.7
....................                      glcd_fillScreen(1);
38E4:  MOVLW  01
38E6:  MOVLB  2
38E8:  MOVWF  x78
38EA:  MOVLB  0
38EC:  CALL   0658
....................                      char text_asteroids[] = "YOU LOSE!";
38F0:  MOVLW  59
38F2:  MOVLB  2
38F4:  MOVWF  x3E
38F6:  MOVLW  4F
38F8:  MOVWF  x3F
38FA:  MOVLW  55
38FC:  MOVWF  x40
38FE:  MOVLW  20
3900:  MOVWF  x41
3902:  MOVLW  4C
3904:  MOVWF  x42
3906:  MOVLW  4F
3908:  MOVWF  x43
390A:  MOVLW  53
390C:  MOVWF  x44
390E:  MOVLW  45
3910:  MOVWF  x45
3912:  MOVLW  21
3914:  MOVWF  x46
3916:  CLRF   x47
....................                      glcd_text57(29, 22, text_asteroids, 1, 0);
3918:  MOVLW  1D
391A:  MOVWF  xDF
391C:  MOVLW  16
391E:  MOVWF  xE0
3920:  MOVLW  02
3922:  MOVWF  xE2
3924:  MOVLW  3E
3926:  MOVWF  xE1
3928:  MOVLW  01
392A:  MOVWF  xE3
392C:  CLRF   xE4
392E:  MOVLB  0
3930:  CALL   0B0C
....................                      delay_ms(1000);
3934:  MOVLW  04
3936:  MOVLB  2
3938:  MOVWF  x59
393A:  MOVLW  FA
393C:  MOVWF  x79
393E:  MOVLB  0
3940:  CALL   05EC
3944:  MOVLB  2
3946:  DECFSZ x59,F
3948:  BRA    393A
....................                      glcd_fillScreen(0);
394A:  CLRF   x78
394C:  MOVLB  0
394E:  CALL   0658
....................                      inicio(0);
3952:  MOVLB  2
3954:  CLRF   x59
3956:  MOVLB  0
3958:  CALL   0DDE
....................                      if (score > best_score)
395C:  MOVLB  2
395E:  MOVF   x09,W
3960:  SUBWF  x07,W
3962:  BNC   3974
3964:  BNZ   396C
3966:  MOVF   x06,W
3968:  SUBWF  x08,W
396A:  BC    3974
....................                         best_score = score;
396C:  MOVFF  207,209
3970:  MOVFF  206,208
....................                      if (level > best_level)
3974:  MOVF   x04,W
3976:  SUBWF  x05,W
3978:  BC    397E
....................                         best_level = level;
397A:  MOVFF  204,205
....................                      score = 0;
397E:  CLRF   x07
3980:  CLRF   x06
....................                      level = 0;
3982:  CLRF   x04
3984:  MOVLB  1
....................                   }
....................                }
3986:  MOVLB  2
3988:  INCF   x3D,F
398A:  BRA    3826
....................             }
.................... 
....................             if (bullet)
398C:  MOVLB  1
398E:  BTFSS  x43.2
3990:  BRA    3C48
....................             { // si hay una bala, calcular su posicion, y si hay impacto o se pierde la bala
....................                bullet_x_pos += (signed int)bullet_dx;
3992:  MOVFF  167,28E
3996:  MOVFF  166,28D
399A:  MOVFF  165,28C
399E:  MOVFF  164,28B
39A2:  MOVLB  0
39A4:  CALL   1BAA
39A8:  CLRF   03
39AA:  MOVF   01,W
39AC:  BTFSC  FE8.7
39AE:  DECF   03,F
39B0:  MOVLB  1
39B2:  ADDWF  x60,F
39B4:  MOVF   03,W
39B6:  ADDWFC x61,F
....................                bullet_y_pos += (signed int)bullet_dy;
39B8:  MOVFF  16B,28E
39BC:  MOVFF  16A,28D
39C0:  MOVFF  169,28C
39C4:  MOVFF  168,28B
39C8:  MOVLB  0
39CA:  CALL   1BAA
39CE:  CLRF   03
39D0:  MOVF   01,W
39D2:  BTFSC  FE8.7
39D4:  DECF   03,F
39D6:  MOVLB  1
39D8:  ADDWF  x62,F
39DA:  MOVF   03,W
39DC:  ADDWFC x63,F
....................                // checar collision con asteroides
....................                for (int i = 0; i < 20; i++)
39DE:  MOVLB  2
39E0:  CLRF   x48
39E2:  MOVF   x48,W
39E4:  SUBLW  13
39E6:  BTFSS  FD8.0
39E8:  BRA    3BA2
....................                {
....................                   if (asteroids_lifes[i])
39EA:  CLRF   03
39EC:  MOVF   x48,W
39EE:  ADDLW  22
39F0:  MOVWF  FE9
39F2:  MOVLW  02
39F4:  ADDWFC 03,W
39F6:  MOVWF  FEA
39F8:  MOVF   FEF,F
39FA:  BTFSC  FD8.2
39FC:  BRA    3B9A
....................                   {
....................                      if ((((bullet_x_pos > asteroids_x_pos[i]) && (bullet_x_pos < (asteroids_x_pos[i] + asteroids_lifes[i] * 8))) && ((bullet_y_pos > asteroids_y_pos[i]) && (bullet_y_pos < (asteroids_y_pos[i] + asteroids_lifes[i] * 8)))) || (((last_bullet_x_pos > asteroids_x_pos[i]) && (last_bullet_x_pos < (asteroids_x_pos[i] + asteroids_lifes[i] * 8))) && ((last_bullet_y_pos > asteroids_y_pos[i]) && (last_bullet_y_pos < (asteroids_y_pos[i] + asteroids_lifes[i] * 8)))))
39FE:  CLRF   03
3A00:  MOVF   x48,W
3A02:  ADDLW  B4
3A04:  MOVWF  FE9
3A06:  MOVLW  01
3A08:  ADDWFC 03,W
3A0A:  MOVWF  FEA
3A0C:  MOVF   FEF,W
3A0E:  MOVLB  1
3A10:  BTFSC  x61.7
3A12:  BRA    3AB0
3A14:  MOVF   x61,F
3A16:  BNZ   3A1E
3A18:  SUBWF  x60,W
3A1A:  BZ    3AB0
3A1C:  BNC   3AB0
3A1E:  CLRF   03
3A20:  MOVLB  2
3A22:  MOVF   x48,W
3A24:  ADDLW  B4
3A26:  MOVWF  FE9
3A28:  MOVLW  01
3A2A:  ADDWFC 03,W
3A2C:  MOVWF  FEA
3A2E:  MOVFF  FEF,259
3A32:  CLRF   03
3A34:  MOVF   x48,W
3A36:  ADDLW  22
3A38:  MOVWF  FE9
3A3A:  MOVLW  02
3A3C:  ADDWFC 03,W
3A3E:  MOVWF  FEA
3A40:  MOVF   FEF,W
3A42:  MULLW  08
3A44:  MOVF   FF3,W
3A46:  ADDWF  x59,W
3A48:  MOVLB  1
3A4A:  BTFSC  x61.7
3A4C:  BRA    3A56
3A4E:  MOVF   x61,F
3A50:  BNZ   3AB0
3A52:  SUBWF  x60,W
3A54:  BC    3AB0
3A56:  CLRF   03
3A58:  MOVLB  2
3A5A:  MOVF   x48,W
3A5C:  ADDLW  C8
3A5E:  MOVWF  FE9
3A60:  MOVLW  01
3A62:  ADDWFC 03,W
3A64:  MOVWF  FEA
3A66:  MOVF   FEF,W
3A68:  MOVLB  1
3A6A:  BTFSC  x63.7
3A6C:  BRA    3AB0
3A6E:  MOVF   x63,F
3A70:  BNZ   3A78
3A72:  SUBWF  x62,W
3A74:  BZ    3AB0
3A76:  BNC   3AB0
3A78:  CLRF   03
3A7A:  MOVLB  2
3A7C:  MOVF   x48,W
3A7E:  ADDLW  C8
3A80:  MOVWF  FE9
3A82:  MOVLW  01
3A84:  ADDWFC 03,W
3A86:  MOVWF  FEA
3A88:  MOVFF  FEF,259
3A8C:  CLRF   03
3A8E:  MOVF   x48,W
3A90:  ADDLW  22
3A92:  MOVWF  FE9
3A94:  MOVLW  02
3A96:  ADDWFC 03,W
3A98:  MOVWF  FEA
3A9A:  MOVF   FEF,W
3A9C:  MULLW  08
3A9E:  MOVF   FF3,W
3AA0:  ADDWF  x59,W
3AA2:  MOVLB  1
3AA4:  BTFSC  x63.7
3AA6:  BRA    3B54
3AA8:  MOVF   x63,F
3AAA:  BNZ   3AB0
3AAC:  SUBWF  x62,W
3AAE:  BNC   3B54
3AB0:  CLRF   03
3AB2:  MOVLB  2
3AB4:  MOVF   x48,W
3AB6:  ADDLW  B4
3AB8:  MOVWF  FE9
3ABA:  MOVLW  01
3ABC:  ADDWFC 03,W
3ABE:  MOVWF  FEA
3AC0:  MOVF   FEF,W
3AC2:  MOVLB  1
3AC4:  BTFSC  x5E.7
3AC6:  BRA    3B9C
3AC8:  SUBWF  x5E,W
3ACA:  BZ    3B9C
3ACC:  BNC   3B9C
3ACE:  CLRF   03
3AD0:  MOVLB  2
3AD2:  MOVF   x48,W
3AD4:  ADDLW  B4
3AD6:  MOVWF  FE9
3AD8:  MOVLW  01
3ADA:  ADDWFC 03,W
3ADC:  MOVWF  FEA
3ADE:  MOVFF  FEF,259
3AE2:  CLRF   03
3AE4:  MOVF   x48,W
3AE6:  ADDLW  22
3AE8:  MOVWF  FE9
3AEA:  MOVLW  02
3AEC:  ADDWFC 03,W
3AEE:  MOVWF  FEA
3AF0:  MOVF   FEF,W
3AF2:  MULLW  08
3AF4:  MOVF   FF3,W
3AF6:  ADDWF  x59,W
3AF8:  MOVLB  1
3AFA:  BTFSC  x5E.7
3AFC:  BRA    3B02
3AFE:  SUBWF  x5E,W
3B00:  BC    3B9C
3B02:  CLRF   03
3B04:  MOVLB  2
3B06:  MOVF   x48,W
3B08:  ADDLW  C8
3B0A:  MOVWF  FE9
3B0C:  MOVLW  01
3B0E:  ADDWFC 03,W
3B10:  MOVWF  FEA
3B12:  MOVF   FEF,W
3B14:  MOVLB  1
3B16:  BTFSC  x5F.7
3B18:  BRA    3B9C
3B1A:  SUBWF  x5F,W
3B1C:  BZ    3B9C
3B1E:  BNC   3B9C
3B20:  CLRF   03
3B22:  MOVLB  2
3B24:  MOVF   x48,W
3B26:  ADDLW  C8
3B28:  MOVWF  FE9
3B2A:  MOVLW  01
3B2C:  ADDWFC 03,W
3B2E:  MOVWF  FEA
3B30:  MOVFF  FEF,259
3B34:  CLRF   03
3B36:  MOVF   x48,W
3B38:  ADDLW  22
3B3A:  MOVWF  FE9
3B3C:  MOVLW  02
3B3E:  ADDWFC 03,W
3B40:  MOVWF  FEA
3B42:  MOVF   FEF,W
3B44:  MULLW  08
3B46:  MOVF   FF3,W
3B48:  ADDWF  x59,W
3B4A:  MOVLB  1
3B4C:  BTFSC  x5F.7
3B4E:  BRA    3B54
3B50:  SUBWF  x5F,W
3B52:  BC    3B9C
....................                      {
....................                         score += (4 - asteroids_lifes[i]);
3B54:  CLRF   03
3B56:  MOVLB  2
3B58:  MOVF   x48,W
3B5A:  ADDLW  22
3B5C:  MOVWF  FE9
3B5E:  MOVLW  02
3B60:  ADDWFC 03,W
3B62:  MOVWF  FEA
3B64:  MOVF   FEF,W
3B66:  XORLW  FF
3B68:  ADDLW  05
3B6A:  ADDWF  x06,F
3B6C:  MOVLW  00
3B6E:  ADDWFC x07,F
....................                         asteroids_lifes[i]--;
3B70:  CLRF   03
3B72:  MOVF   x48,W
3B74:  ADDLW  22
3B76:  MOVWF  FE9
3B78:  MOVLW  02
3B7A:  ADDWFC 03,W
3B7C:  MOVWF  FEA
3B7E:  DECF   FEF,F
....................                         asteroid_lost_a_life[i] = 1;
3B80:  MOVFF  248,259
3B84:  MOVLW  01
3B86:  MOVWF  x5A
3B88:  MOVLW  02
3B8A:  MOVWF  x5C
3B8C:  MOVLW  36
3B8E:  MOVWF  x5B
3B90:  MOVLB  0
3B92:  CALL   21AE
....................                         bullet_collision = 1;
3B96:  MOVLB  2
3B98:  BSF    x20.2
3B9A:  MOVLB  1
....................                      }
....................                   }
3B9C:  MOVLB  2
3B9E:  INCF   x48,F
3BA0:  BRA    39E2
....................                }
.................... 
....................                glcd_line(last_last_bullet_x_pos, last_last_bullet_y_pos, last_bullet_x_pos, last_bullet_y_pos, 0);
3BA2:  MOVFF  15C,2DF
3BA6:  MOVFF  15D,2E0
3BAA:  MOVFF  15E,2E1
3BAE:  MOVFF  15F,2E2
3BB2:  CLRF   xE3
3BB4:  MOVLB  0
3BB6:  CALL   0902
....................                glcd_line(last_bullet_x_pos, last_bullet_y_pos, bullet_x_pos, bullet_y_pos, 1);
3BBA:  MOVFF  15E,2DF
3BBE:  MOVFF  15F,2E0
3BC2:  MOVFF  160,2E1
3BC6:  MOVFF  162,2E2
3BCA:  MOVLW  01
3BCC:  MOVLB  2
3BCE:  MOVWF  xE3
3BD0:  MOVLB  0
3BD2:  CALL   0902
....................                if (!bullet_collision)
3BD6:  MOVLB  2
3BD8:  BTFSC  x20.2
3BDA:  BRA    3C24
....................                { // si no hay colision, checar si se pierde la bala
....................                   if (bullet_x_pos > 127 || bullet_x_pos < 0 || bullet_y_pos > 63 || bullet_y_pos < 0)
3BDC:  MOVLB  1
3BDE:  BTFSC  x61.7
3BE0:  BRA    3BEC
3BE2:  MOVF   x61,F
3BE4:  BNZ   3C02
3BE6:  MOVF   x60,W
3BE8:  SUBLW  7F
3BEA:  BNC   3C02
3BEC:  BTFSC  x61.7
3BEE:  BRA    3C02
3BF0:  BTFSC  x63.7
3BF2:  BRA    3BFE
3BF4:  MOVF   x63,F
3BF6:  BNZ   3C02
3BF8:  MOVF   x62,W
3BFA:  SUBLW  3F
3BFC:  BNC   3C02
3BFE:  BTFSS  x63.7
3C00:  BRA    3C20
....................                   { // bala sali?
....................                      bullet = 0;
3C02:  BCF    x43.2
....................                      glcd_line(last_bullet_x_pos, last_bullet_y_pos, bullet_x_pos, bullet_y_pos, 0);
3C04:  MOVFF  15E,2DF
3C08:  MOVFF  15F,2E0
3C0C:  MOVFF  160,2E1
3C10:  MOVFF  162,2E2
3C14:  MOVLB  2
3C16:  CLRF   xE3
3C18:  MOVLB  0
3C1A:  CALL   0902
3C1E:  MOVLB  1
....................                   }
....................                }
3C20:  BRA    3C46
3C22:  MOVLB  2
....................                else
....................                {
....................                   bullet_collision = 0;
3C24:  BCF    x20.2
....................                   bullet = 0;
3C26:  MOVLB  1
3C28:  BCF    x43.2
....................                   glcd_line(last_bullet_x_pos, last_bullet_y_pos, bullet_x_pos, bullet_y_pos, 0);
3C2A:  MOVFF  15E,2DF
3C2E:  MOVFF  15F,2E0
3C32:  MOVFF  160,2E1
3C36:  MOVFF  162,2E2
3C3A:  MOVLB  2
3C3C:  CLRF   xE3
3C3E:  MOVLB  0
3C40:  CALL   0902
3C44:  MOVLB  1
....................                }
....................             }
3C46:  BRA    3D1A
....................             else
....................             {
....................                if (p1_R)
3C48:  MOVLB  2
3C4A:  BTFSS  x10.3
3C4C:  BRA    3D18
....................                { // disparar si no hay una bala actualmente
....................                   bullet = 1;
3C4E:  MOVLB  1
3C50:  BSF    x43.2
....................                   bullet_dx = cos(ship_angle) * (float)bullet_speed; // dispararla segun el angulo q se mira
3C52:  MOVFF  14F,264
3C56:  MOVFF  14E,263
3C5A:  MOVFF  14D,262
3C5E:  MOVFF  14C,261
3C62:  MOVLB  0
3C64:  CALL   21F0
3C68:  MOVFF  03,25C
3C6C:  MOVFF  02,25B
3C70:  MOVFF  01,25A
3C74:  MOVFF  00,259
3C78:  MOVFF  03,292
3C7C:  MOVFF  02,291
3C80:  MOVFF  01,290
3C84:  MOVFF  00,28F
3C88:  MOVLB  2
3C8A:  CLRF   x96
3C8C:  CLRF   x95
3C8E:  MOVLW  40
3C90:  MOVWF  x94
3C92:  MOVLW  81
3C94:  MOVWF  x93
3C96:  MOVLB  0
3C98:  CALL   1F52
3C9C:  MOVFF  03,167
3CA0:  MOVFF  02,166
3CA4:  MOVFF  01,165
3CA8:  MOVFF  00,164
....................                   bullet_dy = sin(ship_angle) * (float)bullet_speed;
3CAC:  MOVFF  14F,25C
3CB0:  MOVFF  14E,25B
3CB4:  MOVFF  14D,25A
3CB8:  MOVFF  14C,259
3CBC:  GOTO   2566
3CC0:  MOVFF  03,25C
3CC4:  MOVFF  02,25B
3CC8:  MOVFF  01,25A
3CCC:  MOVFF  00,259
3CD0:  MOVFF  03,292
3CD4:  MOVFF  02,291
3CD8:  MOVFF  01,290
3CDC:  MOVFF  00,28F
3CE0:  MOVLB  2
3CE2:  CLRF   x96
3CE4:  CLRF   x95
3CE6:  MOVLW  40
3CE8:  MOVWF  x94
3CEA:  MOVLW  81
3CEC:  MOVWF  x93
3CEE:  MOVLB  0
3CF0:  CALL   1F52
3CF4:  MOVFF  03,16B
3CF8:  MOVFF  02,16A
3CFC:  MOVFF  01,169
3D00:  MOVFF  00,168
....................                   bullet_x_pos = x_pos;
3D04:  MOVLB  1
3D06:  MOVFF  152,160
3D0A:  CLRF   x61
....................                   bullet_y_pos = y_pos;
3D0C:  MOVFF  153,162
3D10:  CLRF   x63
....................                   sfx_time = 2;
3D12:  MOVLW  02
3D14:  MOVLB  2
3D16:  MOVWF  x21
3D18:  MOVLB  1
....................                }
....................             }
.................... 
....................             for (unsigned int i = 0; i < 20; i++)
3D1A:  MOVLB  2
3D1C:  CLRF   x49
3D1E:  MOVF   x49,W
3D20:  SUBLW  13
3D22:  BTFSS  FD8.0
3D24:  BRA    3F04
....................             { // dibuar asteroides actuales
....................                if (asteroids_lifes[i])
3D26:  CLRF   03
3D28:  MOVF   x49,W
3D2A:  ADDLW  22
3D2C:  MOVWF  FE9
3D2E:  MOVLW  02
3D30:  ADDWFC 03,W
3D32:  MOVWF  FEA
3D34:  MOVF   FEF,F
3D36:  BTFSC  FD8.2
3D38:  BRA    3E32
....................                {
....................                   if (asteroid_lost_a_life[i])
3D3A:  MOVFF  249,259
3D3E:  MOVLW  02
3D40:  MOVWF  x5B
3D42:  MOVLW  36
3D44:  MOVWF  x5A
3D46:  MOVLB  0
3D48:  CALL   25B6
3D4C:  BTFSS  01.0
3D4E:  BRA    3DAC
....................                   {
....................                      draw_asteroid(last_asteroids_x_pos[i], last_asteroids_y_pos[i], asteroids_lifes[i] + 1, 0);
3D50:  CLRF   03
3D52:  MOVLB  2
3D54:  MOVF   x49,W
3D56:  ADDLW  8C
3D58:  MOVWF  FE9
3D5A:  MOVLW  01
3D5C:  ADDWFC 03,W
3D5E:  MOVWF  FEA
3D60:  MOVFF  FEF,25C
3D64:  CLRF   03
3D66:  MOVF   x49,W
3D68:  ADDLW  A0
3D6A:  MOVWF  FE9
3D6C:  MOVLW  01
3D6E:  ADDWFC 03,W
3D70:  MOVWF  FEA
3D72:  MOVFF  FEF,25D
3D76:  CLRF   03
3D78:  MOVF   x49,W
3D7A:  ADDLW  22
3D7C:  MOVWF  FE9
3D7E:  MOVLW  02
3D80:  ADDWFC 03,W
3D82:  MOVWF  FEA
3D84:  MOVLW  01
3D86:  ADDWF  FEF,W
3D88:  MOVWF  x5B
3D8A:  MOVWF  x5E
3D8C:  CLRF   x5F
3D8E:  MOVLB  0
3D90:  CALL   25EC
....................                      asteroid_lost_a_life[i] = 0;
3D94:  MOVFF  249,259
3D98:  MOVLB  2
3D9A:  CLRF   x5A
3D9C:  MOVLW  02
3D9E:  MOVWF  x5C
3DA0:  MOVLW  36
3DA2:  MOVWF  x5B
3DA4:  MOVLB  0
3DA6:  CALL   21AE
....................                   }
3DAA:  BRA    3DEC
....................                   else
....................                   {
....................                      draw_asteroid(last_asteroids_x_pos[i], last_asteroids_y_pos[i], asteroids_lifes[i], 0);
3DAC:  CLRF   03
3DAE:  MOVLB  2
3DB0:  MOVF   x49,W
3DB2:  ADDLW  8C
3DB4:  MOVWF  FE9
3DB6:  MOVLW  01
3DB8:  ADDWFC 03,W
3DBA:  MOVWF  FEA
3DBC:  MOVFF  FEF,25C
3DC0:  CLRF   03
3DC2:  MOVF   x49,W
3DC4:  ADDLW  A0
3DC6:  MOVWF  FE9
3DC8:  MOVLW  01
3DCA:  ADDWFC 03,W
3DCC:  MOVWF  FEA
3DCE:  MOVFF  FEF,25D
3DD2:  CLRF   03
3DD4:  MOVF   x49,W
3DD6:  ADDLW  22
3DD8:  MOVWF  FE9
3DDA:  MOVLW  02
3DDC:  ADDWFC 03,W
3DDE:  MOVWF  FEA
3DE0:  MOVFF  FEF,25E
3DE4:  CLRF   x5F
3DE6:  MOVLB  0
3DE8:  CALL   25EC
....................                   }
....................                   draw_asteroid(asteroids_x_pos[i], asteroids_y_pos[i], asteroids_lifes[i], 1);
3DEC:  CLRF   03
3DEE:  MOVLB  2
3DF0:  MOVF   x49,W
3DF2:  ADDLW  B4
3DF4:  MOVWF  FE9
3DF6:  MOVLW  01
3DF8:  ADDWFC 03,W
3DFA:  MOVWF  FEA
3DFC:  MOVFF  FEF,25C
3E00:  CLRF   03
3E02:  MOVF   x49,W
3E04:  ADDLW  C8
3E06:  MOVWF  FE9
3E08:  MOVLW  01
3E0A:  ADDWFC 03,W
3E0C:  MOVWF  FEA
3E0E:  MOVFF  FEF,25D
3E12:  CLRF   03
3E14:  MOVF   x49,W
3E16:  ADDLW  22
3E18:  MOVWF  FE9
3E1A:  MOVLW  02
3E1C:  ADDWFC 03,W
3E1E:  MOVWF  FEA
3E20:  MOVFF  FEF,25E
3E24:  MOVLW  01
3E26:  MOVWF  x5F
3E28:  MOVLB  0
3E2A:  CALL   25EC
....................                }
3E2E:  BRA    3EA2
3E30:  MOVLB  2
....................                else
....................                {
....................                   if (asteroid_lost_a_life[i])
3E32:  MOVFF  249,259
3E36:  MOVLW  02
3E38:  MOVWF  x5B
3E3A:  MOVLW  36
3E3C:  MOVWF  x5A
3E3E:  MOVLB  0
3E40:  CALL   25B6
3E44:  BTFSS  01.0
3E46:  BRA    3EA2
....................                   {
....................                      draw_asteroid(last_asteroids_x_pos[i], last_asteroids_y_pos[i], asteroids_lifes[i] + 1, 0);
3E48:  CLRF   03
3E4A:  MOVLB  2
3E4C:  MOVF   x49,W
3E4E:  ADDLW  8C
3E50:  MOVWF  FE9
3E52:  MOVLW  01
3E54:  ADDWFC 03,W
3E56:  MOVWF  FEA
3E58:  MOVFF  FEF,25C
3E5C:  CLRF   03
3E5E:  MOVF   x49,W
3E60:  ADDLW  A0
3E62:  MOVWF  FE9
3E64:  MOVLW  01
3E66:  ADDWFC 03,W
3E68:  MOVWF  FEA
3E6A:  MOVFF  FEF,25D
3E6E:  CLRF   03
3E70:  MOVF   x49,W
3E72:  ADDLW  22
3E74:  MOVWF  FE9
3E76:  MOVLW  02
3E78:  ADDWFC 03,W
3E7A:  MOVWF  FEA
3E7C:  MOVLW  01
3E7E:  ADDWF  FEF,W
3E80:  MOVWF  x5B
3E82:  MOVWF  x5E
3E84:  CLRF   x5F
3E86:  MOVLB  0
3E88:  CALL   25EC
....................                      asteroid_lost_a_life[i] = 0;
3E8C:  MOVFF  249,259
3E90:  MOVLB  2
3E92:  CLRF   x5A
3E94:  MOVLW  02
3E96:  MOVWF  x5C
3E98:  MOVLW  36
3E9A:  MOVWF  x5B
3E9C:  MOVLB  0
3E9E:  CALL   21AE
....................                   }
....................                }
....................                last_asteroids_x_pos[i] = asteroids_x_pos[i];
3EA2:  CLRF   03
3EA4:  MOVLB  2
3EA6:  MOVF   x49,W
3EA8:  ADDLW  8C
3EAA:  MOVWF  01
3EAC:  MOVLW  01
3EAE:  ADDWFC 03,F
3EB0:  MOVFF  03,25A
3EB4:  CLRF   03
3EB6:  MOVF   x49,W
3EB8:  ADDLW  B4
3EBA:  MOVWF  FE9
3EBC:  MOVLW  01
3EBE:  ADDWFC 03,W
3EC0:  MOVWF  FEA
3EC2:  MOVFF  FEF,25B
3EC6:  MOVFF  25A,FEA
3ECA:  MOVFF  01,FE9
3ECE:  MOVFF  25B,FEF
....................                last_asteroids_y_pos[i] = asteroids_y_pos[i];
3ED2:  CLRF   03
3ED4:  MOVF   x49,W
3ED6:  ADDLW  A0
3ED8:  MOVWF  01
3EDA:  MOVLW  01
3EDC:  ADDWFC 03,F
3EDE:  MOVFF  03,25A
3EE2:  CLRF   03
3EE4:  MOVF   x49,W
3EE6:  ADDLW  C8
3EE8:  MOVWF  FE9
3EEA:  MOVLW  01
3EEC:  ADDWFC 03,W
3EEE:  MOVWF  FEA
3EF0:  MOVFF  FEF,25B
3EF4:  MOVFF  25A,FEA
3EF8:  MOVFF  01,FE9
3EFC:  MOVFF  25B,FEF
3F00:  INCF   x49,F
3F02:  BRA    3D1E
....................             }
.................... 
....................             if (bullet)
3F04:  MOVLB  1
3F06:  BTFSS  x43.2
3F08:  BRA    3F1C
....................             { // dibujar la nueva bala
....................                last_last_bullet_x_pos = last_bullet_x_pos;
3F0A:  MOVFF  15E,15C
....................                last_last_bullet_y_pos = last_bullet_y_pos;
3F0E:  MOVFF  15F,15D
....................                last_bullet_x_pos = bullet_x_pos;
3F12:  MOVFF  160,15E
....................                last_bullet_y_pos = bullet_y_pos;
3F16:  MOVFF  162,15F
....................             }
3F1A:  BRA    3F2C
....................             else
....................             {
....................                last_last_bullet_x_pos = x_pos;
3F1C:  MOVFF  152,15C
....................                last_last_bullet_y_pos = y_pos;
3F20:  MOVFF  153,15D
....................                last_bullet_x_pos = x_pos;
3F24:  MOVFF  152,15E
....................                last_bullet_y_pos = y_pos;
3F28:  MOVFF  153,15F
....................             }
.................... 
....................             glcd_line(last_x_pos - 1, last_y_pos + 1, last_x_pos + 1, last_y_pos + 1, 0);
3F2C:  MOVLW  01
3F2E:  SUBWF  x50,W
3F30:  MOVLB  2
3F32:  MOVWF  x59
3F34:  MOVLW  01
3F36:  MOVLB  1
3F38:  ADDWF  x51,W
3F3A:  MOVLB  2
3F3C:  MOVWF  x5A
3F3E:  MOVLW  01
3F40:  MOVLB  1
3F42:  ADDWF  x50,W
3F44:  MOVLB  2
3F46:  MOVWF  x5B
3F48:  MOVLW  01
3F4A:  MOVLB  1
3F4C:  ADDWF  x51,W
3F4E:  MOVLB  2
3F50:  MOVWF  x5C
3F52:  MOVFF  259,2DF
3F56:  MOVFF  25A,2E0
3F5A:  MOVFF  25B,2E1
3F5E:  MOVWF  xE2
3F60:  CLRF   xE3
3F62:  MOVLB  0
3F64:  CALL   0902
....................             glcd_line(last_x_pos - 1, last_y_pos - 1, last_x_pos + 1, last_y_pos - 1, 0);
3F68:  MOVLW  01
3F6A:  MOVLB  1
3F6C:  SUBWF  x50,W
3F6E:  MOVLB  2
3F70:  MOVWF  x59
3F72:  MOVLW  01
3F74:  MOVLB  1
3F76:  SUBWF  x51,W
3F78:  MOVLB  2
3F7A:  MOVWF  x5A
3F7C:  MOVLW  01
3F7E:  MOVLB  1
3F80:  ADDWF  x50,W
3F82:  MOVLB  2
3F84:  MOVWF  x5B
3F86:  MOVLW  01
3F88:  MOVLB  1
3F8A:  SUBWF  x51,W
3F8C:  MOVLB  2
3F8E:  MOVWF  x5C
3F90:  MOVFF  259,2DF
3F94:  MOVFF  25A,2E0
3F98:  MOVFF  25B,2E1
3F9C:  MOVWF  xE2
3F9E:  CLRF   xE3
3FA0:  MOVLB  0
3FA2:  CALL   0902
....................             glcd_line(last_x_pos - 1, last_y_pos + 1, last_x_pos - 1, last_y_pos - 1, 0);
3FA6:  MOVLW  01
3FA8:  MOVLB  1
3FAA:  SUBWF  x50,W
3FAC:  MOVLB  2
3FAE:  MOVWF  x59
3FB0:  MOVLW  01
3FB2:  MOVLB  1
3FB4:  ADDWF  x51,W
3FB6:  MOVLB  2
3FB8:  MOVWF  x5A
3FBA:  MOVLW  01
3FBC:  MOVLB  1
3FBE:  SUBWF  x50,W
3FC0:  MOVLB  2
3FC2:  MOVWF  x5B
3FC4:  MOVLW  01
3FC6:  MOVLB  1
3FC8:  SUBWF  x51,W
3FCA:  MOVLB  2
3FCC:  MOVWF  x5C
3FCE:  MOVFF  259,2DF
3FD2:  MOVFF  25A,2E0
3FD6:  MOVFF  25B,2E1
3FDA:  MOVWF  xE2
3FDC:  CLRF   xE3
3FDE:  MOVLB  0
3FE0:  CALL   0902
....................             glcd_line(last_x_pos + 1, last_y_pos + 1, last_x_pos + 1, last_y_pos - 1, 0);
3FE4:  MOVLW  01
3FE6:  MOVLB  1
3FE8:  ADDWF  x50,W
3FEA:  MOVLB  2
3FEC:  MOVWF  x59
3FEE:  MOVLW  01
3FF0:  MOVLB  1
3FF2:  ADDWF  x51,W
3FF4:  MOVLB  2
3FF6:  MOVWF  x5A
3FF8:  MOVLW  01
3FFA:  MOVLB  1
3FFC:  ADDWF  x50,W
3FFE:  MOVLB  2
4000:  MOVWF  x5B
4002:  MOVLW  01
4004:  MOVLB  1
4006:  SUBWF  x51,W
4008:  MOVLB  2
400A:  MOVWF  x5C
400C:  MOVFF  259,2DF
4010:  MOVFF  25A,2E0
4014:  MOVFF  25B,2E1
4018:  MOVWF  xE2
401A:  CLRF   xE3
401C:  MOVLB  0
401E:  CALL   0902
.................... 
....................             glcd_line(x_pos - 1, y_pos + 1, x_pos + 1, y_pos + 1, 1);
4022:  MOVLW  01
4024:  MOVLB  1
4026:  SUBWF  x52,W
4028:  MOVLB  2
402A:  MOVWF  x59
402C:  MOVLW  01
402E:  MOVLB  1
4030:  ADDWF  x53,W
4032:  MOVLB  2
4034:  MOVWF  x5A
4036:  MOVLW  01
4038:  MOVLB  1
403A:  ADDWF  x52,W
403C:  MOVLB  2
403E:  MOVWF  x5B
4040:  MOVLW  01
4042:  MOVLB  1
4044:  ADDWF  x53,W
4046:  MOVLB  2
4048:  MOVWF  x5C
404A:  MOVFF  259,2DF
404E:  MOVFF  25A,2E0
4052:  MOVFF  25B,2E1
4056:  MOVWF  xE2
4058:  MOVLW  01
405A:  MOVWF  xE3
405C:  MOVLB  0
405E:  CALL   0902
....................             glcd_line(x_pos - 1, y_pos - 1, x_pos + 1, y_pos - 1, 1);
4062:  MOVLW  01
4064:  MOVLB  1
4066:  SUBWF  x52,W
4068:  MOVLB  2
406A:  MOVWF  x59
406C:  MOVLW  01
406E:  MOVLB  1
4070:  SUBWF  x53,W
4072:  MOVLB  2
4074:  MOVWF  x5A
4076:  MOVLW  01
4078:  MOVLB  1
407A:  ADDWF  x52,W
407C:  MOVLB  2
407E:  MOVWF  x5B
4080:  MOVLW  01
4082:  MOVLB  1
4084:  SUBWF  x53,W
4086:  MOVLB  2
4088:  MOVWF  x5C
408A:  MOVFF  259,2DF
408E:  MOVFF  25A,2E0
4092:  MOVFF  25B,2E1
4096:  MOVWF  xE2
4098:  MOVLW  01
409A:  MOVWF  xE3
409C:  MOVLB  0
409E:  CALL   0902
....................             glcd_line(x_pos - 1, y_pos + 1, x_pos - 1, y_pos - 1, 1);
40A2:  MOVLW  01
40A4:  MOVLB  1
40A6:  SUBWF  x52,W
40A8:  MOVLB  2
40AA:  MOVWF  x59
40AC:  MOVLW  01
40AE:  MOVLB  1
40B0:  ADDWF  x53,W
40B2:  MOVLB  2
40B4:  MOVWF  x5A
40B6:  MOVLW  01
40B8:  MOVLB  1
40BA:  SUBWF  x52,W
40BC:  MOVLB  2
40BE:  MOVWF  x5B
40C0:  MOVLW  01
40C2:  MOVLB  1
40C4:  SUBWF  x53,W
40C6:  MOVLB  2
40C8:  MOVWF  x5C
40CA:  MOVFF  259,2DF
40CE:  MOVFF  25A,2E0
40D2:  MOVFF  25B,2E1
40D6:  MOVWF  xE2
40D8:  MOVLW  01
40DA:  MOVWF  xE3
40DC:  MOVLB  0
40DE:  CALL   0902
....................             glcd_line(x_pos + 1, y_pos + 1, x_pos + 1, y_pos - 1, 1);
40E2:  MOVLW  01
40E4:  MOVLB  1
40E6:  ADDWF  x52,W
40E8:  MOVLB  2
40EA:  MOVWF  x59
40EC:  MOVLW  01
40EE:  MOVLB  1
40F0:  ADDWF  x53,W
40F2:  MOVLB  2
40F4:  MOVWF  x5A
40F6:  MOVLW  01
40F8:  MOVLB  1
40FA:  ADDWF  x52,W
40FC:  MOVLB  2
40FE:  MOVWF  x5B
4100:  MOVLW  01
4102:  MOVLB  1
4104:  SUBWF  x53,W
4106:  MOVLB  2
4108:  MOVWF  x5C
410A:  MOVFF  259,2DF
410E:  MOVFF  25A,2E0
4112:  MOVFF  25B,2E1
4116:  MOVWF  xE2
4118:  MOVLW  01
411A:  MOVWF  xE3
411C:  MOVLB  0
411E:  CALL   0902
.................... 
....................             last_ship_angle = ship_angle; // guardar la posicion anterior
4122:  MOVFF  14F,14B
4126:  MOVFF  14E,14A
412A:  MOVFF  14D,149
412E:  MOVFF  14C,148
....................             last_x_pos = x_pos;
4132:  MOVFF  152,150
....................             last_y_pos = y_pos;
4136:  MOVFF  153,151
.................... 
....................             for (int i = 0; i < 20; i++)
413A:  MOVLB  2
413C:  CLRF   x4A
413E:  MOVF   x4A,W
4140:  SUBLW  13
4142:  BNC   415A
....................             { // checa si ya mataste todos los asteroides
....................                temp += asteroids_lifes[i];
4144:  CLRF   03
4146:  MOVF   x4A,W
4148:  ADDLW  22
414A:  MOVWF  FE9
414C:  MOVLW  02
414E:  ADDWFC 03,W
4150:  MOVWF  FEA
4152:  MOVF   FEF,W
4154:  ADDWF  x39,F
4156:  INCF   x4A,F
4158:  BRA    413E
....................             }
....................             if (!temp || new_level)
415A:  MOVF   x39,F
415C:  BZ    4166
415E:  MOVLB  1
4160:  BTFSS  x43.7
4162:  BRA    416A
4164:  MOVLB  2
....................             {
....................                new_level = 1;
4166:  MOVLB  1
4168:  BSF    x43.7
....................                // glcd_fillScreen(1);
....................             }
....................             scores(last_score, last_level, 0);
416A:  MOVFF  20B,25A
416E:  MOVFF  20A,259
4172:  MOVFF  20C,25B
4176:  MOVLB  2
4178:  CLRF   x5C
417A:  MOVLB  0
417C:  CALL   2A16
....................             scores(score, level, 1);
4180:  MOVFF  207,25A
4184:  MOVFF  206,259
4188:  MOVFF  204,25B
418C:  MOVLW  01
418E:  MOVLB  2
4190:  MOVWF  x5C
4192:  MOVLB  0
4194:  CALL   2A16
....................             last_score = score;
4198:  MOVFF  207,20B
419C:  MOVFF  206,20A
....................             last_level = level;
41A0:  MOVFF  204,20C
.................... 
....................             delay_ms((int16)(22.0f - ((float)temp * 0.2f))); // manten los frames constantes segun cuantas cosas hayas dibujado
41A4:  MOVLB  2
41A6:  CLRF   x90
41A8:  MOVFF  239,28F
41AC:  MOVLB  0
41AE:  CALL   1A16
41B2:  MOVFF  03,25C
41B6:  MOVFF  02,25B
41BA:  MOVFF  01,25A
41BE:  MOVFF  00,259
41C2:  MOVFF  03,292
41C6:  MOVFF  02,291
41CA:  MOVFF  01,290
41CE:  MOVFF  00,28F
41D2:  MOVLW  CD
41D4:  MOVLB  2
41D6:  MOVWF  x96
41D8:  MOVLW  CC
41DA:  MOVWF  x95
41DC:  MOVLW  4C
41DE:  MOVWF  x94
41E0:  MOVLW  7C
41E2:  MOVWF  x93
41E4:  MOVLB  0
41E6:  CALL   1F52
41EA:  BSF    FD8.1
41EC:  MOVLB  2
41EE:  CLRF   x92
41F0:  CLRF   x91
41F2:  MOVLW  30
41F4:  MOVWF  x90
41F6:  MOVLW  83
41F8:  MOVWF  x8F
41FA:  MOVFF  03,296
41FE:  MOVFF  02,295
4202:  MOVFF  01,294
4206:  MOVFF  00,293
420A:  MOVLB  0
420C:  CALL   1C12
4210:  MOVFF  03,28E
4214:  MOVFF  02,28D
4218:  MOVFF  01,28C
421C:  MOVFF  00,28B
4220:  CALL   1BAA
4224:  MOVFF  02,25A
4228:  MOVFF  01,259
422C:  MOVFF  02,25B
4230:  MOVLB  2
4232:  INCF   x5B,F
4234:  DECF   x5B,F
4236:  BTFSC  FD8.2
4238:  BRA    4246
423A:  SETF   x79
423C:  MOVLB  0
423E:  CALL   05EC
4242:  MOVLB  2
4244:  BRA    4234
4246:  MOVFF  259,279
424A:  MOVLB  0
424C:  CALL   05EC
.................... 
....................             temp = 0;
4250:  MOVLB  2
4252:  CLRF   x39
4254:  MOVLB  0
....................          }
....................          break;
4256:  MOVLB  2
4258:  GOTO   4CF6
425C:  MOVLB  0
....................       }
....................       case 'J':
....................       { // jugando multiplayer
....................          if (new_game)
425E:  MOVLB  2
4260:  BTFSS  x20.3
4262:  BRA    427A
....................          {
....................             new_game = 0;
4264:  BCF    x20.3
....................             x_pos_1 = 10;
4266:  MOVLW  0A
4268:  MOVLB  1
426A:  MOVWF  x25
....................             y_pos_1 = 20;
426C:  MOVLW  14
426E:  MOVWF  x26
....................             x_pos_2 = 120;
4270:  MOVLW  78
4272:  MOVWF  x39
....................             y_pos_2 = 40;
4274:  MOVLW  28
4276:  MOVWF  x3A
4278:  MOVLB  2
....................          }
.................... 
....................          dx_1 = get_d(p1_pot_x);        // potenciometro movimiento
427A:  MOVFF  212,259
427E:  MOVLB  0
4280:  CALL   2AA6
4284:  MOVFF  03,12A
4288:  MOVFF  02,129
428C:  MOVFF  01,128
4290:  MOVFF  00,127
....................          dy_1 = get_d(p1_pot_y);        // potenciometro movimiento
4294:  MOVFF  213,259
4298:  CALL   2AA6
429C:  MOVFF  03,12E
42A0:  MOVFF  02,12D
42A4:  MOVFF  01,12C
42A8:  MOVFF  00,12B
....................          if ((float)x_pos_1 + dx_1 < 4) // mover jugador
42AC:  MOVLB  2
42AE:  CLRF   x90
42B0:  MOVFF  125,28F
42B4:  MOVLB  0
42B6:  CALL   1A16
42BA:  MOVFF  03,25C
42BE:  MOVFF  02,25B
42C2:  MOVFF  01,25A
42C6:  MOVFF  00,259
42CA:  BCF    FD8.1
42CC:  MOVFF  03,292
42D0:  MOVFF  02,291
42D4:  MOVFF  01,290
42D8:  MOVFF  00,28F
42DC:  MOVFF  12A,296
42E0:  MOVFF  129,295
42E4:  MOVFF  128,294
42E8:  MOVFF  127,293
42EC:  CALL   1C12
42F0:  MOVFF  03,25C
42F4:  MOVFF  02,25B
42F8:  MOVFF  01,25A
42FC:  MOVFF  00,259
4300:  MOVFF  03,28E
4304:  MOVFF  02,28D
4308:  MOVFF  01,28C
430C:  MOVFF  00,28B
4310:  MOVLB  2
4312:  CLRF   x92
4314:  CLRF   x91
4316:  CLRF   x90
4318:  MOVLW  81
431A:  MOVWF  x8F
431C:  MOVLB  0
431E:  CALL   2134
4322:  BNC   4388
....................             x_pos_1 = 123 + (int)((float)x_pos_1 + dx_1);
4324:  MOVLB  2
4326:  CLRF   x90
4328:  MOVFF  125,28F
432C:  MOVLB  0
432E:  CALL   1A16
4332:  MOVFF  03,25C
4336:  MOVFF  02,25B
433A:  MOVFF  01,25A
433E:  MOVFF  00,259
4342:  BCF    FD8.1
4344:  MOVFF  03,292
4348:  MOVFF  02,291
434C:  MOVFF  01,290
4350:  MOVFF  00,28F
4354:  MOVFF  12A,296
4358:  MOVFF  129,295
435C:  MOVFF  128,294
4360:  MOVFF  127,293
4364:  CALL   1C12
4368:  MOVFF  03,28E
436C:  MOVFF  02,28D
4370:  MOVFF  01,28C
4374:  MOVFF  00,28B
4378:  CALL   1BAA
437C:  MOVLW  7B
437E:  ADDWF  01,W
4380:  MOVLB  1
4382:  MOVWF  x25
4384:  BRA    43B8
4386:  MOVLB  0
....................          else
....................             x_pos_1 = (x_pos_1 + (int)dx_1) % 123;
4388:  MOVFF  12A,28E
438C:  MOVFF  129,28D
4390:  MOVFF  128,28C
4394:  MOVFF  127,28B
4398:  CALL   1BAA
439C:  MOVF   01,W
439E:  MOVLB  1
43A0:  ADDWF  x25,W
43A2:  MOVLB  2
43A4:  MOVWF  x5A
43A6:  MOVWF  x69
43A8:  MOVLW  7B
43AA:  MOVWF  x6A
43AC:  MOVLB  0
43AE:  CALL   1BE6
43B2:  MOVFF  00,125
43B6:  MOVLB  1
.................... 
....................          if ((float)y_pos_1 - dy_1 < 4) // mover jugador
43B8:  MOVLB  2
43BA:  CLRF   x90
43BC:  MOVFF  126,28F
43C0:  MOVLB  0
43C2:  CALL   1A16
43C6:  MOVFF  03,25C
43CA:  MOVFF  02,25B
43CE:  MOVFF  01,25A
43D2:  MOVFF  00,259
43D6:  BSF    FD8.1
43D8:  MOVFF  03,292
43DC:  MOVFF  02,291
43E0:  MOVFF  01,290
43E4:  MOVFF  00,28F
43E8:  MOVFF  12E,296
43EC:  MOVFF  12D,295
43F0:  MOVFF  12C,294
43F4:  MOVFF  12B,293
43F8:  CALL   1C12
43FC:  MOVFF  03,25C
4400:  MOVFF  02,25B
4404:  MOVFF  01,25A
4408:  MOVFF  00,259
440C:  MOVFF  03,28E
4410:  MOVFF  02,28D
4414:  MOVFF  01,28C
4418:  MOVFF  00,28B
441C:  MOVLB  2
441E:  CLRF   x92
4420:  CLRF   x91
4422:  CLRF   x90
4424:  MOVLW  81
4426:  MOVWF  x8F
4428:  MOVLB  0
442A:  CALL   2134
442E:  BNC   4494
....................             y_pos_1 = 59 + (int)((float)y_pos_1 - dy_1);
4430:  MOVLB  2
4432:  CLRF   x90
4434:  MOVFF  126,28F
4438:  MOVLB  0
443A:  CALL   1A16
443E:  MOVFF  03,25C
4442:  MOVFF  02,25B
4446:  MOVFF  01,25A
444A:  MOVFF  00,259
444E:  BSF    FD8.1
4450:  MOVFF  03,292
4454:  MOVFF  02,291
4458:  MOVFF  01,290
445C:  MOVFF  00,28F
4460:  MOVFF  12E,296
4464:  MOVFF  12D,295
4468:  MOVFF  12C,294
446C:  MOVFF  12B,293
4470:  CALL   1C12
4474:  MOVFF  03,28E
4478:  MOVFF  02,28D
447C:  MOVFF  01,28C
4480:  MOVFF  00,28B
4484:  CALL   1BAA
4488:  MOVLW  3B
448A:  ADDWF  01,W
448C:  MOVLB  1
448E:  MOVWF  x26
4490:  BRA    44C4
4492:  MOVLB  0
....................          else
....................             y_pos_1 = (y_pos_1 - (int)dy_1) % 59;
4494:  MOVFF  12E,28E
4498:  MOVFF  12D,28D
449C:  MOVFF  12C,28C
44A0:  MOVFF  12B,28B
44A4:  CALL   1BAA
44A8:  MOVF   01,W
44AA:  MOVLB  1
44AC:  SUBWF  x26,W
44AE:  MOVLB  2
44B0:  MOVWF  x5A
44B2:  MOVWF  x69
44B4:  MOVLW  3B
44B6:  MOVWF  x6A
44B8:  MOVLB  0
44BA:  CALL   1BE6
44BE:  MOVFF  00,126
44C2:  MOVLB  1
.................... 
....................          dx_2 = get_d(p2_pot_x);        // potenciometro movimiento
44C4:  MOVFF  216,259
44C8:  MOVLB  0
44CA:  CALL   2AA6
44CE:  MOVFF  03,13E
44D2:  MOVFF  02,13D
44D6:  MOVFF  01,13C
44DA:  MOVFF  00,13B
....................          dy_2 = get_d(p2_pot_y);        // potenciometro movimiento
44DE:  MOVFF  217,259
44E2:  CALL   2AA6
44E6:  MOVFF  03,142
44EA:  MOVFF  02,141
44EE:  MOVFF  01,140
44F2:  MOVFF  00,13F
....................          if ((float)x_pos_2 + dx_2 < 4) // mover jugador
44F6:  MOVLB  2
44F8:  CLRF   x90
44FA:  MOVFF  139,28F
44FE:  MOVLB  0
4500:  CALL   1A16
4504:  MOVFF  03,25C
4508:  MOVFF  02,25B
450C:  MOVFF  01,25A
4510:  MOVFF  00,259
4514:  BCF    FD8.1
4516:  MOVFF  03,292
451A:  MOVFF  02,291
451E:  MOVFF  01,290
4522:  MOVFF  00,28F
4526:  MOVFF  13E,296
452A:  MOVFF  13D,295
452E:  MOVFF  13C,294
4532:  MOVFF  13B,293
4536:  CALL   1C12
453A:  MOVFF  03,25C
453E:  MOVFF  02,25B
4542:  MOVFF  01,25A
4546:  MOVFF  00,259
454A:  MOVFF  03,28E
454E:  MOVFF  02,28D
4552:  MOVFF  01,28C
4556:  MOVFF  00,28B
455A:  MOVLB  2
455C:  CLRF   x92
455E:  CLRF   x91
4560:  CLRF   x90
4562:  MOVLW  81
4564:  MOVWF  x8F
4566:  MOVLB  0
4568:  CALL   2134
456C:  BNC   45D2
....................             x_pos_2 = 123 + (int)((float)x_pos_2 + dx_2);
456E:  MOVLB  2
4570:  CLRF   x90
4572:  MOVFF  139,28F
4576:  MOVLB  0
4578:  CALL   1A16
457C:  MOVFF  03,25C
4580:  MOVFF  02,25B
4584:  MOVFF  01,25A
4588:  MOVFF  00,259
458C:  BCF    FD8.1
458E:  MOVFF  03,292
4592:  MOVFF  02,291
4596:  MOVFF  01,290
459A:  MOVFF  00,28F
459E:  MOVFF  13E,296
45A2:  MOVFF  13D,295
45A6:  MOVFF  13C,294
45AA:  MOVFF  13B,293
45AE:  CALL   1C12
45B2:  MOVFF  03,28E
45B6:  MOVFF  02,28D
45BA:  MOVFF  01,28C
45BE:  MOVFF  00,28B
45C2:  CALL   1BAA
45C6:  MOVLW  7B
45C8:  ADDWF  01,W
45CA:  MOVLB  1
45CC:  MOVWF  x39
45CE:  BRA    4602
45D0:  MOVLB  0
....................          else
....................             x_pos_2 = (x_pos_2 + (int)dx_2) % 123;
45D2:  MOVFF  13E,28E
45D6:  MOVFF  13D,28D
45DA:  MOVFF  13C,28C
45DE:  MOVFF  13B,28B
45E2:  CALL   1BAA
45E6:  MOVF   01,W
45E8:  MOVLB  1
45EA:  ADDWF  x39,W
45EC:  MOVLB  2
45EE:  MOVWF  x5A
45F0:  MOVWF  x69
45F2:  MOVLW  7B
45F4:  MOVWF  x6A
45F6:  MOVLB  0
45F8:  CALL   1BE6
45FC:  MOVFF  00,139
4600:  MOVLB  1
.................... 
....................          if ((float)y_pos_2 - dy_2 < 4) // mover jugador
4602:  MOVLB  2
4604:  CLRF   x90
4606:  MOVFF  13A,28F
460A:  MOVLB  0
460C:  CALL   1A16
4610:  MOVFF  03,25C
4614:  MOVFF  02,25B
4618:  MOVFF  01,25A
461C:  MOVFF  00,259
4620:  BSF    FD8.1
4622:  MOVFF  03,292
4626:  MOVFF  02,291
462A:  MOVFF  01,290
462E:  MOVFF  00,28F
4632:  MOVFF  142,296
4636:  MOVFF  141,295
463A:  MOVFF  140,294
463E:  MOVFF  13F,293
4642:  CALL   1C12
4646:  MOVFF  03,25C
464A:  MOVFF  02,25B
464E:  MOVFF  01,25A
4652:  MOVFF  00,259
4656:  MOVFF  03,28E
465A:  MOVFF  02,28D
465E:  MOVFF  01,28C
4662:  MOVFF  00,28B
4666:  MOVLB  2
4668:  CLRF   x92
466A:  CLRF   x91
466C:  CLRF   x90
466E:  MOVLW  81
4670:  MOVWF  x8F
4672:  MOVLB  0
4674:  CALL   2134
4678:  BNC   46DE
....................             y_pos_2 = 59 + (int)((float)y_pos_2 - dy_2);
467A:  MOVLB  2
467C:  CLRF   x90
467E:  MOVFF  13A,28F
4682:  MOVLB  0
4684:  CALL   1A16
4688:  MOVFF  03,25C
468C:  MOVFF  02,25B
4690:  MOVFF  01,25A
4694:  MOVFF  00,259
4698:  BSF    FD8.1
469A:  MOVFF  03,292
469E:  MOVFF  02,291
46A2:  MOVFF  01,290
46A6:  MOVFF  00,28F
46AA:  MOVFF  142,296
46AE:  MOVFF  141,295
46B2:  MOVFF  140,294
46B6:  MOVFF  13F,293
46BA:  CALL   1C12
46BE:  MOVFF  03,28E
46C2:  MOVFF  02,28D
46C6:  MOVFF  01,28C
46CA:  MOVFF  00,28B
46CE:  CALL   1BAA
46D2:  MOVLW  3B
46D4:  ADDWF  01,W
46D6:  MOVLB  1
46D8:  MOVWF  x3A
46DA:  BRA    470E
46DC:  MOVLB  0
....................          else
....................             y_pos_2 = (y_pos_2 - (int)dy_2) % 59;
46DE:  MOVFF  142,28E
46E2:  MOVFF  141,28D
46E6:  MOVFF  140,28C
46EA:  MOVFF  13F,28B
46EE:  CALL   1BAA
46F2:  MOVF   01,W
46F4:  MOVLB  1
46F6:  SUBWF  x3A,W
46F8:  MOVLB  2
46FA:  MOVWF  x5A
46FC:  MOVWF  x69
46FE:  MOVLW  3B
4700:  MOVWF  x6A
4702:  MOVLB  0
4704:  CALL   1BE6
4708:  MOVFF  00,13A
470C:  MOVLB  1
.................... 
....................          if(shoot_1){
470E:  BTFSS  x43.0
4710:  BRA    4716
....................             cooldown_1 = 0;
4712:  CLRF   x44
....................          }
4714:  BRA    47B0
....................          else{
....................             cooldown_1--;
4716:  DECF   x44,F
....................             if(cooldown_1 == 0){
4718:  MOVF   x44,F
471A:  BNZ   471E
....................                shoot_1 = 1;
471C:  BSF    x43.0
....................             }
....................             if(cooldown_1 == 10){
471E:  MOVF   x44,W
4720:  SUBLW  0A
4722:  BNZ   47B0
....................                switch(aiming_1){
4724:  MOVF   x45,W
4726:  ADDLW  FB
4728:  BC    47B0
472A:  ADDLW  05
472C:  MOVLB  0
472E:  GOTO   4D04
....................                   case 0: 
....................                   case 1:{
....................                      glcd_line(last_bullet_x_pos_1, last_bullet_y_pos_1, 128, last_bullet_y_pos_1, 0);
4732:  MOVFF  16E,2DF
4736:  MOVFF  16F,2E0
473A:  MOVLW  80
473C:  MOVLB  2
473E:  MOVWF  xE1
4740:  MOVFF  16F,2E2
4744:  CLRF   xE3
4746:  MOVLB  0
4748:  CALL   0902
....................                      break;
474C:  MOVLB  1
474E:  BRA    47B0
4750:  MOVLB  0
....................                   }
....................                   case 2:{
....................                      glcd_line(last_bullet_x_pos_1, last_bullet_y_pos_1, last_bullet_x_pos_1, 0, 0);
4752:  MOVFF  16E,2DF
4756:  MOVFF  16F,2E0
475A:  MOVFF  16E,2E1
475E:  MOVLB  2
4760:  CLRF   xE2
4762:  CLRF   xE3
4764:  MOVLB  0
4766:  CALL   0902
....................                      break;
476A:  MOVLB  1
476C:  BRA    47B0
476E:  MOVLB  0
....................                   }
....................                   case 3:{
....................                      glcd_line(0, last_bullet_y_pos_1, last_bullet_x_pos_1, last_bullet_y_pos_1, 0);
4770:  MOVLB  2
4772:  CLRF   xDF
4774:  MOVFF  16F,2E0
4778:  MOVFF  16E,2E1
477C:  MOVFF  16F,2E2
4780:  CLRF   xE3
4782:  MOVLB  0
4784:  CALL   0902
....................                      break;
4788:  MOVLB  1
478A:  BRA    47B0
478C:  MOVLB  0
....................                   }
....................                   case 4:{
....................                      glcd_line(last_bullet_x_pos_1, last_bullet_y_pos_1, last_bullet_x_pos_1, 63, 0);
478E:  MOVFF  16E,2DF
4792:  MOVFF  16F,2E0
4796:  MOVFF  16E,2E1
479A:  MOVLW  3F
479C:  MOVLB  2
479E:  MOVWF  xE2
47A0:  CLRF   xE3
47A2:  MOVLB  0
47A4:  CALL   0902
....................                      break;
47A8:  MOVLB  1
47AA:  BRA    47B0
47AC:  MOVLB  0
47AE:  MOVLB  1
....................                   }
....................                }
....................             }
....................          }
.................... 
....................          if(p1_L && shoot_1){
47B0:  MOVLB  2
47B2:  BTFSS  x10.2
47B4:  BRA    497A
47B6:  MOVLB  1
47B8:  BTFSC  x43.0
47BA:  BRA    47C0
47BC:  MOVLB  2
47BE:  BRA    497A
....................             aiming_1 = laser_waza(p1_pot_xx, p1_pot_yy);
47C0:  MOVFF  214,259
47C4:  MOVFF  215,25A
47C8:  MOVLB  0
47CA:  CALL   2B20
47CE:  MOVFF  01,145
....................             switch(aiming_1){
47D2:  MOVLB  1
47D4:  MOVF   x45,W
47D6:  ADDLW  FB
47D8:  BTFSC  FD8.0
47DA:  BRA    496A
47DC:  ADDLW  05
47DE:  MOVLB  0
47E0:  GOTO   4D28
....................                case 0: 
....................                case 1:{
....................                   glcd_line(x_pos_1, y_pos_1, 128, y_pos_1, 1);
47E4:  MOVFF  125,2DF
47E8:  MOVFF  126,2E0
47EC:  MOVLW  80
47EE:  MOVLB  2
47F0:  MOVWF  xE1
47F2:  MOVFF  126,2E2
47F6:  MOVLW  01
47F8:  MOVWF  xE3
47FA:  MOVLB  0
47FC:  CALL   0902
....................                   if(x_pos_2 > x_pos_1){
4800:  MOVLB  1
4802:  MOVF   x39,W
4804:  SUBWF  x25,W
4806:  BC    4842
....................                      if( (y_pos_2 < (y_pos_1 + 4)) && (y_pos_2 > (y_pos_1 - 4))){
4808:  MOVLW  04
480A:  ADDWF  x26,W
480C:  SUBWF  x3A,W
480E:  BC    4842
4810:  MOVLW  04
4812:  SUBWF  x26,W
4814:  SUBWF  x3A,W
4816:  BZ    4842
4818:  BNC   4842
....................                         new_game = 1;
481A:  MOVLB  2
481C:  BSF    x20.3
....................                         mode = 'i';
481E:  MOVLW  69
4820:  MOVWF  x0E
....................                         delay_ms(500);
4822:  MOVLW  02
4824:  MOVWF  x59
4826:  MOVLW  FA
4828:  MOVWF  x79
482A:  MOVLB  0
482C:  CALL   05EC
4830:  MOVLB  2
4832:  DECFSZ x59,F
4834:  BRA    4826
....................                         draw_win(1);
4836:  MOVLW  01
4838:  MOVWF  x59
483A:  MOVLB  0
483C:  CALL   2B5E
4840:  MOVLB  1
....................                      }
....................                   }
....................                   break;
4842:  BRA    496A
4844:  MOVLB  0
....................                }
....................                case 2:{
....................                   glcd_line(x_pos_1, y_pos_1, x_pos_1, 0, 1);
4846:  MOVFF  125,2DF
484A:  MOVFF  126,2E0
484E:  MOVFF  125,2E1
4852:  MOVLB  2
4854:  CLRF   xE2
4856:  MOVLW  01
4858:  MOVWF  xE3
485A:  MOVLB  0
485C:  CALL   0902
....................                   if(y_pos_2 < y_pos_1){
4860:  MOVLB  1
4862:  MOVF   x26,W
4864:  SUBWF  x3A,W
4866:  BC    48A2
....................                      if( (x_pos_2 < (x_pos_1 + 4)) && (x_pos_2 > (x_pos_1 - 4))){
4868:  MOVLW  04
486A:  ADDWF  x25,W
486C:  SUBWF  x39,W
486E:  BC    48A2
4870:  MOVLW  04
4872:  SUBWF  x25,W
4874:  SUBWF  x39,W
4876:  BZ    48A2
4878:  BNC   48A2
....................                         new_game = 1;
487A:  MOVLB  2
487C:  BSF    x20.3
....................                         mode = 'i';
487E:  MOVLW  69
4880:  MOVWF  x0E
....................                         delay_ms(500);
4882:  MOVLW  02
4884:  MOVWF  x59
4886:  MOVLW  FA
4888:  MOVWF  x79
488A:  MOVLB  0
488C:  CALL   05EC
4890:  MOVLB  2
4892:  DECFSZ x59,F
4894:  BRA    4886
....................                         draw_win(1);
4896:  MOVLW  01
4898:  MOVWF  x59
489A:  MOVLB  0
489C:  CALL   2B5E
48A0:  MOVLB  1
....................                      }
....................                   }
....................                   break;
48A2:  BRA    496A
48A4:  MOVLB  0
....................                }
....................                case 3:{
....................                   glcd_line(0, y_pos_1, x_pos_1, y_pos_1, 1);
48A6:  MOVLB  2
48A8:  CLRF   xDF
48AA:  MOVFF  126,2E0
48AE:  MOVFF  125,2E1
48B2:  MOVFF  126,2E2
48B6:  MOVLW  01
48B8:  MOVWF  xE3
48BA:  MOVLB  0
48BC:  CALL   0902
....................                   if(x_pos_2 < x_pos_1){
48C0:  MOVLB  1
48C2:  MOVF   x25,W
48C4:  SUBWF  x39,W
48C6:  BC    4902
....................                      if( (y_pos_2 < (y_pos_1 + 4)) && (y_pos_2 > (y_pos_1 - 4))){
48C8:  MOVLW  04
48CA:  ADDWF  x26,W
48CC:  SUBWF  x3A,W
48CE:  BC    4902
48D0:  MOVLW  04
48D2:  SUBWF  x26,W
48D4:  SUBWF  x3A,W
48D6:  BZ    4902
48D8:  BNC   4902
....................                         new_game = 1;
48DA:  MOVLB  2
48DC:  BSF    x20.3
....................                         mode = 'i';
48DE:  MOVLW  69
48E0:  MOVWF  x0E
....................                         delay_ms(500);
48E2:  MOVLW  02
48E4:  MOVWF  x59
48E6:  MOVLW  FA
48E8:  MOVWF  x79
48EA:  MOVLB  0
48EC:  CALL   05EC
48F0:  MOVLB  2
48F2:  DECFSZ x59,F
48F4:  BRA    48E6
....................                         draw_win(1);
48F6:  MOVLW  01
48F8:  MOVWF  x59
48FA:  MOVLB  0
48FC:  CALL   2B5E
4900:  MOVLB  1
....................                      }
....................                   }
....................                   break;
4902:  BRA    496A
4904:  MOVLB  0
....................                }
....................                case 4:{
....................                   glcd_line(x_pos_1, y_pos_1, x_pos_1, 63, 1);
4906:  MOVFF  125,2DF
490A:  MOVFF  126,2E0
490E:  MOVFF  125,2E1
4912:  MOVLW  3F
4914:  MOVLB  2
4916:  MOVWF  xE2
4918:  MOVLW  01
491A:  MOVWF  xE3
491C:  MOVLB  0
491E:  CALL   0902
....................                   if(y_pos_2 > y_pos_1){
4922:  MOVLB  1
4924:  MOVF   x3A,W
4926:  SUBWF  x26,W
4928:  BC    4964
....................                      if( (x_pos_2 < (x_pos_1 + 4)) && (x_pos_2 > (x_pos_1 - 4))){
492A:  MOVLW  04
492C:  ADDWF  x25,W
492E:  SUBWF  x39,W
4930:  BC    4964
4932:  MOVLW  04
4934:  SUBWF  x25,W
4936:  SUBWF  x39,W
4938:  BZ    4964
493A:  BNC   4964
....................                         new_game = 1;
493C:  MOVLB  2
493E:  BSF    x20.3
....................                         mode = 'i';
4940:  MOVLW  69
4942:  MOVWF  x0E
....................                         delay_ms(500);
4944:  MOVLW  02
4946:  MOVWF  x59
4948:  MOVLW  FA
494A:  MOVWF  x79
494C:  MOVLB  0
494E:  CALL   05EC
4952:  MOVLB  2
4954:  DECFSZ x59,F
4956:  BRA    4948
....................                         draw_win(1);
4958:  MOVLW  01
495A:  MOVWF  x59
495C:  MOVLB  0
495E:  CALL   2B5E
4962:  MOVLB  1
....................                      }
....................                   }
....................                   break;
4964:  BRA    496A
4966:  MOVLB  0
4968:  MOVLB  1
....................                }
....................             }
....................             cooldown_1 = 15;
496A:  MOVLW  0F
496C:  MOVWF  x44
....................             shoot_1 = 0;
496E:  BCF    x43.0
....................             last_bullet_x_pos_1 = x_pos_1;
4970:  MOVFF  125,16E
....................             last_bullet_y_pos_1 = y_pos_1;
4974:  MOVFF  126,16F
4978:  MOVLB  2
.................... 
....................          }
.................... 
....................          if(shoot_2){
497A:  MOVLB  1
497C:  BTFSS  x43.1
497E:  BRA    4984
....................             cooldown_2 = 0;
4980:  CLRF   x46
....................          }
4982:  BRA    4A1E
....................          else{
....................             cooldown_2--;
4984:  DECF   x46,F
....................             if(cooldown_2 == 0){
4986:  MOVF   x46,F
4988:  BNZ   498C
....................                shoot_2 = 1;
498A:  BSF    x43.1
....................             }
....................             if(cooldown_2 == 10){
498C:  MOVF   x46,W
498E:  SUBLW  0A
4990:  BNZ   4A1E
....................                switch(aiming_2){
4992:  MOVF   x47,W
4994:  ADDLW  FB
4996:  BC    4A1E
4998:  ADDLW  05
499A:  MOVLB  0
499C:  GOTO   4D4C
....................                   case 0: 
....................                   case 1:{
....................                      glcd_line(last_bullet_x_pos_2, last_bullet_y_pos_2, 128, last_bullet_y_pos_2, 0);
49A0:  MOVFF  17E,2DF
49A4:  MOVFF  17F,2E0
49A8:  MOVLW  80
49AA:  MOVLB  2
49AC:  MOVWF  xE1
49AE:  MOVFF  17F,2E2
49B2:  CLRF   xE3
49B4:  MOVLB  0
49B6:  CALL   0902
....................                      break;
49BA:  MOVLB  1
49BC:  BRA    4A1E
49BE:  MOVLB  0
....................                   }
....................                   case 2:{
....................                      glcd_line(last_bullet_x_pos_2, last_bullet_y_pos_2, last_bullet_x_pos_2, 0, 0);
49C0:  MOVFF  17E,2DF
49C4:  MOVFF  17F,2E0
49C8:  MOVFF  17E,2E1
49CC:  MOVLB  2
49CE:  CLRF   xE2
49D0:  CLRF   xE3
49D2:  MOVLB  0
49D4:  CALL   0902
....................                      break;
49D8:  MOVLB  1
49DA:  BRA    4A1E
49DC:  MOVLB  0
....................                   }
....................                   case 3:{
....................                      glcd_line(0, last_bullet_y_pos_2, last_bullet_x_pos_2, last_bullet_y_pos_2, 0);
49DE:  MOVLB  2
49E0:  CLRF   xDF
49E2:  MOVFF  17F,2E0
49E6:  MOVFF  17E,2E1
49EA:  MOVFF  17F,2E2
49EE:  CLRF   xE3
49F0:  MOVLB  0
49F2:  CALL   0902
....................                      break;
49F6:  MOVLB  1
49F8:  BRA    4A1E
49FA:  MOVLB  0
....................                   }
....................                   case 4:{
....................                      glcd_line(last_bullet_x_pos_2, last_bullet_y_pos_2, last_bullet_x_pos_2, 63, 0);
49FC:  MOVFF  17E,2DF
4A00:  MOVFF  17F,2E0
4A04:  MOVFF  17E,2E1
4A08:  MOVLW  3F
4A0A:  MOVLB  2
4A0C:  MOVWF  xE2
4A0E:  CLRF   xE3
4A10:  MOVLB  0
4A12:  CALL   0902
....................                      break;
4A16:  MOVLB  1
4A18:  BRA    4A1E
4A1A:  MOVLB  0
4A1C:  MOVLB  1
....................                   }
....................                }
....................             }
....................          }
.................... 
....................          if(p2_L && shoot_2){
4A1E:  MOVLB  2
4A20:  BTFSS  x10.4
4A22:  BRA    4BE0
4A24:  MOVLB  1
4A26:  BTFSC  x43.1
4A28:  BRA    4A2E
4A2A:  MOVLB  2
4A2C:  BRA    4BE0
....................             aiming_2 = laser_waza(p2_pot_xx, p2_pot_yy);
4A2E:  MOVFF  218,259
4A32:  MOVFF  219,25A
4A36:  MOVLB  0
4A38:  CALL   2B20
4A3C:  MOVFF  01,147
....................             switch(aiming_2){
4A40:  MOVLB  1
4A42:  MOVF   x47,W
4A44:  ADDLW  FB
4A46:  BTFSC  FD8.0
4A48:  BRA    4BD0
4A4A:  ADDLW  05
4A4C:  MOVLB  0
4A4E:  GOTO   4D70
....................                case 0: 
....................                case 1:{
....................                   glcd_line(x_pos_2, y_pos_2, 128, y_pos_2, 1);
4A52:  MOVFF  139,2DF
4A56:  MOVFF  13A,2E0
4A5A:  MOVLW  80
4A5C:  MOVLB  2
4A5E:  MOVWF  xE1
4A60:  MOVFF  13A,2E2
4A64:  MOVLW  01
4A66:  MOVWF  xE3
4A68:  MOVLB  0
4A6A:  CALL   0902
....................                   if(x_pos_1 > x_pos_2){
4A6E:  MOVLB  1
4A70:  MOVF   x25,W
4A72:  SUBWF  x39,W
4A74:  BC    4AAE
....................                      if( (y_pos_1 < (y_pos_2 + 4)) && (y_pos_1 > (y_pos_2 - 4))){
4A76:  MOVLW  04
4A78:  ADDWF  x3A,W
4A7A:  SUBWF  x26,W
4A7C:  BC    4AAE
4A7E:  MOVLW  04
4A80:  SUBWF  x3A,W
4A82:  SUBWF  x26,W
4A84:  BZ    4AAE
4A86:  BNC   4AAE
....................                         new_game = 1;
4A88:  MOVLB  2
4A8A:  BSF    x20.3
....................                         mode = 'i';
4A8C:  MOVLW  69
4A8E:  MOVWF  x0E
....................                         delay_ms(500);
4A90:  MOVLW  02
4A92:  MOVWF  x59
4A94:  MOVLW  FA
4A96:  MOVWF  x79
4A98:  MOVLB  0
4A9A:  CALL   05EC
4A9E:  MOVLB  2
4AA0:  DECFSZ x59,F
4AA2:  BRA    4A94
....................                         draw_win(0);
4AA4:  CLRF   x59
4AA6:  MOVLB  0
4AA8:  CALL   2B5E
4AAC:  MOVLB  1
....................                      }
....................                   }
....................                   break;
4AAE:  BRA    4BD0
4AB0:  MOVLB  0
....................                }
....................                case 2:{
....................                   glcd_line(x_pos_2, y_pos_2, x_pos_2, 0, 1);
4AB2:  MOVFF  139,2DF
4AB6:  MOVFF  13A,2E0
4ABA:  MOVFF  139,2E1
4ABE:  MOVLB  2
4AC0:  CLRF   xE2
4AC2:  MOVLW  01
4AC4:  MOVWF  xE3
4AC6:  MOVLB  0
4AC8:  CALL   0902
....................                   if(y_pos_1 < y_pos_2){
4ACC:  MOVLB  1
4ACE:  MOVF   x3A,W
4AD0:  SUBWF  x26,W
4AD2:  BC    4B0C
....................                      if( (x_pos_1 < (x_pos_2 + 4)) && (x_pos_1 > (x_pos_2 - 4))){
4AD4:  MOVLW  04
4AD6:  ADDWF  x39,W
4AD8:  SUBWF  x25,W
4ADA:  BC    4B0C
4ADC:  MOVLW  04
4ADE:  SUBWF  x39,W
4AE0:  SUBWF  x25,W
4AE2:  BZ    4B0C
4AE4:  BNC   4B0C
....................                         new_game = 1;
4AE6:  MOVLB  2
4AE8:  BSF    x20.3
....................                         mode = 'i';
4AEA:  MOVLW  69
4AEC:  MOVWF  x0E
....................                         delay_ms(500);
4AEE:  MOVLW  02
4AF0:  MOVWF  x59
4AF2:  MOVLW  FA
4AF4:  MOVWF  x79
4AF6:  MOVLB  0
4AF8:  CALL   05EC
4AFC:  MOVLB  2
4AFE:  DECFSZ x59,F
4B00:  BRA    4AF2
....................                         draw_win(0);
4B02:  CLRF   x59
4B04:  MOVLB  0
4B06:  CALL   2B5E
4B0A:  MOVLB  1
....................                      }
....................                   }
....................                   break;
4B0C:  BRA    4BD0
4B0E:  MOVLB  0
....................                }
....................                case 3:{
....................                   glcd_line(0, y_pos_2, x_pos_2, y_pos_2, 1);
4B10:  MOVLB  2
4B12:  CLRF   xDF
4B14:  MOVFF  13A,2E0
4B18:  MOVFF  139,2E1
4B1C:  MOVFF  13A,2E2
4B20:  MOVLW  01
4B22:  MOVWF  xE3
4B24:  MOVLB  0
4B26:  CALL   0902
....................                   if(x_pos_1 < x_pos_2){
4B2A:  MOVLB  1
4B2C:  MOVF   x39,W
4B2E:  SUBWF  x25,W
4B30:  BC    4B6A
....................                      if( (y_pos_1 < (y_pos_2 + 4)) && (y_pos_1 > (y_pos_2 - 4))){
4B32:  MOVLW  04
4B34:  ADDWF  x3A,W
4B36:  SUBWF  x26,W
4B38:  BC    4B6A
4B3A:  MOVLW  04
4B3C:  SUBWF  x3A,W
4B3E:  SUBWF  x26,W
4B40:  BZ    4B6A
4B42:  BNC   4B6A
....................                         new_game = 1;
4B44:  MOVLB  2
4B46:  BSF    x20.3
....................                         mode = 'i';
4B48:  MOVLW  69
4B4A:  MOVWF  x0E
....................                         delay_ms(500);
4B4C:  MOVLW  02
4B4E:  MOVWF  x59
4B50:  MOVLW  FA
4B52:  MOVWF  x79
4B54:  MOVLB  0
4B56:  CALL   05EC
4B5A:  MOVLB  2
4B5C:  DECFSZ x59,F
4B5E:  BRA    4B50
....................                         draw_win(0);
4B60:  CLRF   x59
4B62:  MOVLB  0
4B64:  CALL   2B5E
4B68:  MOVLB  1
....................                      }
....................                   }
....................                   break;
4B6A:  BRA    4BD0
4B6C:  MOVLB  0
....................                }
....................                case 4:{
....................                   glcd_line(x_pos_2, y_pos_2, x_pos_2, 63, 1);
4B6E:  MOVFF  139,2DF
4B72:  MOVFF  13A,2E0
4B76:  MOVFF  139,2E1
4B7A:  MOVLW  3F
4B7C:  MOVLB  2
4B7E:  MOVWF  xE2
4B80:  MOVLW  01
4B82:  MOVWF  xE3
4B84:  MOVLB  0
4B86:  CALL   0902
....................                   if(y_pos_1 > y_pos_2){
4B8A:  MOVLB  1
4B8C:  MOVF   x26,W
4B8E:  SUBWF  x3A,W
4B90:  BC    4BCA
....................                      if( (x_pos_1 < (x_pos_2 + 4)) && (x_pos_1 > (x_pos_2 - 4))){
4B92:  MOVLW  04
4B94:  ADDWF  x39,W
4B96:  SUBWF  x25,W
4B98:  BC    4BCA
4B9A:  MOVLW  04
4B9C:  SUBWF  x39,W
4B9E:  SUBWF  x25,W
4BA0:  BZ    4BCA
4BA2:  BNC   4BCA
....................                         new_game = 1;
4BA4:  MOVLB  2
4BA6:  BSF    x20.3
....................                         mode = 'i';
4BA8:  MOVLW  69
4BAA:  MOVWF  x0E
....................                         delay_ms(500);
4BAC:  MOVLW  02
4BAE:  MOVWF  x59
4BB0:  MOVLW  FA
4BB2:  MOVWF  x79
4BB4:  MOVLB  0
4BB6:  CALL   05EC
4BBA:  MOVLB  2
4BBC:  DECFSZ x59,F
4BBE:  BRA    4BB0
....................                         draw_win(0);
4BC0:  CLRF   x59
4BC2:  MOVLB  0
4BC4:  CALL   2B5E
4BC8:  MOVLB  1
....................                      }
....................                   }
....................                   break;
4BCA:  BRA    4BD0
4BCC:  MOVLB  0
4BCE:  MOVLB  1
....................                }
....................             }
....................             cooldown_2 = 15;
4BD0:  MOVLW  0F
4BD2:  MOVWF  x46
....................             shoot_2 = 0;
4BD4:  BCF    x43.1
....................             last_bullet_x_pos_2 = x_pos_2;
4BD6:  MOVFF  139,17E
....................             last_bullet_y_pos_2 = y_pos_2;
4BDA:  MOVFF  13A,17F
4BDE:  MOVLB  2
....................          }
.................... 
....................          
.................... 
....................          
....................          draw_cuadrito(last_x_pos_1, last_y_pos_1, 0);
4BE0:  MOVFF  123,259
4BE4:  MOVFF  124,25A
4BE8:  CLRF   x5B
4BEA:  MOVLB  0
4BEC:  CALL   2C5A
....................          draw_cuadrito(x_pos_1, y_pos_1, 1);
4BF0:  MOVFF  125,259
4BF4:  MOVFF  126,25A
4BF8:  MOVLW  01
4BFA:  MOVLB  2
4BFC:  MOVWF  x5B
4BFE:  MOVLB  0
4C00:  CALL   2C5A
.................... 
....................          last_x_pos_1 = x_pos_1;
4C04:  MOVFF  125,123
....................          last_y_pos_1 = y_pos_1;
4C08:  MOVFF  126,124
.................... 
....................          draw_cuadrito(last_x_pos_2, last_y_pos_2, 0);
4C0C:  MOVFF  137,259
4C10:  MOVFF  138,25A
4C14:  MOVLB  2
4C16:  CLRF   x5B
4C18:  MOVLB  0
4C1A:  CALL   2C5A
....................          draw_cuadrito(x_pos_2, y_pos_2, 1);
4C1E:  MOVFF  139,259
4C22:  MOVFF  13A,25A
4C26:  MOVLW  01
4C28:  MOVLB  2
4C2A:  MOVWF  x5B
4C2C:  MOVLB  0
4C2E:  CALL   2C5A
.................... 
....................          last_x_pos_2 = x_pos_2;
4C32:  MOVFF  139,137
....................          last_y_pos_2 = y_pos_2;
4C36:  MOVFF  13A,138
....................          delay_ms(35);
4C3A:  MOVLW  23
4C3C:  MOVLB  2
4C3E:  MOVWF  x79
4C40:  MOVLB  0
4C42:  CALL   05EC
.................... 
....................          if (win)
4C46:  MOVLB  2
4C48:  BTFSS  x20.0
4C4A:  BRA    4CF0
....................          {
....................             win = 0;
4C4C:  BCF    x20.0
....................             if (!who)
4C4E:  BTFSC  x20.1
4C50:  BRA    4CA2
....................             {
....................                glcd_fillScreen(0);
4C52:  CLRF   x78
4C54:  MOVLB  0
4C56:  CALL   0658
....................                inicio(1);
4C5A:  MOVLW  01
4C5C:  MOVLB  2
4C5E:  MOVWF  x59
4C60:  MOVLB  0
4C62:  CALL   0DDE
....................                char tewion[] = "GANA 1";
4C66:  MOVLW  47
4C68:  MOVLB  2
4C6A:  MOVWF  x4B
4C6C:  MOVLW  41
4C6E:  MOVWF  x4C
4C70:  MOVLW  4E
4C72:  MOVWF  x4D
4C74:  MOVLW  41
4C76:  MOVWF  x4E
4C78:  MOVLW  20
4C7A:  MOVWF  x4F
4C7C:  MOVLW  31
4C7E:  MOVWF  x50
4C80:  CLRF   x51
....................                glcd_text57(22, 50, tewion, 1, 1);
4C82:  MOVLW  16
4C84:  MOVWF  xDF
4C86:  MOVLW  32
4C88:  MOVWF  xE0
4C8A:  MOVLW  02
4C8C:  MOVWF  xE2
4C8E:  MOVLW  4B
4C90:  MOVWF  xE1
4C92:  MOVLW  01
4C94:  MOVWF  xE3
4C96:  MOVWF  xE4
4C98:  MOVLB  0
4C9A:  CALL   0B0C
....................             }
4C9E:  BRA    4CEE
4CA0:  MOVLB  2
....................             else
....................             {
....................                glcd_fillScreen(0);
4CA2:  CLRF   x78
4CA4:  MOVLB  0
4CA6:  CALL   0658
....................                inicio(1);
4CAA:  MOVLW  01
4CAC:  MOVLB  2
4CAE:  MOVWF  x59
4CB0:  MOVLB  0
4CB2:  CALL   0DDE
....................                char tewion[] = "GANA 2";
4CB6:  MOVLW  47
4CB8:  MOVLB  2
4CBA:  MOVWF  x52
4CBC:  MOVLW  41
4CBE:  MOVWF  x53
4CC0:  MOVLW  4E
4CC2:  MOVWF  x54
4CC4:  MOVLW  41
4CC6:  MOVWF  x55
4CC8:  MOVLW  20
4CCA:  MOVWF  x56
4CCC:  MOVLW  32
4CCE:  MOVWF  x57
4CD0:  CLRF   x58
....................                glcd_text57(22, 50, tewion, 1, 1);
4CD2:  MOVLW  16
4CD4:  MOVWF  xDF
4CD6:  MOVLW  32
4CD8:  MOVWF  xE0
4CDA:  MOVLW  02
4CDC:  MOVWF  xE2
4CDE:  MOVLW  52
4CE0:  MOVWF  xE1
4CE2:  MOVLW  01
4CE4:  MOVWF  xE3
4CE6:  MOVWF  xE4
4CE8:  MOVLB  0
4CEA:  CALL   0B0C
4CEE:  MOVLB  2
....................             }
....................          }
.................... 
....................          break;
4CF0:  BRA    4CF6
4CF2:  MOVLB  0
....................       }
....................       default:
....................       {
....................          break;
4CF4:  MOVLB  2
....................       }
....................       }
.................... 
....................       printf("p");
4CF6:  MOVLW  70
4CF8:  BTFSS  F9E.4
4CFA:  BRA    4CF8
4CFC:  MOVWF  FAD
4CFE:  GOTO   2FA2
....................    }
.................... }
.................... 
4D02:  SLEEP 
.................... void glcd_line(int x1, int y1, int x2, int y2, int1 color)
.................... {
....................    signed int x, y, addx, addy, dx, dy;
....................    signed long P;
....................    int i;
....................    dx = abs((signed int)(x2 - x1));
*
0902:  MOVLB  2
0904:  MOVF   xDF,W
0906:  SUBWF  xE1,W
0908:  MOVWF  xED
090A:  MOVF   xED,W
090C:  BTFSS  xED.7
090E:  BRA    0916
0910:  MOVLW  00
0912:  BSF    FD8.0
0914:  SUBFWB xED,W
0916:  MOVWF  xE8
....................    dy = abs((signed int)(y2 - y1));
0918:  MOVF   xE0,W
091A:  SUBWF  xE2,W
091C:  MOVWF  xED
091E:  MOVF   xED,W
0920:  BTFSS  xED.7
0922:  BRA    092A
0924:  MOVLW  00
0926:  BSF    FD8.0
0928:  SUBFWB xED,W
092A:  MOVWF  xE9
....................    x = x1;
092C:  MOVFF  2DF,2E4
....................    y = y1;
0930:  MOVFF  2E0,2E5
.................... 
....................    if (x1 > x2)
0934:  MOVF   xDF,W
0936:  SUBWF  xE1,W
0938:  BC    093E
....................       addx = -1;
093A:  SETF   xE6
093C:  BRA    0942
....................    else
....................       addx = 1;
093E:  MOVLW  01
0940:  MOVWF  xE6
....................    if (y1 > y2)
0942:  MOVF   xE0,W
0944:  SUBWF  xE2,W
0946:  BC    094C
....................       addy = -1;
0948:  SETF   xE7
094A:  BRA    0950
....................    else
....................       addy = 1;
094C:  MOVLW  01
094E:  MOVWF  xE7
.................... 
....................    if (dx >= dy)
0950:  MOVF   xE9,W
0952:  XORLW  80
0954:  MOVWF  00
0956:  MOVF   xE8,W
0958:  XORLW  80
095A:  SUBWF  00,W
095C:  BZ    0960
095E:  BC    0A00
....................    {
....................       P = 2 * dy - dx;
0960:  MOVLW  02
0962:  MOVWF  xEE
0964:  MOVFF  2E9,2EF
0968:  MOVLB  0
096A:  RCALL  0786
096C:  MOVLB  2
096E:  MOVF   xE8,W
0970:  SUBWF  01,W
0972:  CLRF   03
0974:  BTFSC  FE8.7
0976:  DECF   03,F
0978:  MOVWF  xEA
097A:  MOVFF  03,2EB
.................... 
....................       for (i = 0; i <= dx; ++i)
097E:  CLRF   xEC
0980:  BTFSC  xE8.7
0982:  BRA    09FE
0984:  MOVF   xEC,W
0986:  SUBWF  xE8,W
0988:  BNC   09FE
....................       {
....................          glcd_pixel(x, y, color);
098A:  MOVFF  2E4,2F1
098E:  MOVFF  2E5,2F2
0992:  MOVFF  2E3,2F3
0996:  MOVLB  0
0998:  RCALL  0816
.................... 
....................          if (P < 0)
099A:  MOVLB  2
099C:  BTFSS  xEB.7
099E:  BRA    09C2
....................          {
....................             P += 2 * dy;
09A0:  MOVLW  02
09A2:  MOVWF  xEE
09A4:  MOVFF  2E9,2EF
09A8:  MOVLB  0
09AA:  RCALL  0786
09AC:  MOVF   01,W
09AE:  CLRF   03
09B0:  BTFSC  FE8.7
09B2:  DECF   03,F
09B4:  MOVLB  2
09B6:  ADDWF  xEA,F
09B8:  MOVF   03,W
09BA:  ADDWFC xEB,F
....................             x += addx;
09BC:  MOVF   xE6,W
09BE:  ADDWF  xE4,F
....................          }
09C0:  BRA    09FA
....................          else
....................          {
....................             P += 2 * dy - 2 * dx;
09C2:  MOVLW  02
09C4:  MOVWF  xEE
09C6:  MOVFF  2E9,2EF
09CA:  MOVLB  0
09CC:  RCALL  0786
09CE:  MOVFF  01,2ED
09D2:  MOVLW  02
09D4:  MOVLB  2
09D6:  MOVWF  xEE
09D8:  MOVFF  2E8,2EF
09DC:  MOVLB  0
09DE:  RCALL  0786
09E0:  MOVF   01,W
09E2:  MOVLB  2
09E4:  SUBWF  xED,W
09E6:  CLRF   03
09E8:  BTFSC  FE8.7
09EA:  DECF   03,F
09EC:  ADDWF  xEA,F
09EE:  MOVF   03,W
09F0:  ADDWFC xEB,F
....................             x += addx;
09F2:  MOVF   xE6,W
09F4:  ADDWF  xE4,F
....................             y += addy;
09F6:  MOVF   xE7,W
09F8:  ADDWF  xE5,F
....................          }
09FA:  INCF   xEC,F
09FC:  BRA    0980
....................       }
....................    }
09FE:  BRA    0A9E
....................    else
....................    {
....................       P = 2 * dx - dy;
0A00:  MOVLW  02
0A02:  MOVWF  xEE
0A04:  MOVFF  2E8,2EF
0A08:  MOVLB  0
0A0A:  RCALL  0786
0A0C:  MOVLB  2
0A0E:  MOVF   xE9,W
0A10:  SUBWF  01,W
0A12:  CLRF   03
0A14:  BTFSC  FE8.7
0A16:  DECF   03,F
0A18:  MOVWF  xEA
0A1A:  MOVFF  03,2EB
.................... 
....................       for (i = 0; i <= dy; ++i)
0A1E:  CLRF   xEC
0A20:  BTFSC  xE9.7
0A22:  BRA    0A9E
0A24:  MOVF   xEC,W
0A26:  SUBWF  xE9,W
0A28:  BNC   0A9E
....................       {
....................          glcd_pixel(x, y, color);
0A2A:  MOVFF  2E4,2F1
0A2E:  MOVFF  2E5,2F2
0A32:  MOVFF  2E3,2F3
0A36:  MOVLB  0
0A38:  RCALL  0816
.................... 
....................          if (P < 0)
0A3A:  MOVLB  2
0A3C:  BTFSS  xEB.7
0A3E:  BRA    0A62
....................          {
....................             P += 2 * dx;
0A40:  MOVLW  02
0A42:  MOVWF  xEE
0A44:  MOVFF  2E8,2EF
0A48:  MOVLB  0
0A4A:  RCALL  0786
0A4C:  MOVF   01,W
0A4E:  CLRF   03
0A50:  BTFSC  FE8.7
0A52:  DECF   03,F
0A54:  MOVLB  2
0A56:  ADDWF  xEA,F
0A58:  MOVF   03,W
0A5A:  ADDWFC xEB,F
....................             y += addy;
0A5C:  MOVF   xE7,W
0A5E:  ADDWF  xE5,F
....................          }
0A60:  BRA    0A9A
....................          else
....................          {
....................             P += 2 * dx - 2 * dy;
0A62:  MOVLW  02
0A64:  MOVWF  xEE
0A66:  MOVFF  2E8,2EF
0A6A:  MOVLB  0
0A6C:  RCALL  0786
0A6E:  MOVFF  01,2ED
0A72:  MOVLW  02
0A74:  MOVLB  2
0A76:  MOVWF  xEE
0A78:  MOVFF  2E9,2EF
0A7C:  MOVLB  0
0A7E:  RCALL  0786
0A80:  MOVF   01,W
0A82:  MOVLB  2
0A84:  SUBWF  xED,W
0A86:  CLRF   03
0A88:  BTFSC  FE8.7
0A8A:  DECF   03,F
0A8C:  ADDWF  xEA,F
0A8E:  MOVF   03,W
0A90:  ADDWFC xEB,F
....................             x += addx;
0A92:  MOVF   xE6,W
0A94:  ADDWF  xE4,F
....................             y += addy;
0A96:  MOVF   xE7,W
0A98:  ADDWF  xE5,F
....................          }
0A9A:  INCF   xEC,F
0A9C:  BRA    0A20
....................       }
....................    }
0A9E:  MOVLB  0
0AA0:  RETURN 0
.................... }
.................... void glcd_lineTracing(int *xx, int *yy, int n_points, int1 color)
.................... {
....................    int i;
....................    for (i = 0; i < n_points - 1; i++)
....................    { // Iterate thru all points, drawing a line between each point
....................       glcd_line((xx + i), (yy + i), (xx + i + 1), (yy + i + 1), color);
....................    }
....................    glcd_line((xx + i), (yy + i), (xx), (yy), color);
.................... }
.................... void draw_triangle(int x, int y, float starting_angle, int1 color)
.................... {
....................    int x_points_on_glcd = (int)malloc(3 * sizeof(int));
....................    int y_points_on_glcd = (int)malloc(3 * sizeof(int));
.................... 
....................    for (char i = 0; i < 3; i++)
....................    {
....................       *(x_points_on_glcd + i) = x + (char)((float)5 * cos((float)i * internal_angle - starting_angle));
....................       *(y_points_on_glcd + i) = y + (char)((float)5 * sin((float)i * internal_angle - starting_angle));
....................    }
.................... 
....................    glcd_lineTracing(x_points_on_glcd, y_points_on_glcd, 3, color);
.................... 
....................    free(x_points_on_glcd);
....................    free(y_points_on_glcd);
.................... }
.................... void draw_asteroid(int x, int y, int life, int1 color)
*
25EC:  MOVLB  2
25EE:  MOVF   x5E,W
25F0:  MULLW  08
25F2:  MOVF   FF3,W
25F4:  ADDWF  x5C,W
25F6:  MOVWF  x60
25F8:  MOVF   x5E,W
25FA:  MULLW  08
25FC:  MOVF   FF3,W
25FE:  ADDWF  x5D,W
2600:  MOVWF  x61
.................... {
....................    int x2 = x + life * 8;
....................    int y2 = y + life * 8;
.................... 
....................    if (x2 > 127)
2602:  MOVF   x60,W
2604:  SUBLW  7F
2606:  BTFSC  FD8.0
2608:  BRA    27A2
....................    {
....................       glcd_line(x, y, 127, y, color);
260A:  MOVFF  25C,2DF
260E:  MOVFF  25D,2E0
2612:  MOVLW  7F
2614:  MOVWF  xE1
2616:  MOVFF  25D,2E2
261A:  MOVFF  25F,2E3
261E:  MOVLB  0
2620:  CALL   0902
....................       glcd_line(0, y, x2 - 127, y, color);
2624:  MOVLW  7F
2626:  MOVLB  2
2628:  SUBWF  x60,W
262A:  MOVWF  x62
262C:  CLRF   xDF
262E:  MOVFF  25D,2E0
2632:  MOVWF  xE1
2634:  MOVFF  25D,2E2
2638:  MOVFF  25F,2E3
263C:  MOVLB  0
263E:  CALL   0902
....................       if (y2 > 63)
2642:  MOVLB  2
2644:  MOVF   x61,W
2646:  SUBLW  3F
2648:  BC    2728
....................       {
....................          glcd_line(x, y2 - 63, 127, y2 - 63, color);
264A:  MOVLW  3F
264C:  SUBWF  x61,W
264E:  MOVWF  x62
2650:  MOVLW  3F
2652:  SUBWF  x61,W
2654:  MOVWF  x63
2656:  MOVFF  25C,2DF
265A:  MOVFF  262,2E0
265E:  MOVLW  7F
2660:  MOVWF  xE1
2662:  MOVFF  263,2E2
2666:  MOVFF  25F,2E3
266A:  MOVLB  0
266C:  CALL   0902
....................          glcd_line(0, y2 - 63, x2 - 127, y2 - 63, color);
2670:  MOVLW  3F
2672:  MOVLB  2
2674:  SUBWF  x61,W
2676:  MOVWF  x62
2678:  MOVLW  7F
267A:  SUBWF  x60,W
267C:  MOVWF  x63
267E:  MOVLW  3F
2680:  SUBWF  x61,W
2682:  MOVWF  x64
2684:  CLRF   xDF
2686:  MOVFF  262,2E0
268A:  MOVFF  263,2E1
268E:  MOVWF  xE2
2690:  MOVFF  25F,2E3
2694:  MOVLB  0
2696:  CALL   0902
.................... 
....................          glcd_line(x, y, x, 63, color);
269A:  MOVFF  25C,2DF
269E:  MOVFF  25D,2E0
26A2:  MOVFF  25C,2E1
26A6:  MOVLW  3F
26A8:  MOVLB  2
26AA:  MOVWF  xE2
26AC:  MOVFF  25F,2E3
26B0:  MOVLB  0
26B2:  CALL   0902
....................          glcd_line(x, 0, x, y2 - 63, color);
26B6:  MOVLW  3F
26B8:  MOVLB  2
26BA:  SUBWF  x61,W
26BC:  MOVWF  x62
26BE:  MOVFF  25C,2DF
26C2:  CLRF   xE0
26C4:  MOVFF  25C,2E1
26C8:  MOVWF  xE2
26CA:  MOVFF  25F,2E3
26CE:  MOVLB  0
26D0:  CALL   0902
.................... 
....................          glcd_line(x2 - 127, y, x2 - 127, 63, color);
26D4:  MOVLW  7F
26D6:  MOVLB  2
26D8:  SUBWF  x60,W
26DA:  MOVWF  x62
26DC:  MOVLW  7F
26DE:  SUBWF  x60,W
26E0:  MOVWF  x63
26E2:  MOVFF  262,2DF
26E6:  MOVFF  25D,2E0
26EA:  MOVWF  xE1
26EC:  MOVLW  3F
26EE:  MOVWF  xE2
26F0:  MOVFF  25F,2E3
26F4:  MOVLB  0
26F6:  CALL   0902
....................          glcd_line(x2 - 127, 0, x2 - 127, y2 - 63, color);
26FA:  MOVLW  7F
26FC:  MOVLB  2
26FE:  SUBWF  x60,W
2700:  MOVWF  x62
2702:  MOVLW  7F
2704:  SUBWF  x60,W
2706:  MOVWF  x63
2708:  MOVLW  3F
270A:  SUBWF  x61,W
270C:  MOVWF  x64
270E:  MOVFF  262,2DF
2712:  CLRF   xE0
2714:  MOVFF  263,2E1
2718:  MOVWF  xE2
271A:  MOVFF  25F,2E3
271E:  MOVLB  0
2720:  CALL   0902
....................       }
2724:  BRA    279E
2726:  MOVLB  2
....................       else
....................       {
....................          glcd_line(x, y2, 127, y2, color);
2728:  MOVFF  25C,2DF
272C:  MOVFF  261,2E0
2730:  MOVLW  7F
2732:  MOVWF  xE1
2734:  MOVFF  261,2E2
2738:  MOVFF  25F,2E3
273C:  MOVLB  0
273E:  CALL   0902
....................          glcd_line(0, y2, x2 - 127, y2, color);
2742:  MOVLW  7F
2744:  MOVLB  2
2746:  SUBWF  x60,W
2748:  MOVWF  x62
274A:  CLRF   xDF
274C:  MOVFF  261,2E0
2750:  MOVWF  xE1
2752:  MOVFF  261,2E2
2756:  MOVFF  25F,2E3
275A:  MOVLB  0
275C:  CALL   0902
.................... 
....................          glcd_line(x, y, x, y2, color);
2760:  MOVFF  25C,2DF
2764:  MOVFF  25D,2E0
2768:  MOVFF  25C,2E1
276C:  MOVFF  261,2E2
2770:  MOVFF  25F,2E3
2774:  CALL   0902
.................... 
....................          glcd_line(x2 - 127, y, x2 - 127, y2, color);
2778:  MOVLW  7F
277A:  MOVLB  2
277C:  SUBWF  x60,W
277E:  MOVWF  x62
2780:  MOVLW  7F
2782:  SUBWF  x60,W
2784:  MOVWF  x63
2786:  MOVFF  262,2DF
278A:  MOVFF  25D,2E0
278E:  MOVWF  xE1
2790:  MOVFF  261,2E2
2794:  MOVFF  25F,2E3
2798:  MOVLB  0
279A:  CALL   0902
....................       }
....................    }
279E:  BRA    28AA
27A0:  MOVLB  2
....................    else
....................    {
....................       glcd_line(x, y, x2, y, color);
27A2:  MOVFF  25C,2DF
27A6:  MOVFF  25D,2E0
27AA:  MOVFF  260,2E1
27AE:  MOVFF  25D,2E2
27B2:  MOVFF  25F,2E3
27B6:  MOVLB  0
27B8:  CALL   0902
....................       if (y2 > 63)
27BC:  MOVLB  2
27BE:  MOVF   x61,W
27C0:  SUBLW  3F
27C2:  BC    2860
....................       {
....................          glcd_line(x, y2 - 63, x2, y2 - 63, color);
27C4:  MOVLW  3F
27C6:  SUBWF  x61,W
27C8:  MOVWF  x62
27CA:  MOVLW  3F
27CC:  SUBWF  x61,W
27CE:  MOVWF  x63
27D0:  MOVFF  25C,2DF
27D4:  MOVFF  262,2E0
27D8:  MOVFF  260,2E1
27DC:  MOVWF  xE2
27DE:  MOVFF  25F,2E3
27E2:  MOVLB  0
27E4:  CALL   0902
.................... 
....................          glcd_line(x, y, x, 63, color);
27E8:  MOVFF  25C,2DF
27EC:  MOVFF  25D,2E0
27F0:  MOVFF  25C,2E1
27F4:  MOVLW  3F
27F6:  MOVLB  2
27F8:  MOVWF  xE2
27FA:  MOVFF  25F,2E3
27FE:  MOVLB  0
2800:  CALL   0902
....................          glcd_line(x, 0, x, y2 - 63, color);
2804:  MOVLW  3F
2806:  MOVLB  2
2808:  SUBWF  x61,W
280A:  MOVWF  x62
280C:  MOVFF  25C,2DF
2810:  CLRF   xE0
2812:  MOVFF  25C,2E1
2816:  MOVWF  xE2
2818:  MOVFF  25F,2E3
281C:  MOVLB  0
281E:  CALL   0902
.................... 
....................          glcd_line(x2, y, x2, 63, color);
2822:  MOVFF  260,2DF
2826:  MOVFF  25D,2E0
282A:  MOVFF  260,2E1
282E:  MOVLW  3F
2830:  MOVLB  2
2832:  MOVWF  xE2
2834:  MOVFF  25F,2E3
2838:  MOVLB  0
283A:  CALL   0902
....................          glcd_line(x2, 0, x2, y2 - 63, color);
283E:  MOVLW  3F
2840:  MOVLB  2
2842:  SUBWF  x61,W
2844:  MOVWF  x62
2846:  MOVFF  260,2DF
284A:  CLRF   xE0
284C:  MOVFF  260,2E1
2850:  MOVWF  xE2
2852:  MOVFF  25F,2E3
2856:  MOVLB  0
2858:  CALL   0902
....................       }
285C:  BRA    28AA
285E:  MOVLB  2
....................       else
....................       {
....................          glcd_line(x, y2, x2, y2, color);
2860:  MOVFF  25C,2DF
2864:  MOVFF  261,2E0
2868:  MOVFF  260,2E1
286C:  MOVFF  261,2E2
2870:  MOVFF  25F,2E3
2874:  MOVLB  0
2876:  CALL   0902
.................... 
....................          glcd_line(x, y, x, y2, color);
287A:  MOVFF  25C,2DF
287E:  MOVFF  25D,2E0
2882:  MOVFF  25C,2E1
2886:  MOVFF  261,2E2
288A:  MOVFF  25F,2E3
288E:  CALL   0902
.................... 
....................          glcd_line(x2, y, x2, y2, color);
2892:  MOVFF  260,2DF
2896:  MOVFF  25D,2E0
289A:  MOVFF  260,2E1
289E:  MOVFF  261,2E2
28A2:  MOVFF  25F,2E3
28A6:  CALL   0902
....................       }
....................    }
28AA:  RETURN 0
.................... }
.................... 
.................... void glcd_text57(int x, int y, char *textptr, int size, int1 color)
.................... {
.................... 
....................    int i, j, k, l, m; // Loop counters
....................    BYTE pixelData[5]; // Stores character data
.................... 
....................    for (i = 0; textptr[i] != '\0'; ++i, ++x) // Loop through the passed string
*
0B0C:  MOVLB  2
0B0E:  CLRF   xE5
0B10:  MOVF   xE5,W
0B12:  ADDWF  xE1,W
0B14:  MOVWF  FE9
0B16:  MOVLW  00
0B18:  ADDWFC xE2,W
0B1A:  MOVWF  FEA
0B1C:  MOVF   FEF,F
0B1E:  BTFSC  FD8.2
0B20:  BRA    0C78
....................    {
....................       if (textptr[i] < 'S') // Checks if the letter is in the first text array
0B22:  MOVF   xE5,W
0B24:  ADDWF  xE1,W
0B26:  MOVWF  FE9
0B28:  MOVLW  00
0B2A:  ADDWFC xE2,W
0B2C:  MOVWF  FEA
0B2E:  MOVF   FEF,W
0B30:  SUBLW  52
0B32:  BNC   0B78
....................          memcpy(pixelData, TEXT[textptr[i] - ' '], 5);
0B34:  MOVF   xE5,W
0B36:  ADDWF  xE1,W
0B38:  MOVWF  FE9
0B3A:  MOVLW  00
0B3C:  ADDWFC xE2,W
0B3E:  MOVWF  FEA
0B40:  MOVLW  20
0B42:  SUBWF  FEF,W
0B44:  MULLW  05
0B46:  MOVF   FF3,W
0B48:  CLRF   03
0B4A:  MOVWF  xEF
0B4C:  MOVLW  02
0B4E:  MOVWF  FEA
0B50:  MOVLW  EA
0B52:  MOVWF  FE9
0B54:  CLRF   xF3
0B56:  MOVFF  2EF,2F2
0B5A:  MOVLW  05
0B5C:  MOVWF  01
0B5E:  CLRF   FF7
0B60:  MOVF   xEF,W
0B62:  MOVLB  0
0B64:  CALL   00AE
0B68:  TBLRD*-
0B6A:  TBLRD*+
0B6C:  MOVFF  FF5,FEE
0B70:  DECFSZ 01,F
0B72:  BRA    0B6A
0B74:  BRA    0BDA
0B76:  MOVLB  2
....................       else if (textptr[i] <= '~') // Check if the letter is in the second array
0B78:  MOVF   xE5,W
0B7A:  ADDWF  xE1,W
0B7C:  MOVWF  FE9
0B7E:  MOVLW  00
0B80:  ADDWFC xE2,W
0B82:  MOVWF  FEA
0B84:  MOVF   FEF,W
0B86:  SUBLW  7E
0B88:  BNC   0BCE
....................          memcpy(pixelData, TEXT2[textptr[i] - 'S'], 5);
0B8A:  MOVF   xE5,W
0B8C:  ADDWF  xE1,W
0B8E:  MOVWF  FE9
0B90:  MOVLW  00
0B92:  ADDWFC xE2,W
0B94:  MOVWF  FEA
0B96:  MOVLW  53
0B98:  SUBWF  FEF,W
0B9A:  MULLW  05
0B9C:  MOVF   FF3,W
0B9E:  CLRF   03
0BA0:  MOVWF  xEF
0BA2:  MOVLW  02
0BA4:  MOVWF  FEA
0BA6:  MOVLW  EA
0BA8:  MOVWF  FE9
0BAA:  CLRF   xF3
0BAC:  MOVFF  2EF,2F2
0BB0:  MOVLW  05
0BB2:  MOVWF  01
0BB4:  CLRF   FF7
0BB6:  MOVF   xEF,W
0BB8:  MOVLB  0
0BBA:  CALL   01BE
0BBE:  TBLRD*-
0BC0:  TBLRD*+
0BC2:  MOVFF  FF5,FEE
0BC6:  DECFSZ 01,F
0BC8:  BRA    0BC0
0BCA:  BRA    0BDA
0BCC:  MOVLB  2
....................       else
....................          memcpy(pixelData, TEXT[0], 5); // Default to space
0BCE:  CLRF   xEA
0BD0:  CLRF   xEB
0BD2:  CLRF   xEC
0BD4:  CLRF   xED
0BD6:  CLRF   xEE
0BD8:  MOVLB  0
.................... 
....................       if (x + 5 * size >= GLCD_WIDTH) // Performs character wrapping
0BDA:  MOVLB  2
0BDC:  MOVF   xE3,W
0BDE:  MULLW  05
0BE0:  MOVF   FF3,W
0BE2:  ADDWF  xDF,W
0BE4:  SUBLW  7F
0BE6:  BC    0BF4
....................       {
....................          x = 0;             // Set x at far left position
0BE8:  CLRF   xDF
....................          y += 7 * size + 1; // Set y at next position down
0BEA:  MOVF   xE3,W
0BEC:  MULLW  07
0BEE:  MOVF   FF3,W
0BF0:  ADDLW  01
0BF2:  ADDWF  xE0,F
....................       }
....................       for (j = 0; j < 5; ++j, x += size) // Loop through character byte data
0BF4:  CLRF   xE6
0BF6:  MOVF   xE6,W
0BF8:  SUBLW  04
0BFA:  BNC   0C72
....................       {
....................          for (k = 0; k < 7 * size; ++k) // Loop through the vertical pixels
0BFC:  CLRF   xE7
0BFE:  MOVF   xE3,W
0C00:  MULLW  07
0C02:  MOVF   FF3,W
0C04:  SUBWF  xE7,W
0C06:  BC    0C6A
....................          {
....................             if (bit_test(pixelData[j], k)) // Check if the pixel should be set
0C08:  CLRF   03
0C0A:  MOVF   xE6,W
0C0C:  ADDLW  EA
0C0E:  MOVWF  FE9
0C10:  MOVLW  02
0C12:  ADDWFC 03,W
0C14:  MOVWF  FEA
0C16:  MOVFF  FEF,00
0C1A:  MOVF   xE7,W
0C1C:  MOVWF  01
0C1E:  BZ    0C28
0C20:  BCF    FD8.0
0C22:  RRCF   00,F
0C24:  DECFSZ 01,F
0C26:  BRA    0C20
0C28:  BTFSS  00.0
0C2A:  BRA    0C66
....................             {
....................                for (l = 0; l < size; ++l) // The next two loops change the
0C2C:  CLRF   xE8
0C2E:  MOVF   xE3,W
0C30:  SUBWF  xE8,W
0C32:  BC    0C66
....................                {                          // character's size
....................                   for (m = 0; m < size; ++m)
0C34:  CLRF   xE9
0C36:  MOVF   xE3,W
0C38:  SUBWF  xE9,W
0C3A:  BC    0C62
....................                   {
....................                      glcd_pixel(x + m, y + k * size + l, color); // Draws the pixel
0C3C:  MOVF   xE9,W
0C3E:  ADDWF  xDF,W
0C40:  MOVWF  xEF
0C42:  MOVF   xE7,W
0C44:  MULWF  xE3
0C46:  MOVF   FF3,W
0C48:  ADDWF  xE0,W
0C4A:  ADDWF  xE8,W
0C4C:  MOVWF  xF0
0C4E:  MOVFF  2EF,2F1
0C52:  MOVWF  xF2
0C54:  MOVFF  2E4,2F3
0C58:  MOVLB  0
0C5A:  RCALL  0816
0C5C:  MOVLB  2
0C5E:  INCF   xE9,F
0C60:  BRA    0C36
....................                   }
0C62:  INCF   xE8,F
0C64:  BRA    0C2E
....................                }
....................             }
0C66:  INCF   xE7,F
0C68:  BRA    0BFE
....................          }
0C6A:  INCF   xE6,F
0C6C:  MOVF   xE3,W
0C6E:  ADDWF  xDF,F
0C70:  BRA    0BF6
....................       }
0C72:  INCF   xE5,F
0C74:  INCF   xDF,F
0C76:  BRA    0B10
....................    }
0C78:  MOVLB  0
0C7A:  RETURN 0
.................... }
.................... 
.................... void inicio(int sec)
.................... {
....................    switch (sec)
*
0DDE:  MOVLB  2
0DE0:  MOVF   x59,W
0DE2:  XORLW  01
0DE4:  MOVLB  0
0DE6:  BZ    0DF0
0DE8:  XORLW  03
0DEA:  BTFSC  FD8.2
0DEC:  BRA    0FCC
0DEE:  BRA    11B4
....................    {
....................    case 1:
....................    {
....................       char text_asteroids[] = "ASTEROIDS";
0DF0:  MOVLW  41
0DF2:  MOVLB  2
0DF4:  MOVWF  x5A
0DF6:  MOVLW  53
0DF8:  MOVWF  x5B
0DFA:  MOVLW  54
0DFC:  MOVWF  x5C
0DFE:  MOVLW  45
0E00:  MOVWF  x5D
0E02:  MOVLW  52
0E04:  MOVWF  x5E
0E06:  MOVLW  4F
0E08:  MOVWF  x5F
0E0A:  MOVLW  49
0E0C:  MOVWF  x60
0E0E:  MOVLW  44
0E10:  MOVWF  x61
0E12:  MOVLW  53
0E14:  MOVWF  x62
0E16:  CLRF   x63
....................       glcd_text57(38, 4, text_asteroids, 1, 1);
0E18:  MOVLW  26
0E1A:  MOVWF  xDF
0E1C:  MOVLW  04
0E1E:  MOVWF  xE0
0E20:  MOVLW  02
0E22:  MOVWF  xE2
0E24:  MOVLW  5A
0E26:  MOVWF  xE1
0E28:  MOVLW  01
0E2A:  MOVWF  xE3
0E2C:  MOVWF  xE4
0E2E:  MOVLB  0
0E30:  RCALL  0B0C
....................       
....................       char text_aid[] = "SELECT & HOLD: [LJ]";
0E32:  MOVLW  53
0E34:  MOVLB  2
0E36:  MOVWF  x64
0E38:  MOVLW  45
0E3A:  MOVWF  x65
0E3C:  MOVLW  4C
0E3E:  MOVWF  x66
0E40:  MOVLW  45
0E42:  MOVWF  x67
0E44:  MOVLW  43
0E46:  MOVWF  x68
0E48:  MOVLW  54
0E4A:  MOVWF  x69
0E4C:  MOVLW  20
0E4E:  MOVWF  x6A
0E50:  MOVLW  26
0E52:  MOVWF  x6B
0E54:  MOVLW  20
0E56:  MOVWF  x6C
0E58:  MOVLW  48
0E5A:  MOVWF  x6D
0E5C:  MOVLW  4F
0E5E:  MOVWF  x6E
0E60:  MOVLW  4C
0E62:  MOVWF  x6F
0E64:  MOVLW  44
0E66:  MOVWF  x70
0E68:  MOVLW  3A
0E6A:  MOVWF  x71
0E6C:  MOVLW  20
0E6E:  MOVWF  x72
0E70:  MOVLW  5B
0E72:  MOVWF  x73
0E74:  MOVLW  4C
0E76:  MOVWF  x74
0E78:  MOVLW  4A
0E7A:  MOVWF  x75
0E7C:  MOVLW  5D
0E7E:  MOVWF  x76
0E80:  CLRF   x77
....................       glcd_text57(10, 49, text_aid, 1, 1);
0E82:  MOVLW  0A
0E84:  MOVWF  xDF
0E86:  MOVLW  31
0E88:  MOVWF  xE0
0E8A:  MOVLW  02
0E8C:  MOVWF  xE2
0E8E:  MOVLW  64
0E90:  MOVWF  xE1
0E92:  MOVLW  01
0E94:  MOVWF  xE3
0E96:  MOVWF  xE4
0E98:  MOVLB  0
0E9A:  RCALL  0B0C
....................       char text_aid2[] = "PRESS: [BR]";
0E9C:  MOVLW  50
0E9E:  MOVLB  2
0EA0:  MOVWF  x78
0EA2:  MOVLW  52
0EA4:  MOVWF  x79
0EA6:  MOVLW  45
0EA8:  MOVWF  x7A
0EAA:  MOVLW  53
0EAC:  MOVWF  x7B
0EAE:  MOVWF  x7C
0EB0:  MOVLW  3A
0EB2:  MOVWF  x7D
0EB4:  MOVLW  20
0EB6:  MOVWF  x7E
0EB8:  MOVLW  5B
0EBA:  MOVWF  x7F
0EBC:  MOVLW  42
0EBE:  MOVWF  x80
0EC0:  MOVLW  52
0EC2:  MOVWF  x81
0EC4:  MOVLW  5D
0EC6:  MOVWF  x82
0EC8:  CLRF   x83
....................       glcd_text57(40, 57, text_aid2, 1, 1);
0ECA:  MOVLW  28
0ECC:  MOVWF  xDF
0ECE:  MOVLW  39
0ED0:  MOVWF  xE0
0ED2:  MOVLW  02
0ED4:  MOVWF  xE2
0ED6:  MOVLW  78
0ED8:  MOVWF  xE1
0EDA:  MOVLW  01
0EDC:  MOVWF  xE3
0EDE:  MOVWF  xE4
0EE0:  MOVLB  0
0EE2:  RCALL  0B0C
.................... 
.................... 
....................       for (int i = 0; i < 16; i++)
0EE4:  MOVLB  2
0EE6:  CLRF   x84
0EE8:  MOVF   x84,W
0EEA:  SUBLW  0F
0EEC:  BNC   0FC8
....................       {
....................          for (int j = 0; j < 16; j++)
0EEE:  CLRF   x85
0EF0:  MOVF   x85,W
0EF2:  SUBLW  0F
0EF4:  BNC   0FC4
....................          {
....................             if (personaje[j][i] == 1)
0EF6:  MOVF   x85,W
0EF8:  MULLW  10
0EFA:  MOVF   FF3,W
0EFC:  CLRF   xE0
0EFE:  MOVWF  xDF
0F00:  CLRF   03
0F02:  MOVF   x84,W
0F04:  ADDWF  xDF,W
0F06:  MOVWF  01
0F08:  MOVF   xE0,W
0F0A:  ADDWFC 03,F
0F0C:  MOVF   01,W
0F0E:  ADDLW  1B
0F10:  MOVWF  FE9
0F12:  MOVLW  00
0F14:  ADDWFC 03,W
0F16:  MOVWF  FEA
0F18:  DECFSZ FEF,W
0F1A:  BRA    0F70
....................             {
....................                glcd_pixel(20 + i, 26 + j, 0);
0F1C:  MOVLW  14
0F1E:  ADDWF  x84,W
0F20:  MOVWF  xDF
0F22:  MOVLW  1A
0F24:  ADDWF  x85,W
0F26:  MOVWF  xE0
0F28:  MOVFF  2DF,2F1
0F2C:  MOVWF  xF2
0F2E:  CLRF   xF3
0F30:  MOVLB  0
0F32:  RCALL  0816
.................... 
....................                glcd_pixel(82 + i, 26 + j, 1);
0F34:  MOVLW  52
0F36:  MOVLB  2
0F38:  ADDWF  x84,W
0F3A:  MOVWF  xDF
0F3C:  MOVLW  1A
0F3E:  ADDWF  x85,W
0F40:  MOVWF  xE0
0F42:  MOVFF  2DF,2F1
0F46:  MOVWF  xF2
0F48:  MOVLW  01
0F4A:  MOVWF  xF3
0F4C:  MOVLB  0
0F4E:  RCALL  0816
....................                glcd_pixel(96 + i, 26 + j, 1);
0F50:  MOVLW  60
0F52:  MOVLB  2
0F54:  ADDWF  x84,W
0F56:  MOVWF  xDF
0F58:  MOVLW  1A
0F5A:  ADDWF  x85,W
0F5C:  MOVWF  xE0
0F5E:  MOVFF  2DF,2F1
0F62:  MOVWF  xF2
0F64:  MOVLW  01
0F66:  MOVWF  xF3
0F68:  MOVLB  0
0F6A:  RCALL  0816
....................             }
0F6C:  BRA    0FBE
0F6E:  MOVLB  2
....................             else
....................             {
....................                glcd_pixel(20 + i, 26 + j, 1);
0F70:  MOVLW  14
0F72:  ADDWF  x84,W
0F74:  MOVWF  xDF
0F76:  MOVLW  1A
0F78:  ADDWF  x85,W
0F7A:  MOVWF  xE0
0F7C:  MOVFF  2DF,2F1
0F80:  MOVWF  xF2
0F82:  MOVLW  01
0F84:  MOVWF  xF3
0F86:  MOVLB  0
0F88:  RCALL  0816
.................... 
....................                glcd_pixel(82 + i, 26 + j, 0);
0F8A:  MOVLW  52
0F8C:  MOVLB  2
0F8E:  ADDWF  x84,W
0F90:  MOVWF  xDF
0F92:  MOVLW  1A
0F94:  ADDWF  x85,W
0F96:  MOVWF  xE0
0F98:  MOVFF  2DF,2F1
0F9C:  MOVWF  xF2
0F9E:  CLRF   xF3
0FA0:  MOVLB  0
0FA2:  RCALL  0816
....................                glcd_pixel(96 + i, 26 + j, 0);
0FA4:  MOVLW  60
0FA6:  MOVLB  2
0FA8:  ADDWF  x84,W
0FAA:  MOVWF  xDF
0FAC:  MOVLW  1A
0FAE:  ADDWF  x85,W
0FB0:  MOVWF  xE0
0FB2:  MOVFF  2DF,2F1
0FB6:  MOVWF  xF2
0FB8:  CLRF   xF3
0FBA:  MOVLB  0
0FBC:  RCALL  0816
....................             }
0FBE:  MOVLB  2
0FC0:  INCF   x85,F
0FC2:  BRA    0EF0
....................          }
0FC4:  INCF   x84,F
0FC6:  BRA    0EE8
....................       }
....................       break;
0FC8:  BRA    13C2
0FCA:  MOVLB  0
....................    }
....................    case 2:
....................    {
....................       char text_asteroids[] = "ASTEROIDS";
0FCC:  MOVLW  41
0FCE:  MOVLB  2
0FD0:  MOVWF  x86
0FD2:  MOVLW  53
0FD4:  MOVWF  x87
0FD6:  MOVLW  54
0FD8:  MOVWF  x88
0FDA:  MOVLW  45
0FDC:  MOVWF  x89
0FDE:  MOVLW  52
0FE0:  MOVWF  x8A
0FE2:  MOVLW  4F
0FE4:  MOVWF  x8B
0FE6:  MOVLW  49
0FE8:  MOVWF  x8C
0FEA:  MOVLW  44
0FEC:  MOVWF  x8D
0FEE:  MOVLW  53
0FF0:  MOVWF  x8E
0FF2:  CLRF   x8F
....................       glcd_text57(38, 4, text_asteroids, 1, 1);
0FF4:  MOVLW  26
0FF6:  MOVWF  xDF
0FF8:  MOVLW  04
0FFA:  MOVWF  xE0
0FFC:  MOVLW  02
0FFE:  MOVWF  xE2
1000:  MOVLW  86
1002:  MOVWF  xE1
1004:  MOVLW  01
1006:  MOVWF  xE3
1008:  MOVWF  xE4
100A:  MOVLB  0
100C:  RCALL  0B0C
....................       char text_aid[] = "SELECT & HOLD: [LJ]";
100E:  MOVLW  53
1010:  MOVLB  2
1012:  MOVWF  x90
1014:  MOVLW  45
1016:  MOVWF  x91
1018:  MOVLW  4C
101A:  MOVWF  x92
101C:  MOVLW  45
101E:  MOVWF  x93
1020:  MOVLW  43
1022:  MOVWF  x94
1024:  MOVLW  54
1026:  MOVWF  x95
1028:  MOVLW  20
102A:  MOVWF  x96
102C:  MOVLW  26
102E:  MOVWF  x97
1030:  MOVLW  20
1032:  MOVWF  x98
1034:  MOVLW  48
1036:  MOVWF  x99
1038:  MOVLW  4F
103A:  MOVWF  x9A
103C:  MOVLW  4C
103E:  MOVWF  x9B
1040:  MOVLW  44
1042:  MOVWF  x9C
1044:  MOVLW  3A
1046:  MOVWF  x9D
1048:  MOVLW  20
104A:  MOVWF  x9E
104C:  MOVLW  5B
104E:  MOVWF  x9F
1050:  MOVLW  4C
1052:  MOVWF  xA0
1054:  MOVLW  4A
1056:  MOVWF  xA1
1058:  MOVLW  5D
105A:  MOVWF  xA2
105C:  CLRF   xA3
....................       glcd_text57(10, 49, text_aid, 1, 1);
105E:  MOVLW  0A
1060:  MOVWF  xDF
1062:  MOVLW  31
1064:  MOVWF  xE0
1066:  MOVLW  02
1068:  MOVWF  xE2
106A:  MOVLW  90
106C:  MOVWF  xE1
106E:  MOVLW  01
1070:  MOVWF  xE3
1072:  MOVWF  xE4
1074:  MOVLB  0
1076:  RCALL  0B0C
....................       char text_aid2[] = "PRESS: [BR]";
1078:  MOVLW  50
107A:  MOVLB  2
107C:  MOVWF  xA4
107E:  MOVLW  52
1080:  MOVWF  xA5
1082:  MOVLW  45
1084:  MOVWF  xA6
1086:  MOVLW  53
1088:  MOVWF  xA7
108A:  MOVWF  xA8
108C:  MOVLW  3A
108E:  MOVWF  xA9
1090:  MOVLW  20
1092:  MOVWF  xAA
1094:  MOVLW  5B
1096:  MOVWF  xAB
1098:  MOVLW  42
109A:  MOVWF  xAC
109C:  MOVLW  52
109E:  MOVWF  xAD
10A0:  MOVLW  5D
10A2:  MOVWF  xAE
10A4:  CLRF   xAF
....................       glcd_text57(40, 57, text_aid2, 1, 1);
10A6:  MOVLW  28
10A8:  MOVWF  xDF
10AA:  MOVLW  39
10AC:  MOVWF  xE0
10AE:  MOVLW  02
10B0:  MOVWF  xE2
10B2:  MOVLW  A4
10B4:  MOVWF  xE1
10B6:  MOVLW  01
10B8:  MOVWF  xE3
10BA:  MOVWF  xE4
10BC:  MOVLB  0
10BE:  RCALL  0B0C
.................... 
....................       for (int i = 0; i < 16; i++)
10C0:  MOVLB  2
10C2:  CLRF   xB0
10C4:  MOVF   xB0,W
10C6:  SUBLW  0F
10C8:  BNC   11B0
....................       {
....................          for (int j = 0; j < 16; j++)
10CA:  CLRF   xB1
10CC:  MOVF   xB1,W
10CE:  SUBLW  0F
10D0:  BNC   11AC
....................          {
....................             if (personaje[j][i] == 1)
10D2:  MOVF   xB1,W
10D4:  MULLW  10
10D6:  MOVF   FF3,W
10D8:  CLRF   xE0
10DA:  MOVWF  xDF
10DC:  CLRF   03
10DE:  MOVF   xB0,W
10E0:  ADDWF  xDF,W
10E2:  MOVWF  01
10E4:  MOVF   xE0,W
10E6:  ADDWFC 03,F
10E8:  MOVF   01,W
10EA:  ADDLW  1B
10EC:  MOVWF  FE9
10EE:  MOVLW  00
10F0:  ADDWFC 03,W
10F2:  MOVWF  FEA
10F4:  DECFSZ FEF,W
10F6:  BRA    1150
....................             {
....................                glcd_pixel(20 + i, 26 + j, 1);
10F8:  MOVLW  14
10FA:  ADDWF  xB0,W
10FC:  MOVWF  xDF
10FE:  MOVLW  1A
1100:  ADDWF  xB1,W
1102:  MOVWF  xE0
1104:  MOVFF  2DF,2F1
1108:  MOVWF  xF2
110A:  MOVLW  01
110C:  MOVWF  xF3
110E:  MOVLB  0
1110:  CALL   0816
.................... 
....................                glcd_pixel(82 + i, 26 + j, 0);
1114:  MOVLW  52
1116:  MOVLB  2
1118:  ADDWF  xB0,W
111A:  MOVWF  xDF
111C:  MOVLW  1A
111E:  ADDWF  xB1,W
1120:  MOVWF  xE0
1122:  MOVFF  2DF,2F1
1126:  MOVWF  xF2
1128:  CLRF   xF3
112A:  MOVLB  0
112C:  CALL   0816
....................                glcd_pixel(96 + i, 26 + j, 0);
1130:  MOVLW  60
1132:  MOVLB  2
1134:  ADDWF  xB0,W
1136:  MOVWF  xDF
1138:  MOVLW  1A
113A:  ADDWF  xB1,W
113C:  MOVWF  xE0
113E:  MOVFF  2DF,2F1
1142:  MOVWF  xF2
1144:  CLRF   xF3
1146:  MOVLB  0
1148:  CALL   0816
....................             }
114C:  BRA    11A6
114E:  MOVLB  2
....................             else
....................             {
....................                glcd_pixel(20 + i, 26 + j, 0);
1150:  MOVLW  14
1152:  ADDWF  xB0,W
1154:  MOVWF  xDF
1156:  MOVLW  1A
1158:  ADDWF  xB1,W
115A:  MOVWF  xE0
115C:  MOVFF  2DF,2F1
1160:  MOVWF  xF2
1162:  CLRF   xF3
1164:  MOVLB  0
1166:  CALL   0816
.................... 
....................                glcd_pixel(82 + i, 26 + j, 1);
116A:  MOVLW  52
116C:  MOVLB  2
116E:  ADDWF  xB0,W
1170:  MOVWF  xDF
1172:  MOVLW  1A
1174:  ADDWF  xB1,W
1176:  MOVWF  xE0
1178:  MOVFF  2DF,2F1
117C:  MOVWF  xF2
117E:  MOVLW  01
1180:  MOVWF  xF3
1182:  MOVLB  0
1184:  CALL   0816
....................                glcd_pixel(96 + i, 26 + j, 1);
1188:  MOVLW  60
118A:  MOVLB  2
118C:  ADDWF  xB0,W
118E:  MOVWF  xDF
1190:  MOVLW  1A
1192:  ADDWF  xB1,W
1194:  MOVWF  xE0
1196:  MOVFF  2DF,2F1
119A:  MOVWF  xF2
119C:  MOVLW  01
119E:  MOVWF  xF3
11A0:  MOVLB  0
11A2:  CALL   0816
....................             }
11A6:  MOVLB  2
11A8:  INCF   xB1,F
11AA:  BRA    10CC
....................          }
11AC:  INCF   xB0,F
11AE:  BRA    10C4
....................       }
....................       break;
11B0:  BRA    13C2
11B2:  MOVLB  0
....................    }
....................    default:
....................    {
....................       for (int i = 2; i < 13; i++)
11B4:  MOVLW  02
11B6:  MOVLB  2
11B8:  MOVWF  xB2
11BA:  MOVF   xB2,W
11BC:  SUBLW  0C
11BE:  BNC   11E0
....................       {
....................          glcd_line(32, i, 97, i, 1);
11C0:  MOVLW  20
11C2:  MOVWF  xDF
11C4:  MOVFF  2B2,2E0
11C8:  MOVLW  61
11CA:  MOVWF  xE1
11CC:  MOVFF  2B2,2E2
11D0:  MOVLW  01
11D2:  MOVWF  xE3
11D4:  MOVLB  0
11D6:  CALL   0902
11DA:  MOVLB  2
11DC:  INCF   xB2,F
11DE:  BRA    11BA
....................       }
....................       char text_asteroids[] = "ASTEROIDS";
11E0:  MOVLW  41
11E2:  MOVWF  xB3
11E4:  MOVLW  53
11E6:  MOVWF  xB4
11E8:  MOVLW  54
11EA:  MOVWF  xB5
11EC:  MOVLW  45
11EE:  MOVWF  xB6
11F0:  MOVLW  52
11F2:  MOVWF  xB7
11F4:  MOVLW  4F
11F6:  MOVWF  xB8
11F8:  MOVLW  49
11FA:  MOVWF  xB9
11FC:  MOVLW  44
11FE:  MOVWF  xBA
1200:  MOVLW  53
1202:  MOVWF  xBB
1204:  CLRF   xBC
....................       glcd_text57(38, 4, text_asteroids, 1, 0);
1206:  MOVLW  26
1208:  MOVWF  xDF
120A:  MOVLW  04
120C:  MOVWF  xE0
120E:  MOVLW  02
1210:  MOVWF  xE2
1212:  MOVLW  B3
1214:  MOVWF  xE1
1216:  MOVLW  01
1218:  MOVWF  xE3
121A:  CLRF   xE4
121C:  MOVLB  0
121E:  RCALL  0B0C
....................       char text_aid[] = "SELECT & HOLD: [LJ]";
1220:  MOVLW  53
1222:  MOVLB  2
1224:  MOVWF  xBD
1226:  MOVLW  45
1228:  MOVWF  xBE
122A:  MOVLW  4C
122C:  MOVWF  xBF
122E:  MOVLW  45
1230:  MOVWF  xC0
1232:  MOVLW  43
1234:  MOVWF  xC1
1236:  MOVLW  54
1238:  MOVWF  xC2
123A:  MOVLW  20
123C:  MOVWF  xC3
123E:  MOVLW  26
1240:  MOVWF  xC4
1242:  MOVLW  20
1244:  MOVWF  xC5
1246:  MOVLW  48
1248:  MOVWF  xC6
124A:  MOVLW  4F
124C:  MOVWF  xC7
124E:  MOVLW  4C
1250:  MOVWF  xC8
1252:  MOVLW  44
1254:  MOVWF  xC9
1256:  MOVLW  3A
1258:  MOVWF  xCA
125A:  MOVLW  20
125C:  MOVWF  xCB
125E:  MOVLW  5B
1260:  MOVWF  xCC
1262:  MOVLW  4C
1264:  MOVWF  xCD
1266:  MOVLW  4A
1268:  MOVWF  xCE
126A:  MOVLW  5D
126C:  MOVWF  xCF
126E:  CLRF   xD0
....................       glcd_text57(10, 49, text_aid, 1, 1);
1270:  MOVLW  0A
1272:  MOVWF  xDF
1274:  MOVLW  31
1276:  MOVWF  xE0
1278:  MOVLW  02
127A:  MOVWF  xE2
127C:  MOVLW  BD
127E:  MOVWF  xE1
1280:  MOVLW  01
1282:  MOVWF  xE3
1284:  MOVWF  xE4
1286:  MOVLB  0
1288:  RCALL  0B0C
....................       char text_aid2[] = "PRESS: [BR]";
128A:  MOVLW  50
128C:  MOVLB  2
128E:  MOVWF  xD1
1290:  MOVLW  52
1292:  MOVWF  xD2
1294:  MOVLW  45
1296:  MOVWF  xD3
1298:  MOVLW  53
129A:  MOVWF  xD4
129C:  MOVWF  xD5
129E:  MOVLW  3A
12A0:  MOVWF  xD6
12A2:  MOVLW  20
12A4:  MOVWF  xD7
12A6:  MOVLW  5B
12A8:  MOVWF  xD8
12AA:  MOVLW  42
12AC:  MOVWF  xD9
12AE:  MOVLW  52
12B0:  MOVWF  xDA
12B2:  MOVLW  5D
12B4:  MOVWF  xDB
12B6:  CLRF   xDC
....................       glcd_text57(40, 57, text_aid2, 1, 1);
12B8:  MOVLW  28
12BA:  MOVWF  xDF
12BC:  MOVLW  39
12BE:  MOVWF  xE0
12C0:  MOVLW  02
12C2:  MOVWF  xE2
12C4:  MOVLW  D1
12C6:  MOVWF  xE1
12C8:  MOVLW  01
12CA:  MOVWF  xE3
12CC:  MOVWF  xE4
12CE:  MOVLB  0
12D0:  RCALL  0B0C
.................... 
....................       for (int i = 0; i < 16; i++)
12D2:  MOVLB  2
12D4:  CLRF   xDD
12D6:  MOVF   xDD,W
12D8:  SUBLW  0F
12DA:  BNC   13C2
....................       {
....................          for (int j = 0; j < 16; j++)
12DC:  CLRF   xDE
12DE:  MOVF   xDE,W
12E0:  SUBLW  0F
12E2:  BNC   13BE
....................          {
....................             if (personaje[j][i] == 1)
12E4:  MOVF   xDE,W
12E6:  MULLW  10
12E8:  MOVF   FF3,W
12EA:  CLRF   xE0
12EC:  MOVWF  xDF
12EE:  CLRF   03
12F0:  MOVF   xDD,W
12F2:  ADDWF  xDF,W
12F4:  MOVWF  01
12F6:  MOVF   xE0,W
12F8:  ADDWFC 03,F
12FA:  MOVF   01,W
12FC:  ADDLW  1B
12FE:  MOVWF  FE9
1300:  MOVLW  00
1302:  ADDWFC 03,W
1304:  MOVWF  FEA
1306:  DECFSZ FEF,W
1308:  BRA    1366
....................             {
....................                glcd_pixel(20 + i, 26 + j, 1);
130A:  MOVLW  14
130C:  ADDWF  xDD,W
130E:  MOVWF  xDF
1310:  MOVLW  1A
1312:  ADDWF  xDE,W
1314:  MOVWF  xE0
1316:  MOVFF  2DF,2F1
131A:  MOVWF  xF2
131C:  MOVLW  01
131E:  MOVWF  xF3
1320:  MOVLB  0
1322:  CALL   0816
.................... 
....................                glcd_pixel(82 + i, 26 + j, 1);
1326:  MOVLW  52
1328:  MOVLB  2
132A:  ADDWF  xDD,W
132C:  MOVWF  xDF
132E:  MOVLW  1A
1330:  ADDWF  xDE,W
1332:  MOVWF  xE0
1334:  MOVFF  2DF,2F1
1338:  MOVWF  xF2
133A:  MOVLW  01
133C:  MOVWF  xF3
133E:  MOVLB  0
1340:  CALL   0816
....................                glcd_pixel(96 + i, 26 + j, 1);
1344:  MOVLW  60
1346:  MOVLB  2
1348:  ADDWF  xDD,W
134A:  MOVWF  xDF
134C:  MOVLW  1A
134E:  ADDWF  xDE,W
1350:  MOVWF  xE0
1352:  MOVFF  2DF,2F1
1356:  MOVWF  xF2
1358:  MOVLW  01
135A:  MOVWF  xF3
135C:  MOVLB  0
135E:  CALL   0816
....................             }
1362:  BRA    13B8
1364:  MOVLB  2
....................             else
....................             {
....................                glcd_pixel(20 + i, 26 + j, 0);
1366:  MOVLW  14
1368:  ADDWF  xDD,W
136A:  MOVWF  xDF
136C:  MOVLW  1A
136E:  ADDWF  xDE,W
1370:  MOVWF  xE0
1372:  MOVFF  2DF,2F1
1376:  MOVWF  xF2
1378:  CLRF   xF3
137A:  MOVLB  0
137C:  CALL   0816
.................... 
....................                glcd_pixel(82 + i, 26 + j, 0);
1380:  MOVLW  52
1382:  MOVLB  2
1384:  ADDWF  xDD,W
1386:  MOVWF  xDF
1388:  MOVLW  1A
138A:  ADDWF  xDE,W
138C:  MOVWF  xE0
138E:  MOVFF  2DF,2F1
1392:  MOVWF  xF2
1394:  CLRF   xF3
1396:  MOVLB  0
1398:  CALL   0816
....................                glcd_pixel(96 + i, 26 + j, 0);
139C:  MOVLW  60
139E:  MOVLB  2
13A0:  ADDWF  xDD,W
13A2:  MOVWF  xDF
13A4:  MOVLW  1A
13A6:  ADDWF  xDE,W
13A8:  MOVWF  xE0
13AA:  MOVFF  2DF,2F1
13AE:  MOVWF  xF2
13B0:  CLRF   xF3
13B2:  MOVLB  0
13B4:  CALL   0816
....................             }
13B8:  MOVLB  2
13BA:  INCF   xDE,F
13BC:  BRA    12DE
....................          }
13BE:  INCF   xDD,F
13C0:  BRA    12D6
....................       }
....................       break;
....................    }
....................    }
13C2:  MOVLB  0
13C4:  RETURN 0
.................... }
.................... 
.................... void single_menu(int1 play)
.................... {
....................    char text_ret[] = "RETURN";
13C6:  MOVLW  52
13C8:  MOVLB  2
13CA:  MOVWF  x5A
13CC:  MOVLW  45
13CE:  MOVWF  x5B
13D0:  MOVLW  54
13D2:  MOVWF  x5C
13D4:  MOVLW  55
13D6:  MOVWF  x5D
13D8:  MOVLW  52
13DA:  MOVWF  x5E
13DC:  MOVLW  4E
13DE:  MOVWF  x5F
13E0:  CLRF   x60
....................    char text_play[] = "PLAY";
13E2:  MOVLW  50
13E4:  MOVWF  x61
13E6:  MOVLW  4C
13E8:  MOVWF  x62
13EA:  MOVLW  41
13EC:  MOVWF  x63
13EE:  MOVLW  59
13F0:  MOVWF  x64
13F2:  CLRF   x65
....................    if (play)
13F4:  MOVF   x59,F
13F6:  BTFSC  FD8.2
13F8:  BRA    1540
....................    {
....................       for (int i = 29; i <= 41; i++)
13FA:  MOVLW  1D
13FC:  MOVWF  x66
13FE:  MOVF   x66,W
1400:  SUBLW  29
1402:  BNC   1424
....................       {
....................          glcd_line(20, i, 90, i, 1);
1404:  MOVLW  14
1406:  MOVWF  xDF
1408:  MOVFF  266,2E0
140C:  MOVLW  5A
140E:  MOVWF  xE1
1410:  MOVFF  266,2E2
1414:  MOVLW  01
1416:  MOVWF  xE3
1418:  MOVLB  0
141A:  CALL   0902
141E:  MOVLB  2
1420:  INCF   x66,F
1422:  BRA    13FE
....................       }
....................       glcd_text57(24, 30, text_play, 1, 0);
1424:  MOVLW  18
1426:  MOVWF  xDF
1428:  MOVLW  1E
142A:  MOVWF  xE0
142C:  MOVLW  02
142E:  MOVWF  xE2
1430:  MOVLW  61
1432:  MOVWF  xE1
1434:  MOVLW  01
1436:  MOVWF  xE3
1438:  CLRF   xE4
143A:  MOVLB  0
143C:  CALL   0B0C
.................... 
....................       for (int i = 43; i <= 55; i++)
1440:  MOVLW  2B
1442:  MOVLB  2
1444:  MOVWF  x67
1446:  MOVF   x67,W
1448:  SUBLW  37
144A:  BNC   146A
....................       {
....................          glcd_line(20, i, 90, i, 0);
144C:  MOVLW  14
144E:  MOVWF  xDF
1450:  MOVFF  267,2E0
1454:  MOVLW  5A
1456:  MOVWF  xE1
1458:  MOVFF  267,2E2
145C:  CLRF   xE3
145E:  MOVLB  0
1460:  CALL   0902
1464:  MOVLB  2
1466:  INCF   x67,F
1468:  BRA    1446
....................       }
....................       glcd_text57(24, 44, text_ret, 1, 1);
146A:  MOVLW  18
146C:  MOVWF  xDF
146E:  MOVLW  2C
1470:  MOVWF  xE0
1472:  MOVLW  02
1474:  MOVWF  xE2
1476:  MOVLW  5A
1478:  MOVWF  xE1
147A:  MOVLW  01
147C:  MOVWF  xE3
147E:  MOVWF  xE4
1480:  MOVLB  0
1482:  CALL   0B0C
.................... 
....................       char text_aid[] = "SELECT & HOLD: [LJ]";
1486:  MOVLW  53
1488:  MOVLB  2
148A:  MOVWF  x68
148C:  MOVLW  45
148E:  MOVWF  x69
1490:  MOVLW  4C
1492:  MOVWF  x6A
1494:  MOVLW  45
1496:  MOVWF  x6B
1498:  MOVLW  43
149A:  MOVWF  x6C
149C:  MOVLW  54
149E:  MOVWF  x6D
14A0:  MOVLW  20
14A2:  MOVWF  x6E
14A4:  MOVLW  26
14A6:  MOVWF  x6F
14A8:  MOVLW  20
14AA:  MOVWF  x70
14AC:  MOVLW  48
14AE:  MOVWF  x71
14B0:  MOVLW  4F
14B2:  MOVWF  x72
14B4:  MOVLW  4C
14B6:  MOVWF  x73
14B8:  MOVLW  44
14BA:  MOVWF  x74
14BC:  MOVLW  3A
14BE:  MOVWF  x75
14C0:  MOVLW  20
14C2:  MOVWF  x76
14C4:  MOVLW  5B
14C6:  MOVWF  x77
14C8:  MOVLW  4C
14CA:  MOVWF  x78
14CC:  MOVLW  4A
14CE:  MOVWF  x79
14D0:  MOVLW  5D
14D2:  MOVWF  x7A
14D4:  CLRF   x7B
....................       glcd_text57(10, 5, text_aid, 1, 1);
14D6:  MOVLW  0A
14D8:  MOVWF  xDF
14DA:  MOVLW  05
14DC:  MOVWF  xE0
14DE:  MOVLW  02
14E0:  MOVWF  xE2
14E2:  MOVLW  68
14E4:  MOVWF  xE1
14E6:  MOVLW  01
14E8:  MOVWF  xE3
14EA:  MOVWF  xE4
14EC:  MOVLB  0
14EE:  CALL   0B0C
....................       char text_aid2[] = "PRESS: [BL]";
14F2:  MOVLW  50
14F4:  MOVLB  2
14F6:  MOVWF  x7C
14F8:  MOVLW  52
14FA:  MOVWF  x7D
14FC:  MOVLW  45
14FE:  MOVWF  x7E
1500:  MOVLW  53
1502:  MOVWF  x7F
1504:  MOVWF  x80
1506:  MOVLW  3A
1508:  MOVWF  x81
150A:  MOVLW  20
150C:  MOVWF  x82
150E:  MOVLW  5B
1510:  MOVWF  x83
1512:  MOVLW  42
1514:  MOVWF  x84
1516:  MOVLW  4C
1518:  MOVWF  x85
151A:  MOVLW  5D
151C:  MOVWF  x86
151E:  CLRF   x87
....................       glcd_text57(10, 13, text_aid2, 1, 1);
1520:  MOVLW  0A
1522:  MOVWF  xDF
1524:  MOVLW  0D
1526:  MOVWF  xE0
1528:  MOVLW  02
152A:  MOVWF  xE2
152C:  MOVLW  7C
152E:  MOVWF  xE1
1530:  MOVLW  01
1532:  MOVWF  xE3
1534:  MOVWF  xE4
1536:  MOVLB  0
1538:  CALL   0B0C
....................    }
153C:  BRA    1682
153E:  MOVLB  2
....................    else
....................    {
....................       for (int i = 29; i <= 41; i++)
1540:  MOVLW  1D
1542:  MOVWF  x88
1544:  MOVF   x88,W
1546:  SUBLW  29
1548:  BNC   1568
....................       {
....................          glcd_line(20, i, 90, i, 0);
154A:  MOVLW  14
154C:  MOVWF  xDF
154E:  MOVFF  288,2E0
1552:  MOVLW  5A
1554:  MOVWF  xE1
1556:  MOVFF  288,2E2
155A:  CLRF   xE3
155C:  MOVLB  0
155E:  CALL   0902
1562:  MOVLB  2
1564:  INCF   x88,F
1566:  BRA    1544
....................       }
....................       glcd_text57(24, 30, text_play, 1, 1);
1568:  MOVLW  18
156A:  MOVWF  xDF
156C:  MOVLW  1E
156E:  MOVWF  xE0
1570:  MOVLW  02
1572:  MOVWF  xE2
1574:  MOVLW  61
1576:  MOVWF  xE1
1578:  MOVLW  01
157A:  MOVWF  xE3
157C:  MOVWF  xE4
157E:  MOVLB  0
1580:  CALL   0B0C
.................... 
....................       for (int i = 43; i <= 55; i++)
1584:  MOVLW  2B
1586:  MOVLB  2
1588:  MOVWF  x89
158A:  MOVF   x89,W
158C:  SUBLW  37
158E:  BNC   15B0
....................       {
....................          glcd_line(20, i, 90, i, 1);
1590:  MOVLW  14
1592:  MOVWF  xDF
1594:  MOVFF  289,2E0
1598:  MOVLW  5A
159A:  MOVWF  xE1
159C:  MOVFF  289,2E2
15A0:  MOVLW  01
15A2:  MOVWF  xE3
15A4:  MOVLB  0
15A6:  CALL   0902
15AA:  MOVLB  2
15AC:  INCF   x89,F
15AE:  BRA    158A
....................       }
....................       glcd_text57(24, 44, text_ret, 1, 0);
15B0:  MOVLW  18
15B2:  MOVWF  xDF
15B4:  MOVLW  2C
15B6:  MOVWF  xE0
15B8:  MOVLW  02
15BA:  MOVWF  xE2
15BC:  MOVLW  5A
15BE:  MOVWF  xE1
15C0:  MOVLW  01
15C2:  MOVWF  xE3
15C4:  CLRF   xE4
15C6:  MOVLB  0
15C8:  CALL   0B0C
.................... 
....................       char text_aid[] = "SELECT & HOLD: [LJ]";
15CC:  MOVLW  53
15CE:  MOVLB  2
15D0:  MOVWF  x8A
15D2:  MOVLW  45
15D4:  MOVWF  x8B
15D6:  MOVLW  4C
15D8:  MOVWF  x8C
15DA:  MOVLW  45
15DC:  MOVWF  x8D
15DE:  MOVLW  43
15E0:  MOVWF  x8E
15E2:  MOVLW  54
15E4:  MOVWF  x8F
15E6:  MOVLW  20
15E8:  MOVWF  x90
15EA:  MOVLW  26
15EC:  MOVWF  x91
15EE:  MOVLW  20
15F0:  MOVWF  x92
15F2:  MOVLW  48
15F4:  MOVWF  x93
15F6:  MOVLW  4F
15F8:  MOVWF  x94
15FA:  MOVLW  4C
15FC:  MOVWF  x95
15FE:  MOVLW  44
1600:  MOVWF  x96
1602:  MOVLW  3A
1604:  MOVWF  x97
1606:  MOVLW  20
1608:  MOVWF  x98
160A:  MOVLW  5B
160C:  MOVWF  x99
160E:  MOVLW  4C
1610:  MOVWF  x9A
1612:  MOVLW  4A
1614:  MOVWF  x9B
1616:  MOVLW  5D
1618:  MOVWF  x9C
161A:  CLRF   x9D
....................       glcd_text57(10, 5, text_aid, 1, 1);
161C:  MOVLW  0A
161E:  MOVWF  xDF
1620:  MOVLW  05
1622:  MOVWF  xE0
1624:  MOVLW  02
1626:  MOVWF  xE2
1628:  MOVLW  8A
162A:  MOVWF  xE1
162C:  MOVLW  01
162E:  MOVWF  xE3
1630:  MOVWF  xE4
1632:  MOVLB  0
1634:  CALL   0B0C
....................       char text_aid2[] = "PRESS: [BL]";
1638:  MOVLW  50
163A:  MOVLB  2
163C:  MOVWF  x9E
163E:  MOVLW  52
1640:  MOVWF  x9F
1642:  MOVLW  45
1644:  MOVWF  xA0
1646:  MOVLW  53
1648:  MOVWF  xA1
164A:  MOVWF  xA2
164C:  MOVLW  3A
164E:  MOVWF  xA3
1650:  MOVLW  20
1652:  MOVWF  xA4
1654:  MOVLW  5B
1656:  MOVWF  xA5
1658:  MOVLW  42
165A:  MOVWF  xA6
165C:  MOVLW  4C
165E:  MOVWF  xA7
1660:  MOVLW  5D
1662:  MOVWF  xA8
1664:  CLRF   xA9
....................       glcd_text57(10, 13, text_aid2, 1, 1);
1666:  MOVLW  0A
1668:  MOVWF  xDF
166A:  MOVLW  0D
166C:  MOVWF  xE0
166E:  MOVLW  02
1670:  MOVWF  xE2
1672:  MOVLW  9E
1674:  MOVWF  xE1
1676:  MOVLW  01
1678:  MOVWF  xE3
167A:  MOVWF  xE4
167C:  MOVLB  0
167E:  CALL   0B0C
....................    }
1682:  RETURN 0
.................... }
.................... 
.................... void scores(unsigned int16 scr, unsigned int lvl, int1 color)
.................... {
....................    char text_score[6];
....................    sprintf(text_score, "S:%lu", scr);
*
2A16:  MOVLW  02
2A18:  MOVLB  2
2A1A:  MOVWF  x1B
2A1C:  MOVLW  5D
2A1E:  MOVWF  x1A
2A20:  MOVLW  53
2A22:  MOVWF  x70
2A24:  MOVLB  0
2A26:  RCALL  28AC
2A28:  MOVLW  3A
2A2A:  MOVLB  2
2A2C:  MOVWF  x70
2A2E:  MOVLB  0
2A30:  RCALL  28AC
2A32:  MOVLW  10
2A34:  MOVWF  FE9
2A36:  MOVFF  25A,268
2A3A:  MOVFF  259,267
2A3E:  BRA    28CC
....................    glcd_text57(0, 0, text_score, 1, color);
2A40:  MOVLB  2
2A42:  CLRF   xDF
2A44:  CLRF   xE0
2A46:  MOVLW  02
2A48:  MOVWF  xE2
2A4A:  MOVLW  5D
2A4C:  MOVWF  xE1
2A4E:  MOVLW  01
2A50:  MOVWF  xE3
2A52:  MOVFF  25C,2E4
2A56:  MOVLB  0
2A58:  CALL   0B0C
....................    char text_level[4];
....................    sprintf(text_level, "L:%u", lvl);
2A5C:  MOVLW  02
2A5E:  MOVLB  2
2A60:  MOVWF  x1B
2A62:  MOVLW  63
2A64:  MOVWF  x1A
2A66:  MOVLW  4C
2A68:  MOVWF  x70
2A6A:  MOVLB  0
2A6C:  RCALL  28AC
2A6E:  MOVLW  3A
2A70:  MOVLB  2
2A72:  MOVWF  x70
2A74:  MOVLB  0
2A76:  RCALL  28AC
2A78:  MOVFF  25B,267
2A7C:  MOVLW  1B
2A7E:  MOVLB  2
2A80:  MOVWF  x68
2A82:  MOVLB  0
2A84:  BRA    2994
....................    glcd_text57(103, 0, text_level, 1, color);
2A86:  MOVLW  67
2A88:  MOVLB  2
2A8A:  MOVWF  xDF
2A8C:  CLRF   xE0
2A8E:  MOVLW  02
2A90:  MOVWF  xE2
2A92:  MOVLW  63
2A94:  MOVWF  xE1
2A96:  MOVLW  01
2A98:  MOVWF  xE3
2A9A:  MOVFF  25C,2E4
2A9E:  MOVLB  0
2AA0:  CALL   0B0C
2AA4:  RETURN 0
.................... }
.................... 
.................... float get_ship_angle(int x, int y)
.................... {
....................    if(x > 185){ // derecha
*
1E8A:  MOVLB  2
1E8C:  MOVF   x59,W
1E8E:  SUBLW  B9
1E90:  BC    1EBA
....................    return 270.0f;
1E92:  MOVLW  87
1E94:  MOVWF  00
1E96:  MOVLW  07
1E98:  MOVWF  01
1E9A:  CLRF   02
1E9C:  CLRF   03
1E9E:  BRA    1F4C
....................    return 90.0f;
1EA0:  MOVLW  85
1EA2:  MOVWF  00
1EA4:  MOVLW  34
1EA6:  MOVWF  01
1EA8:  CLRF   02
1EAA:  CLRF   03
1EAC:  BRA    1F4C
....................       return 0.0f;
1EAE:  CLRF   00
1EB0:  CLRF   01
1EB2:  CLRF   02
1EB4:  CLRF   03
1EB6:  BRA    1F4C
....................    }
1EB8:  BRA    1EEA
....................    else if(x < 70){// izquierda
1EBA:  MOVF   x59,W
1EBC:  SUBLW  45
1EBE:  BNC   1EEA
....................    return 90.0f;
1EC0:  MOVLW  85
1EC2:  MOVWF  00
1EC4:  MOVLW  34
1EC6:  MOVWF  01
1EC8:  CLRF   02
1ECA:  CLRF   03
1ECC:  BRA    1F4C
....................    return 270.0f;
1ECE:  MOVLW  87
1ED0:  MOVWF  00
1ED2:  MOVLW  07
1ED4:  MOVWF  01
1ED6:  CLRF   02
1ED8:  CLRF   03
1EDA:  BRA    1F4C
....................       return 180.0f;
1EDC:  MOVLW  86
1EDE:  MOVWF  00
1EE0:  MOVLW  34
1EE2:  MOVWF  01
1EE4:  CLRF   02
1EE6:  CLRF   03
1EE8:  BRA    1F4C
....................    }
....................    if(y > 185){ // arriba
1EEA:  MOVF   x5A,W
1EEC:  SUBLW  B9
1EEE:  BC    1F18
....................    return 0.0f;
1EF0:  CLRF   00
1EF2:  CLRF   01
1EF4:  CLRF   02
1EF6:  CLRF   03
1EF8:  BRA    1F4C
....................       return 180.0f;
1EFA:  MOVLW  86
1EFC:  MOVWF  00
1EFE:  MOVLW  34
1F00:  MOVWF  01
1F02:  CLRF   02
1F04:  CLRF   03
1F06:  BRA    1F4C
....................       return 90.0f;
1F08:  MOVLW  85
1F0A:  MOVWF  00
1F0C:  MOVLW  34
1F0E:  MOVWF  01
1F10:  CLRF   02
1F12:  CLRF   03
1F14:  BRA    1F4C
....................    }
1F16:  BRA    1F44
....................    else if(y < 70){ // abajo
1F18:  MOVF   x5A,W
1F1A:  SUBLW  45
1F1C:  BNC   1F44
....................    return 180.0f;
1F1E:  MOVLW  86
1F20:  MOVWF  00
1F22:  MOVLW  34
1F24:  MOVWF  01
1F26:  CLRF   02
1F28:  CLRF   03
1F2A:  BRA    1F4C
....................       return 0.0f;
1F2C:  CLRF   00
1F2E:  CLRF   01
1F30:  CLRF   02
1F32:  CLRF   03
1F34:  BRA    1F4C
....................       return 270.0f;
1F36:  MOVLW  87
1F38:  MOVWF  00
1F3A:  MOVLW  07
1F3C:  MOVWF  01
1F3E:  CLRF   02
1F40:  CLRF   03
1F42:  BRA    1F4C
....................    }
....................    return 0.0f;
1F44:  CLRF   00
1F46:  CLRF   01
1F48:  CLRF   02
1F4A:  CLRF   03
1F4C:  MOVLB  0
1F4E:  GOTO   3328 (RETURN)
.................... }
.................... float get_x_vel()
.................... {
....................    return (float)((float)p1_pot_x - 127.0f) / 30.0f;
*
2048:  MOVLB  2
204A:  CLRF   x90
204C:  MOVFF  212,28F
2050:  MOVLB  0
2052:  RCALL  1A16
2054:  MOVFF  03,25C
2058:  MOVFF  02,25B
205C:  MOVFF  01,25A
2060:  MOVFF  00,259
2064:  BSF    FD8.1
2066:  MOVFF  03,292
206A:  MOVFF  02,291
206E:  MOVFF  01,290
2072:  MOVFF  00,28F
2076:  MOVLB  2
2078:  CLRF   x96
207A:  CLRF   x95
207C:  MOVLW  7E
207E:  MOVWF  x94
2080:  MOVLW  85
2082:  MOVWF  x93
2084:  MOVLB  0
2086:  RCALL  1C12
2088:  MOVFF  03,25C
208C:  MOVFF  02,25B
2090:  MOVFF  01,25A
2094:  MOVFF  00,259
2098:  MOVFF  03,264
209C:  MOVFF  02,263
20A0:  MOVFF  01,262
20A4:  MOVFF  00,261
20A8:  MOVLB  2
20AA:  CLRF   x68
20AC:  CLRF   x67
20AE:  MOVLW  70
20B0:  MOVWF  x66
20B2:  MOVLW  83
20B4:  MOVWF  x65
20B6:  MOVLB  0
20B8:  RCALL  1A4C
20BA:  GOTO   33A8 (RETURN)
.................... }
.................... float get_y_vel()
.................... {
....................    return (float)((float)p1_pot_y - 127.0f) / 30.0f;
20BE:  MOVLB  2
20C0:  CLRF   x90
20C2:  MOVFF  213,28F
20C6:  MOVLB  0
20C8:  RCALL  1A16
20CA:  MOVFF  03,25C
20CE:  MOVFF  02,25B
20D2:  MOVFF  01,25A
20D6:  MOVFF  00,259
20DA:  BSF    FD8.1
20DC:  MOVFF  03,292
20E0:  MOVFF  02,291
20E4:  MOVFF  01,290
20E8:  MOVFF  00,28F
20EC:  MOVLB  2
20EE:  CLRF   x96
20F0:  CLRF   x95
20F2:  MOVLW  7E
20F4:  MOVWF  x94
20F6:  MOVLW  85
20F8:  MOVWF  x93
20FA:  MOVLB  0
20FC:  RCALL  1C12
20FE:  MOVFF  03,25C
2102:  MOVFF  02,25B
2106:  MOVFF  01,25A
210A:  MOVFF  00,259
210E:  MOVFF  03,264
2112:  MOVFF  02,263
2116:  MOVFF  01,262
211A:  MOVFF  00,261
211E:  MOVLB  2
2120:  CLRF   x68
2122:  CLRF   x67
2124:  MOVLW  70
2126:  MOVWF  x66
2128:  MOVLW  83
212A:  MOVWF  x65
212C:  MOVLB  0
212E:  RCALL  1A4C
2130:  GOTO   33BC (RETURN)
.................... }
.................... 
.................... 
.................... int laser_waza(int x, int y){
....................    if(x > 185){ // derecha
*
2B20:  MOVLB  2
2B22:  MOVF   x59,W
2B24:  SUBLW  B9
2B26:  BC    2B30
....................       return 2;
2B28:  MOVLW  02
2B2A:  MOVWF  01
2B2C:  BRA    2B5A
....................    }
2B2E:  BRA    2B3C
....................    else if(x < 70){// izquierda
2B30:  MOVF   x59,W
2B32:  SUBLW  45
2B34:  BNC   2B3C
....................       return 4;
2B36:  MOVLW  04
2B38:  MOVWF  01
2B3A:  BRA    2B5A
....................    }
....................    if(y > 185){ // arriba
2B3C:  MOVF   x5A,W
2B3E:  SUBLW  B9
2B40:  BC    2B4A
....................       return 1;
2B42:  MOVLW  01
2B44:  MOVWF  01
2B46:  BRA    2B5A
....................    }
2B48:  BRA    2B56
....................    else if(y < 70){ // abajo
2B4A:  MOVF   x5A,W
2B4C:  SUBLW  45
2B4E:  BNC   2B56
....................       return 3;
2B50:  MOVLW  03
2B52:  MOVWF  01
2B54:  BRA    2B5A
....................    }
....................    return 0;
2B56:  MOVLW  00
2B58:  MOVWF  01
2B5A:  MOVLB  0
2B5C:  RETURN 0
.................... }
.................... 
.................... void draw_cuadrito(int x, int y, int1 col)
.................... {
....................    glcd_line(x - 2, y + 2, x + 2, y + 2, col);
*
2C5A:  MOVLW  02
2C5C:  MOVLB  2
2C5E:  SUBWF  x59,W
2C60:  MOVWF  x5C
2C62:  MOVLW  02
2C64:  ADDWF  x5A,W
2C66:  MOVWF  x5D
2C68:  MOVLW  02
2C6A:  ADDWF  x59,W
2C6C:  MOVWF  x5E
2C6E:  MOVLW  02
2C70:  ADDWF  x5A,W
2C72:  MOVWF  x5F
2C74:  MOVFF  25C,2DF
2C78:  MOVFF  25D,2E0
2C7C:  MOVFF  25E,2E1
2C80:  MOVWF  xE2
2C82:  MOVFF  25B,2E3
2C86:  MOVLB  0
2C88:  CALL   0902
....................    glcd_line(x - 2, y - 2, x + 2, y - 2, col);
2C8C:  MOVLW  02
2C8E:  MOVLB  2
2C90:  SUBWF  x59,W
2C92:  MOVWF  x5C
2C94:  MOVLW  02
2C96:  SUBWF  x5A,W
2C98:  MOVWF  x5D
2C9A:  MOVLW  02
2C9C:  ADDWF  x59,W
2C9E:  MOVWF  x5E
2CA0:  MOVLW  02
2CA2:  SUBWF  x5A,W
2CA4:  MOVWF  x5F
2CA6:  MOVFF  25C,2DF
2CAA:  MOVFF  25D,2E0
2CAE:  MOVFF  25E,2E1
2CB2:  MOVWF  xE2
2CB4:  MOVFF  25B,2E3
2CB8:  MOVLB  0
2CBA:  CALL   0902
....................    glcd_line(x - 2, y + 2, x - 2, y - 2, col);
2CBE:  MOVLW  02
2CC0:  MOVLB  2
2CC2:  SUBWF  x59,W
2CC4:  MOVWF  x5C
2CC6:  MOVLW  02
2CC8:  ADDWF  x5A,W
2CCA:  MOVWF  x5D
2CCC:  MOVLW  02
2CCE:  SUBWF  x59,W
2CD0:  MOVWF  x5E
2CD2:  MOVLW  02
2CD4:  SUBWF  x5A,W
2CD6:  MOVWF  x5F
2CD8:  MOVFF  25C,2DF
2CDC:  MOVFF  25D,2E0
2CE0:  MOVFF  25E,2E1
2CE4:  MOVWF  xE2
2CE6:  MOVFF  25B,2E3
2CEA:  MOVLB  0
2CEC:  CALL   0902
....................    glcd_line(x + 2, y + 2, x + 2, y - 2, col);
2CF0:  MOVLW  02
2CF2:  MOVLB  2
2CF4:  ADDWF  x59,W
2CF6:  MOVWF  x5C
2CF8:  MOVLW  02
2CFA:  ADDWF  x5A,W
2CFC:  MOVWF  x5D
2CFE:  MOVLW  02
2D00:  ADDWF  x59,W
2D02:  MOVWF  x5E
2D04:  MOVLW  02
2D06:  SUBWF  x5A,W
2D08:  MOVWF  x5F
2D0A:  MOVFF  25C,2DF
2D0E:  MOVFF  25D,2E0
2D12:  MOVFF  25E,2E1
2D16:  MOVWF  xE2
2D18:  MOVFF  25B,2E3
2D1C:  MOVLB  0
2D1E:  CALL   0902
2D22:  RETURN 0
....................    
.................... /*   glcd_line(x - 4, y + 4, x + 4, y + 4, col);
....................    glcd_line(x - 4, y - 4, x + 4, y - 4, col);
....................    glcd_line(x - 4, y + 4, x - 4, y - 4, col);
....................    glcd_line(x + 4, y + 4, x + 4, y - 4, col);*/
.................... }
.................... 
.................... void rect(int x1, int y1, int x2, int y2){
....................    glcd_line(x1, y1, x2, y1, 1);
*
0AA2:  MOVFF  276,2DF
0AA6:  MOVFF  277,2E0
0AAA:  MOVFF  278,2E1
0AAE:  MOVFF  277,2E2
0AB2:  MOVLW  01
0AB4:  MOVLB  2
0AB6:  MOVWF  xE3
0AB8:  MOVLB  0
0ABA:  RCALL  0902
....................    glcd_line(x1, y1, x1, y2, 1);
0ABC:  MOVFF  276,2DF
0AC0:  MOVFF  277,2E0
0AC4:  MOVFF  276,2E1
0AC8:  MOVFF  279,2E2
0ACC:  MOVLW  01
0ACE:  MOVLB  2
0AD0:  MOVWF  xE3
0AD2:  MOVLB  0
0AD4:  RCALL  0902
....................    glcd_line(x2, y1, x2, y2, 1);
0AD6:  MOVFF  278,2DF
0ADA:  MOVFF  277,2E0
0ADE:  MOVFF  278,2E1
0AE2:  MOVFF  279,2E2
0AE6:  MOVLW  01
0AE8:  MOVLB  2
0AEA:  MOVWF  xE3
0AEC:  MOVLB  0
0AEE:  RCALL  0902
....................    glcd_line(x1, y2, x2, y2, 1);
0AF0:  MOVFF  276,2DF
0AF4:  MOVFF  279,2E0
0AF8:  MOVFF  278,2E1
0AFC:  MOVFF  279,2E2
0B00:  MOVLW  01
0B02:  MOVLB  2
0B04:  MOVWF  xE3
0B06:  MOVLB  0
0B08:  RCALL  0902
0B0A:  RETURN 0
.................... }
.................... 
.................... void grafico_control(){// rectangulo control
....................    rect(20,20,108,44);
*
0C7C:  MOVLW  14
0C7E:  MOVLB  2
0C80:  MOVWF  x76
0C82:  MOVWF  x77
0C84:  MOVLW  6C
0C86:  MOVWF  x78
0C88:  MOVLW  2C
0C8A:  MOVWF  x79
0C8C:  MOVLB  0
0C8E:  RCALL  0AA2
....................    rect(20,10,40,20);
0C90:  MOVLW  14
0C92:  MOVLB  2
0C94:  MOVWF  x76
0C96:  MOVLW  0A
0C98:  MOVWF  x77
0C9A:  MOVLW  28
0C9C:  MOVWF  x78
0C9E:  MOVLW  14
0CA0:  MOVWF  x79
0CA2:  MOVLB  0
0CA4:  RCALL  0AA2
....................    rect(88,10,108,20);
0CA6:  MOVLW  58
0CA8:  MOVLB  2
0CAA:  MOVWF  x76
0CAC:  MOVLW  0A
0CAE:  MOVWF  x77
0CB0:  MOVLW  6C
0CB2:  MOVWF  x78
0CB4:  MOVLW  14
0CB6:  MOVWF  x79
0CB8:  MOVLB  0
0CBA:  RCALL  0AA2
....................    rect(22,24,54,34);
0CBC:  MOVLW  16
0CBE:  MOVLB  2
0CC0:  MOVWF  x76
0CC2:  MOVLW  18
0CC4:  MOVWF  x77
0CC6:  MOVLW  36
0CC8:  MOVWF  x78
0CCA:  MOVLW  22
0CCC:  MOVWF  x79
0CCE:  MOVLB  0
0CD0:  RCALL  0AA2
....................    rect(74,24,106,34);
0CD2:  MOVLW  4A
0CD4:  MOVLB  2
0CD6:  MOVWF  x76
0CD8:  MOVLW  18
0CDA:  MOVWF  x77
0CDC:  MOVLW  6A
0CDE:  MOVWF  x78
0CE0:  MOVLW  22
0CE2:  MOVWF  x79
0CE4:  MOVLB  0
0CE6:  RCALL  0AA2
....................    char bl[] = "BL";
0CE8:  MOVLW  42
0CEA:  MOVLB  2
0CEC:  MOVWF  x59
0CEE:  MOVLW  4C
0CF0:  MOVWF  x5A
0CF2:  CLRF   x5B
....................    glcd_text57(22,12, bl, 1, 1);
0CF4:  MOVLW  16
0CF6:  MOVWF  xDF
0CF8:  MOVLW  0C
0CFA:  MOVWF  xE0
0CFC:  MOVLW  02
0CFE:  MOVWF  xE2
0D00:  MOVLW  59
0D02:  MOVWF  xE1
0D04:  MOVLW  01
0D06:  MOVWF  xE3
0D08:  MOVWF  xE4
0D0A:  MOVLB  0
0D0C:  RCALL  0B0C
....................    char br[] = "BR";
0D0E:  MOVLW  42
0D10:  MOVLB  2
0D12:  MOVWF  x5C
0D14:  MOVLW  52
0D16:  MOVWF  x5D
0D18:  CLRF   x5E
....................    glcd_text57(90,12, br, 1, 1);
0D1A:  MOVLW  5A
0D1C:  MOVWF  xDF
0D1E:  MOVLW  0C
0D20:  MOVWF  xE0
0D22:  MOVLW  02
0D24:  MOVWF  xE2
0D26:  MOVLW  5C
0D28:  MOVWF  xE1
0D2A:  MOVLW  01
0D2C:  MOVWF  xE3
0D2E:  MOVWF  xE4
0D30:  MOVLB  0
0D32:  RCALL  0B0C
....................    char jl[] = "LJ";
0D34:  MOVLW  4C
0D36:  MOVLB  2
0D38:  MOVWF  x5F
0D3A:  MOVLW  4A
0D3C:  MOVWF  x60
0D3E:  CLRF   x61
....................    glcd_text57(24,26, jl, 1, 1);
0D40:  MOVLW  18
0D42:  MOVWF  xDF
0D44:  MOVLW  1A
0D46:  MOVWF  xE0
0D48:  MOVLW  02
0D4A:  MOVWF  xE2
0D4C:  MOVLW  5F
0D4E:  MOVWF  xE1
0D50:  MOVLW  01
0D52:  MOVWF  xE3
0D54:  MOVWF  xE4
0D56:  MOVLB  0
0D58:  RCALL  0B0C
....................    char jr[] = "RJ";
0D5A:  MOVLW  52
0D5C:  MOVLB  2
0D5E:  MOVWF  x62
0D60:  MOVLW  4A
0D62:  MOVWF  x63
0D64:  CLRF   x64
....................    glcd_text57(76,26, jr, 1, 1);
0D66:  MOVLW  4C
0D68:  MOVWF  xDF
0D6A:  MOVLW  1A
0D6C:  MOVWF  xE0
0D6E:  MOVLW  02
0D70:  MOVWF  xE2
0D72:  MOVLW  62
0D74:  MOVWF  xE1
0D76:  MOVLW  01
0D78:  MOVWF  xE3
0D7A:  MOVWF  xE4
0D7C:  MOVLB  0
0D7E:  RCALL  0B0C
....................    char p[] = "Use P1 in menus";
0D80:  MOVLW  55
0D82:  MOVLB  2
0D84:  MOVWF  x65
0D86:  MOVLW  73
0D88:  MOVWF  x66
0D8A:  MOVLW  65
0D8C:  MOVWF  x67
0D8E:  MOVLW  20
0D90:  MOVWF  x68
0D92:  MOVLW  50
0D94:  MOVWF  x69
0D96:  MOVLW  31
0D98:  MOVWF  x6A
0D9A:  MOVLW  20
0D9C:  MOVWF  x6B
0D9E:  MOVLW  69
0DA0:  MOVWF  x6C
0DA2:  MOVLW  6E
0DA4:  MOVWF  x6D
0DA6:  MOVLW  20
0DA8:  MOVWF  x6E
0DAA:  MOVLW  6D
0DAC:  MOVWF  x6F
0DAE:  MOVLW  65
0DB0:  MOVWF  x70
0DB2:  MOVLW  6E
0DB4:  MOVWF  x71
0DB6:  MOVLW  75
0DB8:  MOVWF  x72
0DBA:  MOVLW  73
0DBC:  MOVWF  x73
0DBE:  CLRF   x74
....................    glcd_text57(20,56, p, 1, 1);
0DC0:  MOVLW  14
0DC2:  MOVWF  xDF
0DC4:  MOVLW  38
0DC6:  MOVWF  xE0
0DC8:  MOVLW  02
0DCA:  MOVWF  xE2
0DCC:  MOVLW  65
0DCE:  MOVWF  xE1
0DD0:  MOVLW  01
0DD2:  MOVWF  xE3
0DD4:  MOVWF  xE4
0DD6:  MOVLB  0
0DD8:  RCALL  0B0C
0DDA:  GOTO   2F80 (RETURN)
.................... }
.................... 
.................... void explic_m(){// rectangulo control
....................    rect(20,20,108,44);
*
17FC:  MOVLW  14
17FE:  MOVLB  2
1800:  MOVWF  x76
1802:  MOVWF  x77
1804:  MOVLW  6C
1806:  MOVWF  x78
1808:  MOVLW  2C
180A:  MOVWF  x79
180C:  MOVLB  0
180E:  CALL   0AA2
....................    rect(20,10,60,20);
1812:  MOVLW  14
1814:  MOVLB  2
1816:  MOVWF  x76
1818:  MOVLW  0A
181A:  MOVWF  x77
181C:  MOVLW  3C
181E:  MOVWF  x78
1820:  MOVLW  14
1822:  MOVWF  x79
1824:  MOVLB  0
1826:  CALL   0AA2
....................    rect(88,10,108,20);
182A:  MOVLW  58
182C:  MOVLB  2
182E:  MOVWF  x76
1830:  MOVLW  0A
1832:  MOVWF  x77
1834:  MOVLW  6C
1836:  MOVWF  x78
1838:  MOVLW  14
183A:  MOVWF  x79
183C:  MOVLB  0
183E:  CALL   0AA2
....................    rect(22,24,54,34);
1842:  MOVLW  16
1844:  MOVLB  2
1846:  MOVWF  x76
1848:  MOVLW  18
184A:  MOVWF  x77
184C:  MOVLW  36
184E:  MOVWF  x78
1850:  MOVLW  22
1852:  MOVWF  x79
1854:  MOVLB  0
1856:  CALL   0AA2
....................    rect(74,24,106,34);
185A:  MOVLW  4A
185C:  MOVLB  2
185E:  MOVWF  x76
1860:  MOVLW  18
1862:  MOVWF  x77
1864:  MOVLW  6A
1866:  MOVWF  x78
1868:  MOVLW  22
186A:  MOVWF  x79
186C:  MOVLB  0
186E:  CALL   0AA2
....................    char bl[] = "SHOOT";
1872:  MOVLW  53
1874:  MOVLB  2
1876:  MOVWF  x59
1878:  MOVLW  48
187A:  MOVWF  x5A
187C:  MOVLW  4F
187E:  MOVWF  x5B
1880:  MOVWF  x5C
1882:  MOVLW  54
1884:  MOVWF  x5D
1886:  CLRF   x5E
....................    glcd_text57(22,12, bl, 1, 1);
1888:  MOVLW  16
188A:  MOVWF  xDF
188C:  MOVLW  0C
188E:  MOVWF  xE0
1890:  MOVLW  02
1892:  MOVWF  xE2
1894:  MOVLW  59
1896:  MOVWF  xE1
1898:  MOVLW  01
189A:  MOVWF  xE3
189C:  MOVWF  xE4
189E:  MOVLB  0
18A0:  CALL   0B0C
....................    char br[] = "-";
18A4:  MOVLW  2D
18A6:  MOVLB  2
18A8:  MOVWF  x5F
18AA:  CLRF   x60
....................    glcd_text57(90,12, br, 1, 1);
18AC:  MOVLW  5A
18AE:  MOVWF  xDF
18B0:  MOVLW  0C
18B2:  MOVWF  xE0
18B4:  MOVLW  02
18B6:  MOVWF  xE2
18B8:  MOVLW  5F
18BA:  MOVWF  xE1
18BC:  MOVLW  01
18BE:  MOVWF  xE3
18C0:  MOVWF  xE4
18C2:  MOVLB  0
18C4:  CALL   0B0C
....................    char jl[] = "MOVE";
18C8:  MOVLW  4D
18CA:  MOVLB  2
18CC:  MOVWF  x61
18CE:  MOVLW  4F
18D0:  MOVWF  x62
18D2:  MOVLW  56
18D4:  MOVWF  x63
18D6:  MOVLW  45
18D8:  MOVWF  x64
18DA:  CLRF   x65
....................    glcd_text57(24,26, jl, 1, 1);
18DC:  MOVLW  18
18DE:  MOVWF  xDF
18E0:  MOVLW  1A
18E2:  MOVWF  xE0
18E4:  MOVLW  02
18E6:  MOVWF  xE2
18E8:  MOVLW  61
18EA:  MOVWF  xE1
18EC:  MOVLW  01
18EE:  MOVWF  xE3
18F0:  MOVWF  xE4
18F2:  MOVLB  0
18F4:  CALL   0B0C
....................    char jr[] = "AIM";
18F8:  MOVLW  41
18FA:  MOVLB  2
18FC:  MOVWF  x66
18FE:  MOVLW  49
1900:  MOVWF  x67
1902:  MOVLW  4D
1904:  MOVWF  x68
1906:  CLRF   x69
....................    glcd_text57(76,26, jr, 1, 1);
1908:  MOVLW  4C
190A:  MOVWF  xDF
190C:  MOVLW  1A
190E:  MOVWF  xE0
1910:  MOVLW  02
1912:  MOVWF  xE2
1914:  MOVLW  66
1916:  MOVWF  xE1
1918:  MOVLW  01
191A:  MOVWF  xE3
191C:  MOVWF  xE4
191E:  MOVLB  0
1920:  CALL   0B0C
....................    char p[] = "For P1 & P2";
1924:  MOVLW  46
1926:  MOVLB  2
1928:  MOVWF  x6A
192A:  MOVLW  6F
192C:  MOVWF  x6B
192E:  MOVLW  72
1930:  MOVWF  x6C
1932:  MOVLW  20
1934:  MOVWF  x6D
1936:  MOVLW  50
1938:  MOVWF  x6E
193A:  MOVLW  31
193C:  MOVWF  x6F
193E:  MOVLW  20
1940:  MOVWF  x70
1942:  MOVLW  26
1944:  MOVWF  x71
1946:  MOVLW  20
1948:  MOVWF  x72
194A:  MOVLW  50
194C:  MOVWF  x73
194E:  MOVLW  32
1950:  MOVWF  x74
1952:  CLRF   x75
....................    glcd_text57(20,56, p, 1, 1);
1954:  MOVLW  14
1956:  MOVWF  xDF
1958:  MOVLW  38
195A:  MOVWF  xE0
195C:  MOVLW  02
195E:  MOVWF  xE2
1960:  MOVLW  6A
1962:  MOVWF  xE1
1964:  MOVLW  01
1966:  MOVWF  xE3
1968:  MOVWF  xE4
196A:  MOVLB  0
196C:  CALL   0B0C
1970:  GOTO   313E (RETURN)
.................... }
.................... 
.................... void explic_s(){// rectangulo control
....................    rect(20,20,108,44);
*
1684:  MOVLW  14
1686:  MOVLB  2
1688:  MOVWF  x76
168A:  MOVWF  x77
168C:  MOVLW  6C
168E:  MOVWF  x78
1690:  MOVLW  2C
1692:  MOVWF  x79
1694:  MOVLB  0
1696:  CALL   0AA2
....................    rect(20,10,40,20);
169A:  MOVLW  14
169C:  MOVLB  2
169E:  MOVWF  x76
16A0:  MOVLW  0A
16A2:  MOVWF  x77
16A4:  MOVLW  28
16A6:  MOVWF  x78
16A8:  MOVLW  14
16AA:  MOVWF  x79
16AC:  MOVLB  0
16AE:  CALL   0AA2
....................    rect(68,10,108,20);
16B2:  MOVLW  44
16B4:  MOVLB  2
16B6:  MOVWF  x76
16B8:  MOVLW  0A
16BA:  MOVWF  x77
16BC:  MOVLW  6C
16BE:  MOVWF  x78
16C0:  MOVLW  14
16C2:  MOVWF  x79
16C4:  MOVLB  0
16C6:  CALL   0AA2
....................    rect(22,24,54,34);
16CA:  MOVLW  16
16CC:  MOVLB  2
16CE:  MOVWF  x76
16D0:  MOVLW  18
16D2:  MOVWF  x77
16D4:  MOVLW  36
16D6:  MOVWF  x78
16D8:  MOVLW  22
16DA:  MOVWF  x79
16DC:  MOVLB  0
16DE:  CALL   0AA2
....................    rect(74,24,106,34);
16E2:  MOVLW  4A
16E4:  MOVLB  2
16E6:  MOVWF  x76
16E8:  MOVLW  18
16EA:  MOVWF  x77
16EC:  MOVLW  6A
16EE:  MOVWF  x78
16F0:  MOVLW  22
16F2:  MOVWF  x79
16F4:  MOVLB  0
16F6:  CALL   0AA2
....................    char bl[] = "-";
16FA:  MOVLW  2D
16FC:  MOVLB  2
16FE:  MOVWF  x59
1700:  CLRF   x5A
....................    glcd_text57(22,12, bl, 1, 1);
1702:  MOVLW  16
1704:  MOVWF  xDF
1706:  MOVLW  0C
1708:  MOVWF  xE0
170A:  MOVLW  02
170C:  MOVWF  xE2
170E:  MOVLW  59
1710:  MOVWF  xE1
1712:  MOVLW  01
1714:  MOVWF  xE3
1716:  MOVWF  xE4
1718:  MOVLB  0
171A:  CALL   0B0C
....................    char br[] = "SHOOT";
171E:  MOVLW  53
1720:  MOVLB  2
1722:  MOVWF  x5B
1724:  MOVLW  48
1726:  MOVWF  x5C
1728:  MOVLW  4F
172A:  MOVWF  x5D
172C:  MOVWF  x5E
172E:  MOVLW  54
1730:  MOVWF  x5F
1732:  CLRF   x60
....................    glcd_text57(70,12, br, 1, 1);
1734:  MOVLW  46
1736:  MOVWF  xDF
1738:  MOVLW  0C
173A:  MOVWF  xE0
173C:  MOVLW  02
173E:  MOVWF  xE2
1740:  MOVLW  5B
1742:  MOVWF  xE1
1744:  MOVLW  01
1746:  MOVWF  xE3
1748:  MOVWF  xE4
174A:  MOVLB  0
174C:  CALL   0B0C
....................    char jl[] = "MOVE";
1750:  MOVLW  4D
1752:  MOVLB  2
1754:  MOVWF  x61
1756:  MOVLW  4F
1758:  MOVWF  x62
175A:  MOVLW  56
175C:  MOVWF  x63
175E:  MOVLW  45
1760:  MOVWF  x64
1762:  CLRF   x65
....................    glcd_text57(24,26, jl, 1, 1);
1764:  MOVLW  18
1766:  MOVWF  xDF
1768:  MOVLW  1A
176A:  MOVWF  xE0
176C:  MOVLW  02
176E:  MOVWF  xE2
1770:  MOVLW  61
1772:  MOVWF  xE1
1774:  MOVLW  01
1776:  MOVWF  xE3
1778:  MOVWF  xE4
177A:  MOVLB  0
177C:  CALL   0B0C
....................    char jr[] = "AIM";
1780:  MOVLW  41
1782:  MOVLB  2
1784:  MOVWF  x66
1786:  MOVLW  49
1788:  MOVWF  x67
178A:  MOVLW  4D
178C:  MOVWF  x68
178E:  CLRF   x69
....................    glcd_text57(76,26, jr, 1, 1);
1790:  MOVLW  4C
1792:  MOVWF  xDF
1794:  MOVLW  1A
1796:  MOVWF  xE0
1798:  MOVLW  02
179A:  MOVWF  xE2
179C:  MOVLW  66
179E:  MOVWF  xE1
17A0:  MOVLW  01
17A2:  MOVWF  xE3
17A4:  MOVWF  xE4
17A6:  MOVLB  0
17A8:  CALL   0B0C
....................    char p[] = "For P1 only";
17AC:  MOVLW  46
17AE:  MOVLB  2
17B0:  MOVWF  x6A
17B2:  MOVLW  6F
17B4:  MOVWF  x6B
17B6:  MOVLW  72
17B8:  MOVWF  x6C
17BA:  MOVLW  20
17BC:  MOVWF  x6D
17BE:  MOVLW  50
17C0:  MOVWF  x6E
17C2:  MOVLW  31
17C4:  MOVWF  x6F
17C6:  MOVLW  20
17C8:  MOVWF  x70
17CA:  MOVLW  6F
17CC:  MOVWF  x71
17CE:  MOVLW  6E
17D0:  MOVWF  x72
17D2:  MOVLW  6C
17D4:  MOVWF  x73
17D6:  MOVLW  79
17D8:  MOVWF  x74
17DA:  CLRF   x75
....................    glcd_text57(20,56, p, 1, 1);
17DC:  MOVLW  14
17DE:  MOVWF  xDF
17E0:  MOVLW  38
17E2:  MOVWF  xE0
17E4:  MOVLW  02
17E6:  MOVWF  xE2
17E8:  MOVLW  6A
17EA:  MOVWF  xE1
17EC:  MOVLW  01
17EE:  MOVWF  xE3
17F0:  MOVWF  xE4
17F2:  MOVLB  0
17F4:  CALL   0B0C
17F8:  GOTO   30B6 (RETURN)
.................... }

Configuration Fuses:
   Word  1: CC04   PLL5 CPUDIV1 NOUSBDIV HS FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 0700   CCP2C1 PBADEN LPT1OSC NOMCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
