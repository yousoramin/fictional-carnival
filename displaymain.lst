CCS PCH C Compiler, Version 5.112, 5967               22-nov.-24 11:03

               Filename:   C:\Users\Kevin\Desktop\UAQ Auto\Tareas y Trabajos\S4_Microsistemas\videoujuego online\displaymain.lst

               ROM used:   17496 bytes (53%)
                           Largest free fragment is 15268
               RAM used:   613 (30%) at main() level
                           675 (33%) worst case
               Stack used: 5 locations (4 in main + 1 for interrupts)
               Stack size: 31

*
0000:  GOTO   25CC
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.5
0056:  GOTO   0060
005A:  BTFSC  F9E.5
005C:  GOTO   0510
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVFF  15,FF5
009A:  MOVFF  16,FF6
009E:  MOVFF  17,FF7
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... #include <18F4550.h>
.................... //////////// Standard Header file for the PIC18F4550 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F4550
00AE:  CLRF   FF7
00B0:  ADDLW  BE
00B2:  MOVWF  FF6
00B4:  MOVLW  00
00B6:  ADDWFC FF7,F
00B8:  TBLRD*+
00BA:  MOVF   FF5,W
00BC:  RETURN 0
00BE:  DATA 00,00
00C0:  DATA 00,00
00C2:  DATA 00,00
00C4:  DATA 00,5F
00C6:  DATA 00,00
00C8:  DATA 00,03
00CA:  DATA 00,03
00CC:  DATA 00,14
00CE:  DATA 3E,14
00D0:  DATA 3E,14
00D2:  DATA 24,2A
00D4:  DATA 7F,2A
00D6:  DATA 12,43
00D8:  DATA 33,08
00DA:  DATA 66,61
00DC:  DATA 36,49
00DE:  DATA 55,22
00E0:  DATA 50,00
00E2:  DATA 05,03
00E4:  DATA 00,00
00E6:  DATA 00,1C
00E8:  DATA 22,41
00EA:  DATA 00,00
00EC:  DATA 41,22
00EE:  DATA 1C,00
00F0:  DATA 14,08
00F2:  DATA 3E,08
00F4:  DATA 14,08
00F6:  DATA 08,3E
00F8:  DATA 08,08
00FA:  DATA 00,50
00FC:  DATA 30,00
00FE:  DATA 00,08
0100:  DATA 08,08
0102:  DATA 08,08
0104:  DATA 00,60
0106:  DATA 60,00
0108:  DATA 00,20
010A:  DATA 10,08
010C:  DATA 04,02
010E:  DATA 3E,51
0110:  DATA 49,45
0112:  DATA 3E,04
0114:  DATA 02,7F
0116:  DATA 00,00
0118:  DATA 42,61
011A:  DATA 51,49
011C:  DATA 46,22
011E:  DATA 41,49
0120:  DATA 49,36
0122:  DATA 18,14
0124:  DATA 12,7F
0126:  DATA 10,27
0128:  DATA 45,45
012A:  DATA 45,39
012C:  DATA 3E,49
012E:  DATA 49,49
0130:  DATA 32,01
0132:  DATA 01,71
0134:  DATA 09,07
0136:  DATA 36,49
0138:  DATA 49,49
013A:  DATA 36,26
013C:  DATA 49,49
013E:  DATA 49,3E
0140:  DATA 00,36
0142:  DATA 36,00
0144:  DATA 00,00
0146:  DATA 56,36
0148:  DATA 00,00
014A:  DATA 08,14
014C:  DATA 22,41
014E:  DATA 00,14
0150:  DATA 14,14
0152:  DATA 14,14
0154:  DATA 00,41
0156:  DATA 22,14
0158:  DATA 08,02
015A:  DATA 01,51
015C:  DATA 09,06
015E:  DATA 3E,41
0160:  DATA 59,55
0162:  DATA 5E,7E
0164:  DATA 09,09
0166:  DATA 09,7E
0168:  DATA 7F,49
016A:  DATA 49,49
016C:  DATA 36,3E
016E:  DATA 41,41
0170:  DATA 41,22
0172:  DATA 7F,41
0174:  DATA 41,41
0176:  DATA 3E,7F
0178:  DATA 49,49
017A:  DATA 49,41
017C:  DATA 7F,09
017E:  DATA 09,09
0180:  DATA 01,3E
0182:  DATA 41,41
0184:  DATA 49,3A
0186:  DATA 7F,08
0188:  DATA 08,08
018A:  DATA 7F,00
018C:  DATA 41,7F
018E:  DATA 41,00
0190:  DATA 30,40
0192:  DATA 40,40
0194:  DATA 3F,7F
0196:  DATA 08,14
0198:  DATA 22,41
019A:  DATA 7F,40
019C:  DATA 40,40
019E:  DATA 40,7F
01A0:  DATA 02,0C
01A2:  DATA 02,7F
01A4:  DATA 7F,02
01A6:  DATA 04,08
01A8:  DATA 7F,3E
01AA:  DATA 41,41
01AC:  DATA 41,3E
01AE:  DATA 7F,09
01B0:  DATA 09,09
01B2:  DATA 06,1E
01B4:  DATA 21,21
01B6:  DATA 21,5E
01B8:  DATA 7F,09
01BA:  DATA 09,09
01BC:  DATA 76,00
01BE:  CLRF   FF7
01C0:  ADDLW  CE
01C2:  MOVWF  FF6
01C4:  MOVLW  01
01C6:  ADDWFC FF7,F
01C8:  TBLRD*+
01CA:  MOVF   FF5,W
01CC:  RETURN 0
01CE:  DATA 26,49
01D0:  DATA 49,49
01D2:  DATA 32,01
01D4:  DATA 01,7F
01D6:  DATA 01,01
01D8:  DATA 3F,40
01DA:  DATA 40,40
01DC:  DATA 3F,1F
01DE:  DATA 20,40
01E0:  DATA 20,1F
01E2:  DATA 7F,20
01E4:  DATA 10,20
01E6:  DATA 7F,41
01E8:  DATA 22,1C
01EA:  DATA 22,41
01EC:  DATA 07,08
01EE:  DATA 70,08
01F0:  DATA 07,61
01F2:  DATA 51,49
01F4:  DATA 45,43
01F6:  DATA 00,7F
01F8:  DATA 41,00
01FA:  DATA 00,02
01FC:  DATA 04,08
01FE:  DATA 10,20
0200:  DATA 00,00
0202:  DATA 41,7F
0204:  DATA 00,04
0206:  DATA 02,01
0208:  DATA 02,04
020A:  DATA 40,40
020C:  DATA 40,40
020E:  DATA 40,00
0210:  DATA 01,02
0212:  DATA 04,00
0214:  DATA 20,54
0216:  DATA 54,54
0218:  DATA 78,7F
021A:  DATA 44,44
021C:  DATA 44,38
021E:  DATA 38,44
0220:  DATA 44,44
0222:  DATA 44,38
0224:  DATA 44,44
0226:  DATA 44,7F
0228:  DATA 38,54
022A:  DATA 54,54
022C:  DATA 18,04
022E:  DATA 04,7E
0230:  DATA 05,05
0232:  DATA 08,54
0234:  DATA 54,54
0236:  DATA 3C,7F
0238:  DATA 08,04
023A:  DATA 04,78
023C:  DATA 00,44
023E:  DATA 7D,40
0240:  DATA 00,20
0242:  DATA 40,44
0244:  DATA 3D,00
0246:  DATA 7F,10
0248:  DATA 28,44
024A:  DATA 00,00
024C:  DATA 41,7F
024E:  DATA 40,00
0250:  DATA 7C,04
0252:  DATA 78,04
0254:  DATA 78,7C
0256:  DATA 08,04
0258:  DATA 04,78
025A:  DATA 38,44
025C:  DATA 44,44
025E:  DATA 38,7C
0260:  DATA 14,14
0262:  DATA 14,08
0264:  DATA 08,14
0266:  DATA 14,14
0268:  DATA 7C,00
026A:  DATA 7C,08
026C:  DATA 04,04
026E:  DATA 48,54
0270:  DATA 54,54
0272:  DATA 20,04
0274:  DATA 04,3F
0276:  DATA 44,44
0278:  DATA 3C,40
027A:  DATA 40,20
027C:  DATA 7C,1C
027E:  DATA 20,40
0280:  DATA 20,1C
0282:  DATA 3C,40
0284:  DATA 30,40
0286:  DATA 3C,44
0288:  DATA 28,10
028A:  DATA 28,44
028C:  DATA 0C,50
028E:  DATA 50,50
0290:  DATA 3C,44
0292:  DATA 64,54
0294:  DATA 4C,44
0296:  DATA 00,08
0298:  DATA 36,41
029A:  DATA 41,00
029C:  DATA 00,7F
029E:  DATA 00,00
02A0:  DATA 41,41
02A2:  DATA 36,08
02A4:  DATA 00,02
02A6:  DATA 01,02
02A8:  DATA 04,02
02AA:  ADDLW  B8
02AC:  MOVWF  FF6
02AE:  MOVLW  02
02B0:  ADDWFC FF7,F
02B2:  TBLRD*+
02B4:  MOVF   FF5,W
02B6:  RETURN 0
02B8:  DATA 00,00
02BA:  DATA 00,00
02BC:  DATA 00,00
02BE:  DATA 01,00
02C0:  DATA 00,00
02C2:  DATA 00,00
02C4:  DATA 00,00
02C6:  DATA 00,00
02C8:  DATA 00,00
02CA:  DATA 00,00
02CC:  DATA 00,00
02CE:  DATA 00,00
02D0:  DATA 01,00
02D2:  DATA 00,00
02D4:  DATA 00,00
02D6:  DATA 00,00
02D8:  DATA 00,01
02DA:  DATA 00,00
02DC:  DATA 00,00
02DE:  DATA 00,00
02E0:  DATA 00,00
02E2:  DATA 00,00
02E4:  DATA 00,00
02E6:  DATA 00,00
02E8:  DATA 02,00
02EA:  DATA 00,00
02EC:  DATA 00,00
02EE:  DATA 00,00
02F0:  DATA 00,00
02F2:  DATA 00,00
02F4:  DATA 00,00
02F6:  DATA 00,02
02F8:  DATA 00,00
02FA:  DATA 00,00
02FC:  DATA 00,00
02FE:  DATA 00,00
0300:  DATA 00,00
0302:  DATA 00,00
0304:  DATA 02,00
0306:  DATA 00,00
0308:  DATA 00,00
030A:  DATA 00,00
030C:  DATA 00,00
030E:  DATA 00,00
0310:  DATA 00,00
0312:  DATA 00,00
0314:  DATA 00,00
0316:  DATA 00,00
0318:  DATA 00,00
031A:  DATA 00,03
031C:  DATA 03,00
031E:  DATA 00,00
0320:  DATA 00,03
0322:  DATA 00,00
0324:  DATA 00,00
0326:  DATA 00,00
0328:  DATA 00,00
032A:  DATA 00,00
032C:  DATA 00,00
032E:  DATA 00,00
0330:  DATA 00,02
0332:  DATA 03,01
0334:  DATA 00,00
0336:  DATA 00,00
0338:  DATA 00,00
033A:  DATA 00,00
033C:  DATA 00,00
033E:  DATA 00,00
0340:  DATA 00,00
0342:  DATA 00,00
0344:  DATA 00,00
0346:  DATA 00,02
0348:  DATA 00,00
034A:  DATA 01,00
034C:  DATA 01,00
034E:  DATA 00,00
0350:  DATA 00,00
0352:  DATA 00,01
0354:  DATA 00,01
0356:  DATA 00,00
0358:  DATA 00,00
035A:  DATA 00,00
035C:  DATA 00,00
035E:  DATA 00,03
0360:  DATA 00,00
0362:  DATA 03,00
0364:  DATA 03,00
0366:  DATA 00,00
0368:  DATA 00,00
036A:  DATA 00,00
036C:  DATA 00,00
036E:  DATA 00,00
0370:  DATA 00,00
0372:  DATA 00,00
0374:  DATA 00,00
0376:  DATA 00,00
0378:  DATA 00,00
037A:  DATA 00,00
037C:  DATA 00,00
037E:  DATA 00,00
0380:  DATA 00,00
0382:  DATA 00,00
0384:  DATA 00,00
0386:  DATA 00,00
0388:  DATA 00,00
038A:  DATA 00,00
038C:  DATA 00,00
038E:  DATA 00,00
0390:  DATA 00,00
0392:  DATA 00,00
0394:  DATA 00,00
0396:  DATA 00,00
0398:  DATA 00,00
039A:  DATA 00,00
039C:  DATA 00,00
039E:  DATA 00,00
03A0:  DATA 00,00
03A2:  DATA 00,00
03A4:  DATA 00,00
03A6:  DATA 00,00
03A8:  DATA 00,00
03AA:  DATA 00,00
03AC:  DATA 00,00
03AE:  DATA 00,00
03B0:  DATA 00,00
03B2:  DATA 00,00
03B4:  DATA 00,00
03B6:  DATA 00,00
03B8:  DATA 00,00
03BA:  DATA 00,00
03BC:  DATA 00,00
03BE:  DATA 00,00
03C0:  DATA 00,00
03C2:  DATA 00,00
03C4:  DATA 00,00
03C6:  DATA 00,00
03C8:  DATA 00,00
03CA:  DATA 00,00
03CC:  DATA 00,00
03CE:  DATA 00,00
03D0:  DATA 00,00
03D2:  DATA 00,00
03D4:  DATA 00,00
03D6:  DATA 00,00
03D8:  DATA 00,00
03DA:  DATA 00,00
03DC:  DATA 00,00
03DE:  DATA 00,00
03E0:  DATA 00,00
03E2:  DATA 00,00
03E4:  DATA 00,00
03E6:  DATA 00,00
03E8:  DATA 00,00
03EA:  DATA 00,00
03EC:  DATA 00,00
03EE:  DATA 00,00
03F0:  DATA 00,00
03F2:  DATA 00,00
03F4:  DATA 00,00
03F6:  DATA 00,00
03F8:  DATA 00,00
03FA:  DATA 00,00
03FC:  DATA 00,00
03FE:  DATA 00,00
0400:  DATA 00,00
0402:  DATA 00,00
0404:  DATA 00,00
0406:  DATA 00,00
0408:  DATA 00,00
040A:  DATA 00,00
040C:  DATA 00,00
040E:  DATA 00,00
0410:  DATA 00,00
0412:  DATA 00,00
0414:  DATA 00,00
0416:  DATA 00,00
0418:  DATA 00,00
041A:  DATA 00,00
041C:  DATA 00,00
041E:  DATA 00,00
0420:  DATA 00,00
0422:  DATA 00,00
0424:  DATA 00,00
0426:  DATA 00,00
0428:  DATA 00,00
042A:  DATA 00,00
042C:  DATA 00,00
042E:  DATA 00,00
0430:  DATA 00,00
0432:  DATA 00,00
0434:  DATA 00,00
0436:  DATA 00,00
0438:  DATA 00,00
043A:  DATA 00,00
043C:  DATA 00,00
043E:  DATA 00,00
0440:  DATA 00,00
0442:  DATA 00,00
0444:  DATA 00,00
0446:  DATA 00,00
0448:  DATA 00,00
044A:  DATA 00,00
044C:  DATA 00,00
044E:  DATA 00,00
0450:  DATA 00,00
0452:  DATA 00,00
0454:  DATA 00,00
0456:  DATA 00,00
0458:  DATA 00,00
045A:  DATA 00,00
045C:  DATA 00,00
045E:  DATA 00,00
0460:  DATA 00,00
0462:  DATA 00,00
0464:  DATA 00,00
0466:  DATA 00,00
0468:  DATA 00,00
046A:  DATA 00,00
046C:  DATA 00,00
046E:  DATA 00,00
0470:  DATA 00,00
0472:  DATA 00,00
0474:  DATA 00,00
0476:  DATA 00,00
0478:  DATA 00,00
047A:  DATA 00,00
047C:  DATA 00,00
047E:  DATA 00,00
0480:  DATA 00,00
0482:  DATA 00,00
0484:  DATA 00,00
0486:  DATA 00,00
0488:  DATA 00,00
048A:  DATA 00,00
048C:  DATA 00,00
048E:  DATA 00,00
0490:  DATA 00,00
0492:  DATA 00,00
0494:  DATA 00,00
0496:  DATA 00,00
0498:  DATA 00,00
049A:  DATA 00,00
049C:  DATA 00,00
049E:  DATA 00,00
04A0:  DATA 00,00
04A2:  DATA 00,00
04A4:  DATA 00,00
04A6:  DATA 00,00
04A8:  DATA 00,00
04AA:  DATA 00,00
04AC:  DATA 00,00
04AE:  DATA 00,00
04B0:  DATA 00,00
04B2:  DATA 00,00
04B4:  DATA 00,00
04B6:  DATA 00,00
04B8:  DATA 00,00
04BA:  DATA 00,00
04BC:  DATA 00,00
04BE:  DATA 00,00
04C0:  DATA 00,00
04C2:  DATA 00,00
04C4:  DATA 00,00
04C6:  DATA 00,00
04C8:  DATA 00,00
04CA:  DATA 00,00
04CC:  DATA 00,00
04CE:  DATA 00,00
04D0:  DATA 00,00
04D2:  DATA 00,00
04D4:  DATA 00,00
04D6:  DATA 00,00
04D8:  DATA 00,00
04DA:  DATA 00,00
04DC:  DATA 00,00
04DE:  DATA 00,00
04E0:  DATA 00,00
04E2:  DATA 00,00
04E4:  DATA 00,00
04E6:  DATA 00,00
04E8:  DATA 00,00
04EA:  DATA 00,00
04EC:  DATA 00,00
04EE:  DATA 00,00
04F0:  DATA 00,00
04F2:  DATA 00,00
04F4:  DATA 00,00
04F6:  DATA 00,00
04F8:  DATA 00,00
04FA:  DATA 00,00
04FC:  DATA 00,00
04FE:  DATA 00,00
0500:  DATA 00,00
0502:  DATA 00,00
0504:  DATA 00,00
0506:  DATA 00,00
0508:  DATA 00,00
050A:  DATA 00,00
050C:  DATA 00,00
050E:  DATA 00,00
*
05C0:  ADDWF  FE8,W
05C2:  CLRF   FF7
05C4:  RLCF   FF7,F
05C6:  ADDLW  DB
05C8:  MOVWF  FF6
05CA:  MOVLW  05
05CC:  ADDWFC FF7,F
05CE:  TBLRD*-
05D0:  MOVF   FF5,W
05D2:  MOVWF  FFA
05D4:  TBLRD*
05D6:  MOVF   FF5,W
05D8:  MOVWF  FF9
05DA:  DATA 28,05
05DC:  DATA 30,05
05DE:  DATA 38,05
05E0:  DATA 40,05
05E2:  DATA 48,05
05E4:  DATA 50,05
05E6:  DATA 58,05
05E8:  DATA 60,05
05EA:  DATA 68,05
*
0A22:  CLRF   00
0A24:  CLRF   01
0A26:  MOVLB  2
0A28:  MOVF   x92,W
0A2A:  BCF    FD8.0
0A2C:  BTFSC  x93.0
0A2E:  ADDWF  00,F
0A30:  RRCF   00,F
0A32:  RRCF   01,F
0A34:  BTFSC  x93.1
0A36:  ADDWF  00,F
0A38:  RRCF   00,F
0A3A:  RRCF   01,F
0A3C:  BTFSC  x93.2
0A3E:  ADDWF  00,F
0A40:  RRCF   00,F
0A42:  RRCF   01,F
0A44:  BTFSC  x93.3
0A46:  ADDWF  00,F
0A48:  RRCF   00,F
0A4A:  RRCF   01,F
0A4C:  BTFSC  x93.4
0A4E:  ADDWF  00,F
0A50:  RRCF   00,F
0A52:  RRCF   01,F
0A54:  BTFSC  x93.5
0A56:  ADDWF  00,F
0A58:  RRCF   00,F
0A5A:  RRCF   01,F
0A5C:  BTFSC  x93.6
0A5E:  ADDWF  00,F
0A60:  RRCF   00,F
0A62:  RRCF   01,F
0A64:  BTFSC  x93.7
0A66:  ADDWF  00,F
0A68:  RRCF   00,F
0A6A:  RRCF   01,F
0A6C:  MOVLB  0
0A6E:  RETURN 0
*
110C:  MOVLB  2
110E:  MOVF   x5F,W
1110:  MULWF  x61
1112:  MOVFF  FF3,01
1116:  MOVFF  FF4,00
111A:  MULWF  x62
111C:  MOVF   FF3,W
111E:  ADDWF  00,F
1120:  MOVF   x60,W
1122:  MULWF  x61
1124:  MOVF   FF3,W
1126:  ADDWFC 00,W
1128:  MOVWF  02
112A:  MOVLB  0
112C:  GOTO   29D8 (RETURN)
*
11AE:  MOVLW  8E
11B0:  MOVWF  00
11B2:  MOVFF  294,01
11B6:  MOVFF  293,02
11BA:  CLRF   03
11BC:  MOVF   01,F
11BE:  BNZ   11D2
11C0:  MOVFF  02,01
11C4:  CLRF   02
11C6:  MOVLW  08
11C8:  SUBWF  00,F
11CA:  MOVF   01,F
11CC:  BNZ   11D2
11CE:  CLRF   00
11D0:  BRA    11E2
11D2:  BCF    FD8.0
11D4:  BTFSC  01.7
11D6:  BRA    11E0
11D8:  RLCF   02,F
11DA:  RLCF   01,F
11DC:  DECF   00,F
11DE:  BRA    11D2
11E0:  BCF    01.7
11E2:  RETURN 0
11E4:  MOVLB  2
11E6:  MOVF   x65,W
11E8:  BTFSC  FD8.2
11EA:  BRA    1336
11EC:  MOVWF  x71
11EE:  MOVF   x69,W
11F0:  BTFSC  FD8.2
11F2:  BRA    1336
11F4:  SUBWF  x71,F
11F6:  BNC   1202
11F8:  MOVLW  7F
11FA:  ADDWF  x71,F
11FC:  BTFSC  FD8.0
11FE:  BRA    1336
1200:  BRA    120E
1202:  MOVLW  81
1204:  SUBWF  x71,F
1206:  BTFSS  FD8.0
1208:  BRA    1336
120A:  BTFSC  FD8.2
120C:  BRA    1336
120E:  MOVFF  271,00
1212:  CLRF   01
1214:  CLRF   02
1216:  CLRF   03
1218:  CLRF   x70
121A:  MOVFF  266,26F
121E:  BSF    x6F.7
1220:  MOVFF  267,26E
1224:  MOVFF  268,26D
1228:  MOVLW  19
122A:  MOVWF  x71
122C:  MOVF   x6C,W
122E:  SUBWF  x6D,F
1230:  BC    124C
1232:  MOVLW  01
1234:  SUBWF  x6E,F
1236:  BC    124C
1238:  SUBWF  x6F,F
123A:  BC    124C
123C:  SUBWF  x70,F
123E:  BC    124C
1240:  INCF   x70,F
1242:  INCF   x6F,F
1244:  INCF   x6E,F
1246:  MOVF   x6C,W
1248:  ADDWF  x6D,F
124A:  BRA    129C
124C:  MOVF   x6B,W
124E:  SUBWF  x6E,F
1250:  BC    1276
1252:  MOVLW  01
1254:  SUBWF  x6F,F
1256:  BC    1276
1258:  SUBWF  x70,F
125A:  BC    1276
125C:  INCF   x70,F
125E:  INCF   x6F,F
1260:  MOVF   x6B,W
1262:  ADDWF  x6E,F
1264:  MOVF   x6C,W
1266:  ADDWF  x6D,F
1268:  BNC   129C
126A:  INCF   x6E,F
126C:  BNZ   129C
126E:  INCF   x6F,F
1270:  BNZ   129C
1272:  INCF   x70,F
1274:  BRA    129C
1276:  MOVF   x6A,W
1278:  IORLW  80
127A:  SUBWF  x6F,F
127C:  BC    129A
127E:  MOVLW  01
1280:  SUBWF  x70,F
1282:  BC    129A
1284:  INCF   x70,F
1286:  MOVF   x6A,W
1288:  IORLW  80
128A:  ADDWF  x6F,F
128C:  MOVF   x6B,W
128E:  ADDWF  x6E,F
1290:  BNC   1264
1292:  INCF   x6F,F
1294:  BNZ   1264
1296:  INCF   x70,F
1298:  BRA    1264
129A:  BSF    03.0
129C:  DECFSZ x71,F
129E:  BRA    12A2
12A0:  BRA    12B8
12A2:  BCF    FD8.0
12A4:  RLCF   x6D,F
12A6:  RLCF   x6E,F
12A8:  RLCF   x6F,F
12AA:  RLCF   x70,F
12AC:  BCF    FD8.0
12AE:  RLCF   03,F
12B0:  RLCF   02,F
12B2:  RLCF   01,F
12B4:  RLCF   x72,F
12B6:  BRA    122C
12B8:  BTFSS  x72.0
12BA:  BRA    12C8
12BC:  BCF    FD8.0
12BE:  RRCF   01,F
12C0:  RRCF   02,F
12C2:  RRCF   03,F
12C4:  RRCF   x72,F
12C6:  BRA    12CC
12C8:  DECF   00,F
12CA:  BZ    1336
12CC:  BTFSC  x72.7
12CE:  BRA    130C
12D0:  BCF    FD8.0
12D2:  RLCF   x6D,F
12D4:  RLCF   x6E,F
12D6:  RLCF   x6F,F
12D8:  RLCF   x70,F
12DA:  MOVF   x6C,W
12DC:  SUBWF  x6D,F
12DE:  BC    12EE
12E0:  MOVLW  01
12E2:  SUBWF  x6E,F
12E4:  BC    12EE
12E6:  SUBWF  x6F,F
12E8:  BC    12EE
12EA:  SUBWF  x70,F
12EC:  BNC   1322
12EE:  MOVF   x6B,W
12F0:  SUBWF  x6E,F
12F2:  BC    12FE
12F4:  MOVLW  01
12F6:  SUBWF  x6F,F
12F8:  BC    12FE
12FA:  SUBWF  x70,F
12FC:  BNC   1322
12FE:  MOVF   x6A,W
1300:  IORLW  80
1302:  SUBWF  x6F,F
1304:  BC    130C
1306:  MOVLW  01
1308:  SUBWF  x70,F
130A:  BNC   1322
130C:  INCF   03,F
130E:  BNZ   1322
1310:  INCF   02,F
1312:  BNZ   1322
1314:  INCF   01,F
1316:  BNZ   1322
1318:  INCF   00,F
131A:  BZ    1336
131C:  RRCF   01,F
131E:  RRCF   02,F
1320:  RRCF   03,F
1322:  MOVFF  266,271
1326:  MOVF   x6A,W
1328:  XORWF  x71,F
132A:  BTFSS  x71.7
132C:  BRA    1332
132E:  BSF    01.7
1330:  BRA    133E
1332:  BCF    01.7
1334:  BRA    133E
1336:  CLRF   00
1338:  CLRF   01
133A:  CLRF   02
133C:  CLRF   03
133E:  MOVLB  0
1340:  RETURN 0
1342:  MOVLW  8E
1344:  MOVWF  00
1346:  MOVLB  2
1348:  MOVF   x8F,W
134A:  SUBWF  00,F
134C:  MOVFF  290,02
1350:  MOVFF  291,01
1354:  BSF    02.7
1356:  MOVF   00,F
1358:  BZ    136C
135A:  BCF    FD8.0
135C:  MOVF   02,F
135E:  BNZ   1364
1360:  MOVF   01,F
1362:  BZ    136C
1364:  RRCF   02,F
1366:  RRCF   01,F
1368:  DECFSZ 00,F
136A:  BRA    135A
136C:  BTFSS  x90.7
136E:  BRA    137A
1370:  COMF   01,F
1372:  COMF   02,F
1374:  INCF   01,F
1376:  BTFSC  FD8.2
1378:  INCF   02,F
137A:  MOVLB  0
137C:  RETURN 0
137E:  MOVLB  2
1380:  MOVF   x6E,W
1382:  CLRF   01
1384:  SUBWF  x6D,W
1386:  BC    138E
1388:  MOVFF  26D,00
138C:  BRA    13A6
138E:  CLRF   00
1390:  MOVLW  08
1392:  MOVWF  x6F
1394:  RLCF   x6D,F
1396:  RLCF   00,F
1398:  MOVF   x6E,W
139A:  SUBWF  00,W
139C:  BTFSC  FD8.0
139E:  MOVWF  00
13A0:  RLCF   01,F
13A2:  DECFSZ x6F,F
13A4:  BRA    1394
13A6:  MOVLB  0
13A8:  RETURN 0
13AA:  MOVLW  80
13AC:  BTFSS  FD8.1
13AE:  BRA    13B4
13B0:  MOVLB  2
13B2:  XORWF  x98,F
13B4:  MOVLB  2
13B6:  CLRF   x9D
13B8:  CLRF   x9E
13BA:  MOVFF  294,29C
13BE:  MOVF   x98,W
13C0:  XORWF  x9C,F
13C2:  MOVF   x93,W
13C4:  BTFSC  FD8.2
13C6:  BRA    1586
13C8:  MOVWF  x9B
13CA:  MOVWF  00
13CC:  MOVF   x97,W
13CE:  BTFSC  FD8.2
13D0:  BRA    1598
13D2:  SUBWF  x9B,F
13D4:  BTFSC  FD8.2
13D6:  BRA    14DE
13D8:  BNC   1456
13DA:  MOVFF  298,2A1
13DE:  BSF    xA1.7
13E0:  MOVFF  299,2A0
13E4:  MOVFF  29A,29F
13E8:  CLRF   x9E
13EA:  BCF    FD8.0
13EC:  RRCF   xA1,F
13EE:  RRCF   xA0,F
13F0:  RRCF   x9F,F
13F2:  RRCF   x9E,F
13F4:  DECFSZ x9B,F
13F6:  BRA    13E8
13F8:  BTFSS  x9C.7
13FA:  BRA    1402
13FC:  BSF    x9D.0
13FE:  BRA    15C0
1400:  BCF    x9D.0
1402:  BCF    x9B.0
1404:  BSF    x9D.4
1406:  MOVLW  02
1408:  MOVWF  FEA
140A:  MOVLW  96
140C:  MOVWF  FE9
140E:  BRA    15E6
1410:  BCF    x9D.4
1412:  BTFSC  x9C.7
1414:  BRA    142A
1416:  BTFSS  x9B.0
1418:  BRA    1440
141A:  RRCF   xA1,F
141C:  RRCF   xA0,F
141E:  RRCF   x9F,F
1420:  RRCF   x9E,F
1422:  INCF   00,F
1424:  BTFSC  FD8.2
1426:  BRA    15B6
1428:  BRA    1440
142A:  BTFSC  xA1.7
142C:  BRA    1446
142E:  BCF    FD8.0
1430:  RLCF   x9E,F
1432:  RLCF   x9F,F
1434:  RLCF   xA0,F
1436:  RLCF   xA1,F
1438:  DECF   00,F
143A:  BTFSC  FD8.2
143C:  BRA    15B6
143E:  BRA    142A
1440:  BSF    x9D.6
1442:  BRA    151E
1444:  BCF    x9D.6
1446:  MOVFF  294,29C
144A:  BTFSS  x94.7
144C:  BRA    1452
144E:  BSF    xA1.7
1450:  BRA    15A8
1452:  BCF    xA1.7
1454:  BRA    15A8
1456:  MOVFF  297,29B
145A:  MOVFF  297,00
145E:  MOVF   x93,W
1460:  SUBWF  x9B,F
1462:  MOVFF  294,2A1
1466:  BSF    xA1.7
1468:  MOVFF  295,2A0
146C:  MOVFF  296,29F
1470:  CLRF   x9E
1472:  BCF    FD8.0
1474:  RRCF   xA1,F
1476:  RRCF   xA0,F
1478:  RRCF   x9F,F
147A:  RRCF   x9E,F
147C:  DECFSZ x9B,F
147E:  BRA    1470
1480:  BTFSS  x9C.7
1482:  BRA    148A
1484:  BSF    x9D.1
1486:  BRA    15C0
1488:  BCF    x9D.1
148A:  BCF    x9B.0
148C:  BSF    x9D.5
148E:  MOVLW  02
1490:  MOVWF  FEA
1492:  MOVLW  9A
1494:  MOVWF  FE9
1496:  BRA    15E6
1498:  BCF    x9D.5
149A:  BTFSC  x9C.7
149C:  BRA    14B2
149E:  BTFSS  x9B.0
14A0:  BRA    14C8
14A2:  RRCF   xA1,F
14A4:  RRCF   xA0,F
14A6:  RRCF   x9F,F
14A8:  RRCF   x9E,F
14AA:  INCF   00,F
14AC:  BTFSC  FD8.2
14AE:  BRA    15B6
14B0:  BRA    14C8
14B2:  BTFSC  xA1.7
14B4:  BRA    14CE
14B6:  BCF    FD8.0
14B8:  RLCF   x9E,F
14BA:  RLCF   x9F,F
14BC:  RLCF   xA0,F
14BE:  RLCF   xA1,F
14C0:  DECF   00,F
14C2:  BTFSC  FD8.2
14C4:  BRA    15B6
14C6:  BRA    14B2
14C8:  BSF    x9D.7
14CA:  BRA    151E
14CC:  BCF    x9D.7
14CE:  MOVFF  298,29C
14D2:  BTFSS  x98.7
14D4:  BRA    14DA
14D6:  BSF    xA1.7
14D8:  BRA    15A8
14DA:  BCF    xA1.7
14DC:  BRA    15A8
14DE:  MOVFF  298,2A1
14E2:  BSF    xA1.7
14E4:  MOVFF  299,2A0
14E8:  MOVFF  29A,29F
14EC:  BTFSS  x9C.7
14EE:  BRA    14F8
14F0:  BCF    xA1.7
14F2:  BSF    x9D.2
14F4:  BRA    15C0
14F6:  BCF    x9D.2
14F8:  CLRF   x9E
14FA:  BCF    x9B.0
14FC:  MOVLW  02
14FE:  MOVWF  FEA
1500:  MOVLW  96
1502:  MOVWF  FE9
1504:  BRA    15E6
1506:  BTFSC  x9C.7
1508:  BRA    1542
150A:  MOVFF  294,29C
150E:  BTFSS  x9B.0
1510:  BRA    151E
1512:  RRCF   xA1,F
1514:  RRCF   xA0,F
1516:  RRCF   x9F,F
1518:  RRCF   x9E,F
151A:  INCF   00,F
151C:  BZ    15B6
151E:  BTFSS  x9E.7
1520:  BRA    1538
1522:  INCF   x9F,F
1524:  BNZ   1538
1526:  INCF   xA0,F
1528:  BNZ   1538
152A:  INCF   xA1,F
152C:  BNZ   1538
152E:  RRCF   xA1,F
1530:  RRCF   xA0,F
1532:  RRCF   x9F,F
1534:  INCF   00,F
1536:  BZ    15B6
1538:  BTFSC  x9D.6
153A:  BRA    1444
153C:  BTFSC  x9D.7
153E:  BRA    14CC
1540:  BRA    157A
1542:  MOVLW  80
1544:  XORWF  xA1,F
1546:  BTFSS  xA1.7
1548:  BRA    1552
154A:  BRA    15C0
154C:  MOVFF  298,29C
1550:  BRA    1566
1552:  MOVFF  294,29C
1556:  MOVF   xA1,F
1558:  BNZ   1566
155A:  MOVF   xA0,F
155C:  BNZ   1566
155E:  MOVF   x9F,F
1560:  BNZ   1566
1562:  CLRF   00
1564:  BRA    15A8
1566:  BTFSC  xA1.7
1568:  BRA    157A
156A:  BCF    FD8.0
156C:  RLCF   x9E,F
156E:  RLCF   x9F,F
1570:  RLCF   xA0,F
1572:  RLCF   xA1,F
1574:  DECFSZ 00,F
1576:  BRA    1566
1578:  BRA    15B6
157A:  BTFSS  x9C.7
157C:  BRA    1582
157E:  BSF    xA1.7
1580:  BRA    15A8
1582:  BCF    xA1.7
1584:  BRA    15A8
1586:  MOVFF  297,00
158A:  MOVFF  298,2A1
158E:  MOVFF  299,2A0
1592:  MOVFF  29A,29F
1596:  BRA    15A8
1598:  MOVFF  293,00
159C:  MOVFF  294,2A1
15A0:  MOVFF  295,2A0
15A4:  MOVFF  296,29F
15A8:  MOVFF  2A1,01
15AC:  MOVFF  2A0,02
15B0:  MOVFF  29F,03
15B4:  BRA    161E
15B6:  CLRF   00
15B8:  CLRF   01
15BA:  CLRF   02
15BC:  CLRF   03
15BE:  BRA    161E
15C0:  CLRF   x9E
15C2:  COMF   x9F,F
15C4:  COMF   xA0,F
15C6:  COMF   xA1,F
15C8:  COMF   x9E,F
15CA:  INCF   x9E,F
15CC:  BNZ   15D8
15CE:  INCF   x9F,F
15D0:  BNZ   15D8
15D2:  INCF   xA0,F
15D4:  BNZ   15D8
15D6:  INCF   xA1,F
15D8:  BTFSC  x9D.0
15DA:  BRA    1400
15DC:  BTFSC  x9D.1
15DE:  BRA    1488
15E0:  BTFSC  x9D.2
15E2:  BRA    14F6
15E4:  BRA    154C
15E6:  MOVF   FEF,W
15E8:  ADDWF  x9F,F
15EA:  BNC   15F6
15EC:  INCF   xA0,F
15EE:  BNZ   15F6
15F0:  INCF   xA1,F
15F2:  BTFSC  FD8.2
15F4:  BSF    x9B.0
15F6:  MOVF   FED,F
15F8:  MOVF   FEF,W
15FA:  ADDWF  xA0,F
15FC:  BNC   1604
15FE:  INCF   xA1,F
1600:  BTFSC  FD8.2
1602:  BSF    x9B.0
1604:  MOVF   FED,F
1606:  MOVF   FEF,W
1608:  BTFSC  FEF.7
160A:  BRA    160E
160C:  XORLW  80
160E:  ADDWF  xA1,F
1610:  BTFSC  FD8.0
1612:  BSF    x9B.0
1614:  BTFSC  x9D.4
1616:  BRA    1410
1618:  BTFSC  x9D.5
161A:  BRA    1498
161C:  BRA    1506
161E:  MOVLB  0
1620:  RETURN 0
*
16E0:  MOVLB  2
16E2:  MOVF   x93,W
16E4:  BTFSC  FD8.2
16E6:  BRA    17CA
16E8:  MOVWF  00
16EA:  MOVF   x97,W
16EC:  BTFSC  FD8.2
16EE:  BRA    17CA
16F0:  ADDWF  00,F
16F2:  BNC   16FC
16F4:  MOVLW  81
16F6:  ADDWF  00,F
16F8:  BC    17CA
16FA:  BRA    1704
16FC:  MOVLW  7F
16FE:  SUBWF  00,F
1700:  BNC   17CA
1702:  BZ    17CA
1704:  MOVFF  294,29B
1708:  MOVF   x98,W
170A:  XORWF  x9B,F
170C:  BSF    x94.7
170E:  BSF    x98.7
1710:  MOVF   x96,W
1712:  MULWF  x9A
1714:  MOVFF  FF4,29D
1718:  MOVF   x95,W
171A:  MULWF  x99
171C:  MOVFF  FF4,03
1720:  MOVFF  FF3,29C
1724:  MULWF  x9A
1726:  MOVF   FF3,W
1728:  ADDWF  x9D,F
172A:  MOVF   FF4,W
172C:  ADDWFC x9C,F
172E:  MOVLW  00
1730:  ADDWFC 03,F
1732:  MOVF   x96,W
1734:  MULWF  x99
1736:  MOVF   FF3,W
1738:  ADDWF  x9D,F
173A:  MOVF   FF4,W
173C:  ADDWFC x9C,F
173E:  MOVLW  00
1740:  CLRF   02
1742:  ADDWFC 03,F
1744:  ADDWFC 02,F
1746:  MOVF   x94,W
1748:  MULWF  x9A
174A:  MOVF   FF3,W
174C:  ADDWF  x9C,F
174E:  MOVF   FF4,W
1750:  ADDWFC 03,F
1752:  MOVLW  00
1754:  ADDWFC 02,F
1756:  MOVF   x94,W
1758:  MULWF  x99
175A:  MOVF   FF3,W
175C:  ADDWF  03,F
175E:  MOVF   FF4,W
1760:  ADDWFC 02,F
1762:  MOVLW  00
1764:  CLRF   01
1766:  ADDWFC 01,F
1768:  MOVF   x96,W
176A:  MULWF  x98
176C:  MOVF   FF3,W
176E:  ADDWF  x9C,F
1770:  MOVF   FF4,W
1772:  ADDWFC 03,F
1774:  MOVLW  00
1776:  ADDWFC 02,F
1778:  ADDWFC 01,F
177A:  MOVF   x95,W
177C:  MULWF  x98
177E:  MOVF   FF3,W
1780:  ADDWF  03,F
1782:  MOVF   FF4,W
1784:  ADDWFC 02,F
1786:  MOVLW  00
1788:  ADDWFC 01,F
178A:  MOVF   x94,W
178C:  MULWF  x98
178E:  MOVF   FF3,W
1790:  ADDWF  02,F
1792:  MOVF   FF4,W
1794:  ADDWFC 01,F
1796:  INCF   00,F
1798:  BTFSC  01.7
179A:  BRA    17A6
179C:  RLCF   x9C,F
179E:  RLCF   03,F
17A0:  RLCF   02,F
17A2:  RLCF   01,F
17A4:  DECF   00,F
17A6:  MOVLW  00
17A8:  BTFSS  x9C.7
17AA:  BRA    17C0
17AC:  INCF   03,F
17AE:  ADDWFC 02,F
17B0:  ADDWFC 01,F
17B2:  MOVF   01,W
17B4:  BNZ   17C0
17B6:  MOVF   02,W
17B8:  BNZ   17C0
17BA:  MOVF   03,W
17BC:  BNZ   17C0
17BE:  INCF   00,F
17C0:  BTFSC  x9B.7
17C2:  BSF    01.7
17C4:  BTFSS  x9B.7
17C6:  BCF    01.7
17C8:  BRA    17D2
17CA:  CLRF   00
17CC:  CLRF   01
17CE:  CLRF   02
17D0:  CLRF   03
17D2:  MOVLB  0
17D4:  RETURN 0
*
18C2:  MOVFF  290,297
18C6:  MOVLB  2
18C8:  MOVF   x94,W
18CA:  XORWF  x97,F
18CC:  BTFSS  x97.7
18CE:  BRA    18DA
18D0:  BCF    FD8.2
18D2:  BCF    FD8.0
18D4:  BTFSC  x90.7
18D6:  BSF    FD8.0
18D8:  BRA    1938
18DA:  MOVFF  290,297
18DE:  MOVFF  293,298
18E2:  MOVF   x8F,W
18E4:  SUBWF  x98,F
18E6:  BZ    18F4
18E8:  BTFSS  x97.7
18EA:  BRA    1938
18EC:  MOVF   FD8,W
18EE:  XORLW  01
18F0:  MOVWF  FD8
18F2:  BRA    1938
18F4:  MOVFF  294,298
18F8:  MOVF   x90,W
18FA:  SUBWF  x98,F
18FC:  BZ    190A
18FE:  BTFSS  x97.7
1900:  BRA    1938
1902:  MOVF   FD8,W
1904:  XORLW  01
1906:  MOVWF  FD8
1908:  BRA    1938
190A:  MOVFF  295,298
190E:  MOVF   x91,W
1910:  SUBWF  x98,F
1912:  BZ    1920
1914:  BTFSS  x97.7
1916:  BRA    1938
1918:  MOVF   FD8,W
191A:  XORLW  01
191C:  MOVWF  FD8
191E:  BRA    1938
1920:  MOVFF  296,298
1924:  MOVF   x92,W
1926:  SUBWF  x98,F
1928:  BZ    1936
192A:  BTFSS  x97.7
192C:  BRA    1938
192E:  MOVF   FD8,W
1930:  XORLW  01
1932:  MOVWF  FD8
1934:  BRA    1938
1936:  BCF    FD8.0
1938:  MOVLB  0
193A:  RETURN 0
193C:  MOVLB  2
193E:  MOVF   x5D,W
1940:  ANDLW  07
1942:  MOVWF  00
1944:  RRCF   x5D,W
1946:  MOVWF  01
1948:  RRCF   01,F
194A:  RRCF   01,F
194C:  MOVLW  1F
194E:  ANDWF  01,F
1950:  MOVF   01,W
1952:  ADDWF  x5F,W
1954:  MOVWF  FE9
1956:  MOVLW  00
1958:  ADDWFC x60,W
195A:  MOVWF  FEA
195C:  CLRF   01
195E:  INCF   01,F
1960:  INCF   00,F
1962:  BRA    1966
1964:  RLCF   01,F
1966:  DECFSZ 00,F
1968:  BRA    1964
196A:  MOVF   x5E,F
196C:  BZ    1974
196E:  MOVF   01,W
1970:  IORWF  FEF,F
1972:  BRA    197A
1974:  COMF   01,F
1976:  MOVF   01,W
1978:  ANDWF  FEF,F
197A:  MOVLB  0
197C:  RETURN 0
*
1D44:  MOVLB  2
1D46:  MOVF   x5D,W
1D48:  ANDLW  07
1D4A:  MOVWF  00
1D4C:  RRCF   x5D,W
1D4E:  MOVWF  01
1D50:  RRCF   01,F
1D52:  RRCF   01,F
1D54:  MOVLW  1F
1D56:  ANDWF  01,F
1D58:  MOVF   01,W
1D5A:  ADDWF  x5E,W
1D5C:  MOVWF  FE9
1D5E:  MOVLW  00
1D60:  ADDWFC x5F,W
1D62:  MOVWF  FEA
1D64:  MOVFF  FEF,01
1D68:  INCF   00,F
1D6A:  BRA    1D6E
1D6C:  RRCF   01,F
1D6E:  DECFSZ 00,F
1D70:  BRA    1D6C
1D72:  MOVLW  01
1D74:  ANDWF  01,F
1D76:  MOVLB  0
1D78:  RETURN 0
*
203A:  MOVFF  217,FEA
203E:  MOVFF  216,FE9
2042:  MOVLB  2
2044:  MOVFF  274,FEF
2048:  INCF   FE9,F
204A:  BTFSC  FD8.2
204C:  INCF   FEA,F
204E:  CLRF   FEF
2050:  INCF   x16,F
2052:  BTFSC  FD8.2
2054:  INCF   x17,F
2056:  MOVLB  0
2058:  RETURN 0
205A:  MOVFF  FEA,273
205E:  MOVFF  FE9,272
2062:  MOVLB  2
2064:  SWAPF  x6C,W
2066:  IORLW  F0
2068:  MOVWF  x6E
206A:  ADDWF  x6E,F
206C:  ADDLW  E2
206E:  MOVWF  x6F
2070:  ADDLW  32
2072:  MOVWF  x71
2074:  MOVF   x6C,W
2076:  ANDLW  0F
2078:  ADDWF  x6F,F
207A:  ADDWF  x6F,F
207C:  ADDWF  x71,F
207E:  ADDLW  E9
2080:  MOVWF  x70
2082:  ADDWF  x70,F
2084:  ADDWF  x70,F
2086:  SWAPF  x6B,W
2088:  ANDLW  0F
208A:  ADDWF  x70,F
208C:  ADDWF  x71,F
208E:  RLCF   x70,F
2090:  RLCF   x71,F
2092:  COMF   x71,F
2094:  RLCF   x71,F
2096:  MOVF   x6B,W
2098:  ANDLW  0F
209A:  ADDWF  x71,F
209C:  RLCF   x6E,F
209E:  MOVLW  07
20A0:  MOVWF  x6D
20A2:  MOVLW  0A
20A4:  DECF   x70,F
20A6:  ADDWF  x71,F
20A8:  BNC   20A4
20AA:  DECF   x6F,F
20AC:  ADDWF  x70,F
20AE:  BNC   20AA
20B0:  DECF   x6E,F
20B2:  ADDWF  x6F,F
20B4:  BNC   20B0
20B6:  DECF   x6D,F
20B8:  ADDWF  x6E,F
20BA:  BNC   20B6
20BC:  MOVLW  02
20BE:  MOVWF  FEA
20C0:  MOVLW  6D
20C2:  MOVWF  FE9
20C4:  MOVLW  07
20C6:  ANDWF  x72,W
20C8:  BCF    x72.6
20CA:  ADDWF  FE9,F
20CC:  MOVLW  00
20CE:  ADDWFC FEA,F
20D0:  MOVF   FE9,W
20D2:  SUBLW  71
20D4:  BNZ   20DE
20D6:  MOVF   FEA,W
20D8:  SUBLW  02
20DA:  BNZ   20DE
20DC:  BSF    x72.6
20DE:  MOVF   FEF,W
20E0:  MOVWF  00
20E2:  BNZ   20F4
20E4:  BTFSC  x72.6
20E6:  BRA    20F4
20E8:  BTFSC  x72.4
20EA:  BRA    2116
20EC:  BTFSC  x72.3
20EE:  BRA    20F4
20F0:  MOVLW  20
20F2:  BRA    20FA
20F4:  BSF    x72.3
20F6:  BCF    x72.4
20F8:  MOVLW  30
20FA:  ADDWF  00,F
20FC:  MOVFF  FEA,26C
2100:  MOVFF  FE9,26B
2104:  MOVFF  00,274
2108:  MOVLB  0
210A:  RCALL  203A
210C:  MOVFF  26C,FEA
2110:  MOVFF  26B,FE9
2114:  MOVLB  2
2116:  MOVF   FEE,W
2118:  BTFSS  x72.6
211A:  BRA    20D0
211C:  MOVLB  0
211E:  GOTO   21CC (RETURN)
2122:  MOVF   01,W
2124:  MOVFF  26B,26D
2128:  MOVLW  64
212A:  MOVLB  2
212C:  MOVWF  x6E
212E:  MOVLB  0
2130:  CALL   137E
2134:  MOVFF  00,26B
2138:  MOVF   01,W
213A:  MOVLW  30
213C:  BNZ   214E
213E:  MOVLB  2
2140:  BTFSS  x6C.1
2142:  BRA    2162
2144:  BTFSC  x6C.3
2146:  BRA    2162
2148:  BTFSC  x6C.4
214A:  MOVLW  20
214C:  BRA    2156
214E:  MOVLB  2
2150:  BCF    x6C.3
2152:  BCF    x6C.4
2154:  BSF    x6C.0
2156:  ADDWF  01,F
2158:  MOVFF  01,274
215C:  MOVLB  0
215E:  RCALL  203A
2160:  MOVLB  2
2162:  MOVFF  26B,26D
2166:  MOVLW  0A
2168:  MOVWF  x6E
216A:  MOVLB  0
216C:  CALL   137E
2170:  MOVFF  00,26B
2174:  MOVF   01,W
2176:  MOVLW  30
2178:  BNZ   218A
217A:  MOVLB  2
217C:  BTFSC  x6C.3
217E:  BRA    2194
2180:  BTFSS  x6C.0
2182:  BRA    2194
2184:  BTFSC  x6C.4
2186:  MOVLW  20
2188:  MOVLB  0
218A:  ADDWF  01,F
218C:  MOVFF  01,274
2190:  RCALL  203A
2192:  MOVLB  2
2194:  MOVLW  30
2196:  ADDWF  x6B,F
2198:  MOVFF  26B,274
219C:  MOVLB  0
219E:  RCALL  203A
21A0:  RETURN 0
.................... 
.................... #list
.................... 
.................... 
.................... #fuses NOLVP, NOPROTECT, NOMCLR, NOWDT
.................... #use delay(clock = 20M, crystal = 20M)
*
05EC:  MOVLW  02
05EE:  MOVWF  FEA
05F0:  MOVLW  60
05F2:  MOVWF  FE9
05F4:  MOVF   FEF,W
05F6:  BZ    0612
05F8:  MOVLW  06
05FA:  MOVWF  01
05FC:  CLRF   00
05FE:  DECFSZ 00,F
0600:  BRA    05FE
0602:  DECFSZ 01,F
0604:  BRA    05FC
0606:  MOVLW  7B
0608:  MOVWF  00
060A:  DECFSZ 00,F
060C:  BRA    060A
060E:  DECFSZ FEF,F
0610:  BRA    05F8
0612:  RETURN 0
.................... 
.................... #include <HDM64GS12.c>
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                           HDM64GS12.c                           ////
.................... ////                                                                 ////
.................... //// This file contains drivers for using a Hantronix HDM64GS12 with ////
.................... //// a KS0108 display controller. The HDM64GS12 is 128 by 64 pixels. ////
.................... //// The driver treats the upper left pixel as (0,0).                ////
.................... ////                                                                 ////
.................... //// Use #define FAST_GLCD if the target chip has at least 1k of RAM ////
.................... //// to decrease the time it takes to update the display.            ////
.................... //// glcd_update() must then be called to update the display after   ////
.................... //// changing the pixel information.                                 ////
.................... //// See ex_glcd.c for suggested usage.                              ////
.................... //// See KS0108.c for controlling a single 64 by 64 display          ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                                                                 ////
.................... //// LCD Pin connections:                                            ////
.................... //// (These can be changed as needed in the following defines).      ////
.................... ////  * 1: VSS is connected to GND                                   ////
.................... ////  * 2: VDD is connected to +5V                                   ////
.................... ////  * 3: V0  - LCD operating voltage (Contrast adjustment)         ////
.................... ////  * 4: D/I - Data or Instruction is connected to B2              ////
.................... ////  * 5: R/W - Read or Write is connected to B4                    ////
.................... ////  * 6: Enable is connected to B5                                 ////
.................... ////  *7-14: Data Bus 0 to 7 is connected to port d                  ////
.................... ////  *15: Chip Select 1 is connected to B0                          ////
.................... ////  *16: Chip Select 2 is connected to B1                          ////
.................... ////  *17: Reset is connected to C0                                  ////
.................... ////  *18: Negative voltage is also connected to the 20k Ohm POT     ////
.................... ////  *19: Positive voltage for LED backlight is connected to +5V    ////
.................... ////  *20: Negative voltage for LED backlight is connected to GND    ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                                                                 ////
.................... ////  glcd_init(mode)                                                ////
.................... ////     * Must be called before any other function.                 ////
.................... ////       - mode can be ON or OFF to turn the LCD on or off         ////
.................... ////                                                                 ////
.................... ////  glcd_pixel(x,y,color)                                          ////
.................... ////     * Sets the pixel to the given color.                        ////
.................... ////       - color can be ON or OFF                                  ////
.................... ////                                                                 ////
.................... ////  glcd_fillScreen(color)                                         ////
.................... ////     * Fills the entire LCD with the given color.                ////
.................... ////       - color can be ON or OFF                                  ////
.................... ////                                                                 ////
.................... ////  glcd_update()                                                  ////
.................... ////     * Write the display data stored in RAM to the LCD           ////
.................... ////     * Only available if FAST_GLCD is defined                    ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////  Version History                                                ////
.................... ////                                                                 ////
.................... ////  05/01/20 - Added defines to selecting the data bus port or     ////
.................... ////             pins used with this driver.                         ////
.................... ////                                                                 ////
.................... ////             GLCD_PORT - to assign the port to use for the GLCD  ////
.................... ////                 data bus pins, for example:                     ////
.................... ////                    #define GLCD_PORT    c                       ////
.................... ////                                                                 ////
.................... ////                 The above assigns it to use PORTC for the data  ////
.................... ////                 bus pins.  Driver defaults to PORTD if          ////
.................... ////                 GLCD_PORT and GLCD_DATA0 are not defined before ////
.................... ////                 this driver is included in project.             ////
.................... ////                                                                 ////
.................... ////             GLCD_DATA0 - to assign the data bus 0 pin.          ////
.................... ////                                                                 ////
.................... ////             GLCD_DATA1 - to assign the data bus 1 pin.          ////
.................... ////                                                                 ////
.................... ////             GLCD_DATA2 - to assign the data bus 2 pin.          ////
.................... ////                                                                 ////
.................... ////             GLCD_DATA3 - to assign the data bus 3 pin.          ////
.................... ////                                                                 ////
.................... ////             GLCD_DATA4 - to assign the data bus 4 pin.          ////
.................... ////                                                                 ////
.................... ////             GLCD_DATA5 - to assign the data bus 5 pin.          ////
.................... ////                                                                 ////
.................... ////             GLCD_DATA6 - to assign the data bus 6 pin.          ////
.................... ////                                                                 ////
.................... ////             GLCD_DATA7 - to assign the data bus 7 pin.          ////
.................... ////                                                                 ////
.................... ////     The defines GLCD_DATA0 to GLCD_DATA7 can only be used to    ////
.................... ////     assign the pins if GLCD_PORT is not defined.  All eight     ////
.................... ////     defines must be defined before this driver is included in   ////
.................... ////     project to make assignments.  No default defines are made   ////
.................... ////     for GLCD_DATA0 to GLCD_DATA7.                               ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services        ////
.................... //// This source code may only be used by licensed users of the CCS  ////
.................... //// C compiler.  This source code may only be distributed to other  ////
.................... //// licensed users of the CCS C compiler.  No other use,            ////
.................... //// reproduction or distribution is permitted without written       ////
.................... //// permission.  Derivative programs created using this software    ////
.................... //// in object code form are not restricted in any way.              ////
.................... /////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef HDM64GS12
.................... #define HDM64GS12
.................... 
.................... #ifndef concat
....................  #define concat(x,y)    x####y
.................... #endif
.................... 
.................... #ifndef GLCD_WIDTH
....................  #define GLCD_WIDTH     128
.................... #endif
.................... 
.................... #ifndef GLCD_CS1
....................  #define GLCD_CS1       PIN_B0   // Chip Selection 1
.................... #endif
.................... 
.................... #ifndef GLCD_CS2
....................  #define GLCD_CS2       PIN_B1   // Chip Selection 2
.................... #endif
.................... 
.................... #ifndef GLCD_DI
....................  #define GLCD_DI        PIN_B2   // Data or Instruction input
.................... #endif
.................... 
.................... #ifndef GLCD_RW
....................  #define GLCD_RW        PIN_B4   // Read/Write
.................... #endif
.................... 
.................... #ifndef GLCD_E
....................  #define GLCD_E         PIN_B5   // Enable
.................... #endif
.................... 
.................... #ifndef GLCD_RST
....................  #define GLCD_RST       PIN_C0   // Reset
.................... #endif
.................... 
.................... #if !defined(GLCD_PORT) && !defined(GLCD_DATA0)
....................  #define GLCD_PORT      d
.................... #elif !defined(GLCD_PORT) && defined(GLCD_DATA0)
....................  #if !defined(GLCD_DATA1) || !defined(GLCD_DATA2) || !defined(GLCD_DATA3) || !defined(GLCD_DATA4) || \
....................      !defined(GLCD_DATA5) || !defined(GLCD_DATA6) || !defined(GLCD_DATA7)
....................   #error not all GLCD Data pins defined.
....................  #endif
.................... #endif
.................... 
.................... #define GLCD_LEFT       0
.................... #define GLCD_RIGHT      1
.................... 
.................... #ifndef ON
....................  #define ON             1
.................... #endif
.................... 
.................... #ifndef OFF
....................  #define OFF            0
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////
.................... // Function Prototypes
.................... /////////////////////////////////////////////////////////////////////////
.................... void glcd_init(int1 mode);
.................... void glcd_pixel(unsigned int8 x, unsigned int8 y, int1 color);
.................... void glcd_fillScreen(int1 color);
.................... void glcd_writeByte(int1 side, BYTE data);
.................... BYTE glcd_readByte(int1 side);
.................... void glcd_update();
.................... /////////////////////////////////////////////////////////////////////////
.................... 
.................... #if defined(GLCD_PORT)
....................  #define WritePort(v)   concat(output_, GLCD_PORT(v))
....................  #define ReadPort()     concat(input_, GLCD_PORT())
....................  #define TrisPort(v)    concat(set_tris_, GLCD_PORT(v))
.................... #else
....................  #define TrisPort(v)
.................... 
....................  void WritePort(unsigned int8 value)
....................  {
....................    output_bit(GLCD_DATA0, bit_test(value, 0));
....................    output_bit(GLCD_DATA1, bit_test(value, 1));
....................    output_bit(GLCD_DATA2, bit_test(value, 2));
....................    output_bit(GLCD_DATA3, bit_test(value, 3));
....................    output_bit(GLCD_DATA4, bit_test(value, 4));
....................    output_bit(GLCD_DATA5, bit_test(value, 5));
....................    output_bit(GLCD_DATA6, bit_test(value, 6));
....................    output_bit(GLCD_DATA7, bit_test(value, 7));
....................  }
....................  
....................  unsigned int8 ReadPort(void)
....................  {
....................    union
....................    {
....................       unsigned int8 b;
....................       int1 bit[8];
....................    } Result;
....................    
....................    Result.bit[0] = input(GLCD_DATA0);
....................    Result.bit[1] = input(GLCD_DATA1);
....................    Result.bit[2] = input(GLCD_DATA2);
....................    Result.bit[3] = input(GLCD_DATA3);
....................    Result.bit[4] = input(GLCD_DATA4);
....................    Result.bit[5] = input(GLCD_DATA5);
....................    Result.bit[6] = input(GLCD_DATA6);
....................    Result.bit[7] = input(GLCD_DATA7);
....................    
....................    return(Result.b);
....................  } 
.................... #endif
.................... 
.................... #ifdef FAST_GLCD
.................... struct
.................... {
....................    unsigned int8 left[512];
....................    unsigned int8 right[512];
.................... } displayData;
.................... #endif
.................... 
.................... 
.................... // Purpose:       Initialize the LCD.
.................... //                Call before using any other LCD function.
.................... // Inputs:        OFF - Turns the LCD off
.................... //                ON  - Turns the LCD on
.................... void glcd_init(int1 mode)
.................... {
....................    // Initialize some pins
....................    output_high(GLCD_RST);
*
06DE:  BCF    F94.0
06E0:  BSF    F8B.0
....................    output_low(GLCD_E);
06E2:  BCF    F93.5
06E4:  BCF    F8A.5
....................    output_low(GLCD_CS1);
06E6:  BCF    F93.0
06E8:  BCF    F8A.0
....................    output_low(GLCD_CS2);
06EA:  BCF    F93.1
06EC:  BCF    F8A.1
.................... 
....................    output_low(GLCD_DI);                 // Set for instruction
06EE:  BCF    F93.2
06F0:  BCF    F8A.2
....................    glcd_writeByte(GLCD_LEFT,  0xC0);    // Specify first RAM line at the top
06F2:  MOVLB  2
06F4:  CLRF   x9C
06F6:  MOVLW  C0
06F8:  MOVWF  x9D
06FA:  MOVLB  0
06FC:  RCALL  0614
....................    glcd_writeByte(GLCD_RIGHT, 0xC0);    //   of the screen
06FE:  MOVLW  01
0700:  MOVLB  2
0702:  MOVWF  x9C
0704:  MOVLW  C0
0706:  MOVWF  x9D
0708:  MOVLB  0
070A:  RCALL  0614
....................    glcd_writeByte(GLCD_LEFT,  0x40);    // Set the column address to 0
070C:  MOVLB  2
070E:  CLRF   x9C
0710:  MOVLW  40
0712:  MOVWF  x9D
0714:  MOVLB  0
0716:  RCALL  0614
....................    glcd_writeByte(GLCD_RIGHT, 0x40);
0718:  MOVLW  01
071A:  MOVLB  2
071C:  MOVWF  x9C
071E:  MOVLW  40
0720:  MOVWF  x9D
0722:  MOVLB  0
0724:  RCALL  0614
....................    glcd_writeByte(GLCD_LEFT,  0xB8);    // Set the page address to 0
0726:  MOVLB  2
0728:  CLRF   x9C
072A:  MOVLW  B8
072C:  MOVWF  x9D
072E:  MOVLB  0
0730:  RCALL  0614
....................    glcd_writeByte(GLCD_RIGHT, 0xB8);
0732:  MOVLW  01
0734:  MOVLB  2
0736:  MOVWF  x9C
0738:  MOVLW  B8
073A:  MOVWF  x9D
073C:  MOVLB  0
073E:  RCALL  0614
.................... 
....................    if(mode == ON)
0740:  MOVLB  2
0742:  DECFSZ x5D,W
0744:  BRA    0762
....................    {
....................       glcd_writeByte(GLCD_LEFT,  0x3F); // Turn the display on
0746:  CLRF   x9C
0748:  MOVLW  3F
074A:  MOVWF  x9D
074C:  MOVLB  0
074E:  RCALL  0614
....................       glcd_writeByte(GLCD_RIGHT, 0x3F);
0750:  MOVLW  01
0752:  MOVLB  2
0754:  MOVWF  x9C
0756:  MOVLW  3F
0758:  MOVWF  x9D
075A:  MOVLB  0
075C:  RCALL  0614
....................    }
075E:  BRA    077A
0760:  MOVLB  2
....................    else
....................    {
....................       glcd_writeByte(GLCD_LEFT,  0x3E); // Turn the display off
0762:  CLRF   x9C
0764:  MOVLW  3E
0766:  MOVWF  x9D
0768:  MOVLB  0
076A:  RCALL  0614
....................       glcd_writeByte(GLCD_RIGHT, 0x3E);
076C:  MOVLW  01
076E:  MOVLB  2
0770:  MOVWF  x9C
0772:  MOVLW  3E
0774:  MOVWF  x9D
0776:  MOVLB  0
0778:  RCALL  0614
....................    }
.................... 
....................    glcd_fillScreen(OFF);                // Clear the display
077A:  MOVLB  2
077C:  CLRF   x73
077E:  MOVLB  0
0780:  RCALL  0658
.................... 
....................    #ifdef FAST_GLCD
0782:  GOTO   27F4 (RETURN)
....................    glcd_update();
....................    #endif
.................... }
.................... 
.................... 
.................... // Purpose:    Update the LCD with data from the display arrays
.................... #ifdef FAST_GLCD
.................... void glcd_update()
.................... {
....................    unsigned int8 i, j;
....................    unsigned int8 *p1, *p2;
.................... 
....................    p1 = displayData.left;
....................    p2 = displayData.right;
.................... 
....................    // Loop through the vertical pages
....................    for(i = 0; i < 8; ++i)
....................    {
....................       output_low(GLCD_DI);                      // Set for instruction
....................       glcd_writeByte(GLCD_LEFT, 0x40);          // Set horizontal address to 0
....................       glcd_writeByte(GLCD_RIGHT, 0x40);
....................       glcd_writeByte(GLCD_LEFT, i | 0xB8);      // Set page address
....................       glcd_writeByte(GLCD_RIGHT, i | 0xB8);
....................       output_high(GLCD_DI);                     // Set for data
.................... 
....................       // Loop through the horizontal sections
....................       for(j = 0; j < 64; ++j)
....................       {
....................          glcd_writeByte(GLCD_LEFT, *p1++);      // Turn pixels on or off
....................          glcd_writeByte(GLCD_RIGHT, *p2++);     // Turn pixels on or off
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... 
.................... // Purpose:    Turn a pixel on a graphic LCD on or off
.................... // Inputs:     1) x - the x coordinate of the pixel
.................... //             2) y - the y coordinate of the pixel
.................... //             3) color - ON or OFF
.................... void glcd_pixel(unsigned int8 x, unsigned int8 y, int1 color)
.................... #ifdef FAST_GLCD
*
07C8:  MOVLB  2
07CA:  BCF    x99.0
.................... {
....................    unsigned int8* p;
....................    unsigned int16 temp;
....................    temp =  y/8;
....................    temp *= 64;
....................    temp += x;
.................... 
....................    if(x > 63)
....................    {
....................       p = displayData.right + temp - 64;
....................    }
....................    else
....................    {
....................       p = displayData.left + temp;
....................    }
.................... 
....................    if(color)
....................    {
....................       bit_set(*p, y%8);
....................    }
....................    else
....................    {
....................       bit_clear(*p, y%8);
....................    }
.................... }
.................... #else
.................... {
....................    BYTE data;
....................    int1 side = GLCD_LEFT;  // Stores which chip to use on the LCD
.................... 
....................    if(x > 63)              // Check for first or second display area
07CC:  MOVF   x95,W
07CE:  SUBLW  3F
07D0:  BC    07D8
....................    {
....................       x -= 64;
07D2:  MOVLW  40
07D4:  SUBWF  x95,F
....................       side = GLCD_RIGHT;
07D6:  BSF    x99.0
....................    }
.................... 
....................    output_low(GLCD_DI);                         // Set for instruction
07D8:  BCF    F93.2
07DA:  BCF    F8A.2
....................    bit_clear(x,7);                              // Clear the MSB. Part of an instruction code
07DC:  BCF    x95.7
....................    bit_set(x,6);                                // Set bit 6. Also part of an instruction code
07DE:  BSF    x95.6
....................    glcd_writeByte(side, x);                     // Set the horizontal address
07E0:  MOVLW  00
07E2:  BTFSC  x99.0
07E4:  MOVLW  01
07E6:  MOVWF  x9A
07E8:  MOVWF  x9C
07EA:  MOVFF  295,29D
07EE:  MOVLB  0
07F0:  RCALL  0614
....................    glcd_writeByte(side, (y/8 & 0xBF) | 0xB8);   // Set the vertical page address
07F2:  MOVLW  00
07F4:  MOVLB  2
07F6:  BTFSC  x99.0
07F8:  MOVLW  01
07FA:  MOVWF  x9A
07FC:  RRCF   x96,W
07FE:  MOVWF  00
0800:  RRCF   00,F
0802:  RRCF   00,F
0804:  MOVLW  1F
0806:  ANDWF  00,F
0808:  MOVF   00,W
080A:  ANDLW  BF
080C:  IORLW  B8
080E:  MOVWF  x9B
0810:  MOVFF  29A,29C
0814:  MOVWF  x9D
0816:  MOVLB  0
0818:  RCALL  0614
....................    output_high(GLCD_DI);                        // Set for data
081A:  BCF    F93.2
081C:  BSF    F8A.2
....................    glcd_readByte(side);                         // Need two reads to get data
081E:  MOVLW  00
0820:  MOVLB  2
0822:  BTFSC  x99.0
0824:  MOVLW  01
0826:  MOVWF  x9A
0828:  MOVWF  x9B
082A:  MOVLB  0
082C:  RCALL  0786
....................    data = glcd_readByte(side);                  //  at new address
082E:  MOVLW  00
0830:  MOVLB  2
0832:  BTFSC  x99.0
0834:  MOVLW  01
0836:  MOVWF  x9A
0838:  MOVWF  x9B
083A:  MOVLB  0
083C:  RCALL  0786
083E:  MOVFF  01,298
.................... 
....................    if(color == ON)
0842:  MOVLB  2
0844:  DECFSZ x97,W
0846:  BRA    0866
....................       bit_set(data, y%8);        // Turn the pixel on
0848:  MOVF   x96,W
084A:  ANDLW  07
084C:  MOVWF  x9A
084E:  MOVLW  01
0850:  MOVWF  00
0852:  MOVF   x9A,W
0854:  MOVWF  01
0856:  BZ    0860
0858:  BCF    FD8.0
085A:  RLCF   00,F
085C:  DECFSZ 01,F
085E:  BRA    0858
0860:  MOVF   00,W
0862:  IORWF  x98,F
0864:  BRA    0884
....................    else                          // or
....................       bit_clear(data, y%8);      // turn the pixel off
0866:  MOVF   x96,W
0868:  ANDLW  07
086A:  MOVWF  x9A
086C:  MOVLW  01
086E:  MOVWF  00
0870:  MOVF   x9A,W
0872:  MOVWF  01
0874:  BZ    087E
0876:  BCF    FD8.0
0878:  RLCF   00,F
087A:  DECFSZ 01,F
087C:  BRA    0876
087E:  MOVF   00,W
0880:  XORLW  FF
0882:  ANDWF  x98,F
.................... 
....................    output_low(GLCD_DI);          // Set for instruction
0884:  BCF    F93.2
0886:  BCF    F8A.2
....................    glcd_writeByte(side, x);      // Set the horizontal address
0888:  MOVLW  00
088A:  BTFSC  x99.0
088C:  MOVLW  01
088E:  MOVWF  x9A
0890:  MOVWF  x9C
0892:  MOVFF  295,29D
0896:  MOVLB  0
0898:  RCALL  0614
....................    output_high(GLCD_DI);         // Set for data
089A:  BCF    F93.2
089C:  BSF    F8A.2
....................    glcd_writeByte(side, data);   // Write the pixel data
089E:  MOVLW  00
08A0:  MOVLB  2
08A2:  BTFSC  x99.0
08A4:  MOVLW  01
08A6:  MOVWF  x9A
08A8:  MOVWF  x9C
08AA:  MOVFF  298,29D
08AE:  MOVLB  0
08B0:  RCALL  0614
08B2:  RETURN 0
.................... }
.................... #endif
.................... 
.................... 
.................... // Purpose:    Fill the LCD screen with the passed in color
.................... // Inputs:     ON  - turn all the pixels on
.................... //             OFF - turn all the pixels off
.................... void glcd_fillScreen(int1 color)
.................... #ifdef FAST_GLCD
.................... {
....................    unsigned int8  data;
....................    unsigned int8  *p1, *p2;
....................    unsigned int16 i;
.................... 
....................    p1 = displayData.left;
....................    p2 = displayData.right;
....................    data = 0xFF * color;
.................... 
....................    for(i=0; i<512; ++i)
....................    {
....................       *p1++ = data;
....................       *p2++ = data;
....................    }
.................... }
.................... #else
.................... {
....................    unsigned int8 i, j;
.................... 
....................    // Loop through the vertical pages
....................    for(i = 0; i < 8; ++i)
*
0658:  MOVLB  2
065A:  CLRF   x74
065C:  MOVF   x74,W
065E:  SUBLW  07
0660:  BNC   06DA
....................    {
....................       output_low(GLCD_DI);                      // Set for instruction
0662:  BCF    F93.2
0664:  BCF    F8A.2
....................       glcd_writeByte(GLCD_LEFT, 0b01000000);    // Set horizontal address to 0
0666:  CLRF   x9C
0668:  MOVLW  40
066A:  MOVWF  x9D
066C:  MOVLB  0
066E:  RCALL  0614
....................       glcd_writeByte(GLCD_RIGHT, 0b01000000);
0670:  MOVLW  01
0672:  MOVLB  2
0674:  MOVWF  x9C
0676:  MOVLW  40
0678:  MOVWF  x9D
067A:  MOVLB  0
067C:  RCALL  0614
....................       glcd_writeByte(GLCD_LEFT, i | 0b10111000);// Set page address
067E:  MOVLB  2
0680:  MOVF   x74,W
0682:  IORLW  B8
0684:  MOVWF  x76
0686:  CLRF   x9C
0688:  MOVWF  x9D
068A:  MOVLB  0
068C:  RCALL  0614
....................       glcd_writeByte(GLCD_RIGHT, i | 0b10111000);
068E:  MOVLB  2
0690:  MOVF   x74,W
0692:  IORLW  B8
0694:  MOVWF  x76
0696:  MOVLW  01
0698:  MOVWF  x9C
069A:  MOVFF  276,29D
069E:  MOVLB  0
06A0:  RCALL  0614
....................       output_high(GLCD_DI);                     // Set for data
06A2:  BCF    F93.2
06A4:  BSF    F8A.2
.................... 
....................       // Loop through the horizontal sections
....................       for(j = 0; j < 64; ++j)
06A6:  MOVLB  2
06A8:  CLRF   x75
06AA:  MOVF   x75,W
06AC:  SUBLW  3F
06AE:  BNC   06D6
....................       {
....................          glcd_writeByte(GLCD_LEFT, 0xFF*color);  // Turn pixels on or off
06B0:  MOVF   x73,W
06B2:  MULLW  FF
06B4:  MOVFF  FF3,29D
06B8:  CLRF   x9C
06BA:  MOVLB  0
06BC:  RCALL  0614
....................          glcd_writeByte(GLCD_RIGHT, 0xFF*color); // Turn pixels on or off
06BE:  MOVLB  2
06C0:  MOVF   x73,W
06C2:  MULLW  FF
06C4:  MOVFF  FF3,29D
06C8:  MOVLW  01
06CA:  MOVWF  x9C
06CC:  MOVLB  0
06CE:  RCALL  0614
06D0:  MOVLB  2
06D2:  INCF   x75,F
06D4:  BRA    06AA
....................       }
06D6:  INCF   x74,F
06D8:  BRA    065C
....................    }
06DA:  MOVLB  0
06DC:  RETURN 0
.................... }
.................... #endif
.................... 
.................... 
.................... // Purpose:    Write a byte of data to the specified chip
.................... // Inputs:     1) chipSelect - which chip to write the data to
.................... //             2) data - the byte of data to write
.................... void glcd_writeByte(int1 side, BYTE data)
.................... {
....................    TrisPort(0x00);
*
0614:  MOVLW  00
0616:  MOVWF  F95
....................    
....................    output_low(GLCD_RW);       // Set for writing
0618:  BCF    F93.4
061A:  BCF    F8A.4
.................... 
....................     if(side)                   // Choose which side to write to
061C:  MOVLB  2
061E:  MOVF   x9C,F
0620:  BZ    0628
....................       output_high(GLCD_CS2);
0622:  BCF    F93.1
0624:  BSF    F8A.1
0626:  BRA    062C
....................    else
....................       output_high(GLCD_CS1);
0628:  BCF    F93.0
062A:  BSF    F8A.0
.................... 
....................     delay_us(1);
062C:  BRA    062E
062E:  BRA    0630
0630:  NOP   
.................... 
....................    WritePort(data);           // Put the data on the port
0632:  CLRF   F95
0634:  MOVFF  29D,F8C
....................    delay_us(1);
0638:  BRA    063A
063A:  BRA    063C
063C:  NOP   
....................    output_high(GLCD_E);       // Pulse the enable pin
063E:  BCF    F93.5
0640:  BSF    F8A.5
....................    delay_us(1);
0642:  BRA    0644
0644:  BRA    0646
0646:  NOP   
....................    output_low(GLCD_E);
0648:  BCF    F93.5
064A:  BCF    F8A.5
.................... 
....................    output_low(GLCD_CS1);      // Reset the chip select lines
064C:  BCF    F93.0
064E:  BCF    F8A.0
....................    output_low(GLCD_CS2);
0650:  BCF    F93.1
0652:  BCF    F8A.1
0654:  MOVLB  0
0656:  RETURN 0
.................... }
.................... 
.................... 
.................... // Purpose:    Reads a byte of data from the specified chip
.................... // Outputs:     A byte of data read from the chip
.................... BYTE glcd_readByte(int1 side)
.................... {
....................    BYTE data;                 // Stores the data read from the LCD
.................... 
....................    TrisPort(0xFF);            // Set port to input
*
0786:  MOVLW  FF
0788:  MOVWF  F95
....................    output_high(GLCD_RW);      // Set for reading
078A:  BCF    F93.4
078C:  BSF    F8A.4
.................... 
....................    if(side)                   // Choose which side to write to
078E:  MOVLB  2
0790:  MOVF   x9B,F
0792:  BZ    079A
....................       output_high(GLCD_CS2);
0794:  BCF    F93.1
0796:  BSF    F8A.1
0798:  BRA    079E
....................    else
....................       output_high(GLCD_CS1);
079A:  BCF    F93.0
079C:  BSF    F8A.0
.................... 
....................    delay_us(1);
079E:  BRA    07A0
07A0:  BRA    07A2
07A2:  NOP   
....................    output_high(GLCD_E);       // Pulse the enable pin
07A4:  BCF    F93.5
07A6:  BSF    F8A.5
....................    delay_us(1);
07A8:  BRA    07AA
07AA:  BRA    07AC
07AC:  NOP   
....................    data = ReadPort();        // Get the data from the display's output register
07AE:  SETF   F95
07B0:  MOVFF  F83,29C
....................    output_low(GLCD_E);
07B4:  BCF    F93.5
07B6:  BCF    F8A.5
.................... 
....................    output_low(GLCD_CS1);      // Reset the chip select lines
07B8:  BCF    F93.0
07BA:  BCF    F8A.0
....................    output_low(GLCD_CS2);
07BC:  BCF    F93.1
07BE:  BCF    F8A.1
....................    return data;               // Return the read data
07C0:  MOVFF  29C,01
07C4:  MOVLB  0
07C6:  RETURN 0
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
*
197E:  MOVLB  2
1980:  CLRF   x74
1982:  CLRF   x73
1984:  CLRF   x72
1986:  MOVLW  7F
1988:  MOVWF  x71
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
198A:  MOVLW  7E
198C:  MOVWF  x7B
198E:  MOVLW  80
1990:  MOVWF  x7C
1992:  CLRF   x7D
1994:  CLRF   x7E
1996:  MOVLW  7A
1998:  MOVWF  x7F
199A:  MOVLW  2A
199C:  MOVWF  x80
199E:  MOVLW  AA
19A0:  MOVWF  x81
19A2:  MOVLW  A3
19A4:  MOVWF  x82
19A6:  MOVLW  75
19A8:  MOVWF  x83
19AA:  MOVLW  B6
19AC:  MOVWF  x84
19AE:  MOVLW  09
19B0:  MOVWF  x85
19B2:  MOVLW  B4
19B4:  MOVWF  x86
19B6:  MOVLW  6F
19B8:  MOVWF  x87
19BA:  MOVLW  4F
19BC:  MOVWF  x88
19BE:  MOVLW  B6
19C0:  MOVWF  x89
19C2:  MOVLW  AA
19C4:  MOVWF  x8A
19C6:  MOVLW  69
19C8:  MOVWF  x8B
19CA:  MOVLW  8B
19CC:  MOVWF  x8C
19CE:  MOVLW  F6
19D0:  MOVWF  x8D
19D2:  MOVLW  E8
19D4:  MOVWF  x8E
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
19D6:  MOVFF  268,292
19DA:  MOVFF  267,291
19DE:  MOVFF  266,290
19E2:  MOVFF  265,28F
19E6:  CLRF   x96
19E8:  CLRF   x95
19EA:  CLRF   x94
19EC:  CLRF   x93
19EE:  MOVLB  0
19F0:  RCALL  18C2
19F2:  BNC   19FE
19F4:  MOVLB  2
19F6:  MOVF   x66,W
19F8:  XORLW  80
19FA:  MOVWF  x66
19FC:  MOVLB  0
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
19FE:  MOVFF  268,296
1A02:  MOVFF  267,295
1A06:  MOVFF  266,294
1A0A:  MOVFF  265,293
1A0E:  MOVLW  83
1A10:  MOVLB  2
1A12:  MOVWF  x9A
1A14:  MOVLW  F9
1A16:  MOVWF  x99
1A18:  MOVLW  22
1A1A:  MOVWF  x98
1A1C:  MOVLW  7E
1A1E:  MOVWF  x97
1A20:  MOVLB  0
1A22:  RCALL  16E0
1A24:  MOVFF  03,292
1A28:  MOVFF  02,291
1A2C:  MOVFF  01,290
1A30:  MOVFF  00,28F
1A34:  RCALL  1342
1A36:  MOVFF  01,275
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
1A3A:  MOVFF  268,296
1A3E:  MOVFF  267,295
1A42:  MOVFF  266,294
1A46:  MOVFF  265,293
1A4A:  MOVLW  83
1A4C:  MOVLB  2
1A4E:  MOVWF  x9A
1A50:  MOVLW  F9
1A52:  MOVWF  x99
1A54:  MOVLW  22
1A56:  MOVWF  x98
1A58:  MOVLW  7E
1A5A:  MOVWF  x97
1A5C:  MOVLB  0
1A5E:  RCALL  16E0
1A60:  MOVFF  03,292
1A64:  MOVFF  02,291
1A68:  MOVFF  01,290
1A6C:  MOVFF  00,28F
1A70:  MOVLB  2
1A72:  CLRF   x94
1A74:  MOVFF  275,293
1A78:  MOVLB  0
1A7A:  CALL   11AE
1A7E:  BSF    FD8.1
1A80:  MOVFF  292,296
1A84:  MOVFF  291,295
1A88:  MOVFF  290,294
1A8C:  MOVFF  28F,293
1A90:  MOVFF  03,29A
1A94:  MOVFF  02,299
1A98:  MOVFF  01,298
1A9C:  MOVFF  00,297
1AA0:  RCALL  13AA
1AA2:  MOVFF  03,27A
1AA6:  MOVFF  02,279
1AAA:  MOVFF  01,278
1AAE:  MOVFF  00,277
....................    quad = quad % 4;                    // quadrant (0 to 3)
1AB2:  MOVLW  03
1AB4:  MOVLB  2
1AB6:  ANDWF  x75,F
.................... 
....................    if (quad == 0 || quad == 2)
1AB8:  MOVF   x75,F
1ABA:  BZ    1AC2
1ABC:  MOVF   x75,W
1ABE:  SUBLW  02
1AC0:  BNZ   1AFA
....................       t = frac * PI_DIV_BY_TWO;
1AC2:  MOVFF  27A,296
1AC6:  MOVFF  279,295
1ACA:  MOVFF  278,294
1ACE:  MOVFF  277,293
1AD2:  MOVLW  DB
1AD4:  MOVWF  x9A
1AD6:  MOVLW  0F
1AD8:  MOVWF  x99
1ADA:  MOVLW  49
1ADC:  MOVWF  x98
1ADE:  MOVLW  7F
1AE0:  MOVWF  x97
1AE2:  MOVLB  0
1AE4:  RCALL  16E0
1AE6:  MOVFF  03,270
1AEA:  MOVFF  02,26F
1AEE:  MOVFF  01,26E
1AF2:  MOVFF  00,26D
1AF6:  BRA    1BCE
1AF8:  MOVLB  2
....................    else if (quad == 1)
1AFA:  DECFSZ x75,W
1AFC:  BRA    1B68
....................       t = (1-frac) * PI_DIV_BY_TWO;
1AFE:  BSF    FD8.1
1B00:  CLRF   x96
1B02:  CLRF   x95
1B04:  CLRF   x94
1B06:  MOVLW  7F
1B08:  MOVWF  x93
1B0A:  MOVFF  27A,29A
1B0E:  MOVFF  279,299
1B12:  MOVFF  278,298
1B16:  MOVFF  277,297
1B1A:  MOVLB  0
1B1C:  RCALL  13AA
1B1E:  MOVFF  03,292
1B22:  MOVFF  02,291
1B26:  MOVFF  01,290
1B2A:  MOVFF  00,28F
1B2E:  MOVFF  03,296
1B32:  MOVFF  02,295
1B36:  MOVFF  01,294
1B3A:  MOVFF  00,293
1B3E:  MOVLW  DB
1B40:  MOVLB  2
1B42:  MOVWF  x9A
1B44:  MOVLW  0F
1B46:  MOVWF  x99
1B48:  MOVLW  49
1B4A:  MOVWF  x98
1B4C:  MOVLW  7F
1B4E:  MOVWF  x97
1B50:  MOVLB  0
1B52:  RCALL  16E0
1B54:  MOVFF  03,270
1B58:  MOVFF  02,26F
1B5C:  MOVFF  01,26E
1B60:  MOVFF  00,26D
1B64:  BRA    1BCE
1B66:  MOVLB  2
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
1B68:  BSF    FD8.1
1B6A:  MOVFF  27A,296
1B6E:  MOVFF  279,295
1B72:  MOVFF  278,294
1B76:  MOVFF  277,293
1B7A:  CLRF   x9A
1B7C:  CLRF   x99
1B7E:  CLRF   x98
1B80:  MOVLW  7F
1B82:  MOVWF  x97
1B84:  MOVLB  0
1B86:  RCALL  13AA
1B88:  MOVFF  03,292
1B8C:  MOVFF  02,291
1B90:  MOVFF  01,290
1B94:  MOVFF  00,28F
1B98:  MOVFF  03,296
1B9C:  MOVFF  02,295
1BA0:  MOVFF  01,294
1BA4:  MOVFF  00,293
1BA8:  MOVLW  DB
1BAA:  MOVLB  2
1BAC:  MOVWF  x9A
1BAE:  MOVLW  0F
1BB0:  MOVWF  x99
1BB2:  MOVLW  49
1BB4:  MOVWF  x98
1BB6:  MOVLW  7F
1BB8:  MOVWF  x97
1BBA:  MOVLB  0
1BBC:  RCALL  16E0
1BBE:  MOVFF  03,270
1BC2:  MOVFF  02,26F
1BC6:  MOVFF  01,26E
1BCA:  MOVFF  00,26D
.................... 
....................    y = 1.0;
1BCE:  MOVLB  2
1BD0:  CLRF   x6C
1BD2:  CLRF   x6B
1BD4:  CLRF   x6A
1BD6:  MOVLW  7F
1BD8:  MOVWF  x69
....................    t = t * t;
1BDA:  MOVFF  270,296
1BDE:  MOVFF  26F,295
1BE2:  MOVFF  26E,294
1BE6:  MOVFF  26D,293
1BEA:  MOVFF  270,29A
1BEE:  MOVFF  26F,299
1BF2:  MOVFF  26E,298
1BF6:  MOVFF  26D,297
1BFA:  MOVLB  0
1BFC:  RCALL  16E0
1BFE:  MOVFF  03,270
1C02:  MOVFF  02,26F
1C06:  MOVFF  01,26E
1C0A:  MOVFF  00,26D
....................    for (i = 0; i <= 4; i++)
1C0E:  MOVLB  2
1C10:  CLRF   x76
1C12:  MOVF   x76,W
1C14:  SUBLW  04
1C16:  BNC   1CD0
....................    {
....................       t2 = t2 * t;
1C18:  MOVFF  274,296
1C1C:  MOVFF  273,295
1C20:  MOVFF  272,294
1C24:  MOVFF  271,293
1C28:  MOVFF  270,29A
1C2C:  MOVFF  26F,299
1C30:  MOVFF  26E,298
1C34:  MOVFF  26D,297
1C38:  MOVLB  0
1C3A:  RCALL  16E0
1C3C:  MOVFF  03,274
1C40:  MOVFF  02,273
1C44:  MOVFF  01,272
1C48:  MOVFF  00,271
....................       y = y + p[i] * t2;
1C4C:  MOVLB  2
1C4E:  MOVF   x76,W
1C50:  MULLW  04
1C52:  MOVF   FF3,W
1C54:  CLRF   03
1C56:  ADDLW  7B
1C58:  MOVWF  FE9
1C5A:  MOVLW  02
1C5C:  ADDWFC 03,W
1C5E:  MOVWF  FEA
1C60:  MOVFF  FEF,293
1C64:  MOVFF  FEC,294
1C68:  MOVFF  FEC,295
1C6C:  MOVFF  FEC,296
1C70:  MOVFF  274,29A
1C74:  MOVFF  273,299
1C78:  MOVFF  272,298
1C7C:  MOVFF  271,297
1C80:  MOVLB  0
1C82:  RCALL  16E0
1C84:  MOVFF  FEA,290
1C88:  MOVFF  FE9,28F
1C8C:  BCF    FD8.1
1C8E:  MOVFF  26C,296
1C92:  MOVFF  26B,295
1C96:  MOVFF  26A,294
1C9A:  MOVFF  269,293
1C9E:  MOVFF  03,29A
1CA2:  MOVFF  02,299
1CA6:  MOVFF  01,298
1CAA:  MOVFF  00,297
1CAE:  CALL   13AA
1CB2:  MOVFF  290,FEA
1CB6:  MOVFF  28F,FE9
1CBA:  MOVFF  03,26C
1CBE:  MOVFF  02,26B
1CC2:  MOVFF  01,26A
1CC6:  MOVFF  00,269
1CCA:  MOVLB  2
1CCC:  INCF   x76,F
1CCE:  BRA    1C12
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
1CD0:  MOVF   x75,W
1CD2:  SUBLW  02
1CD4:  BZ    1CDA
1CD6:  DECFSZ x75,W
1CD8:  BRA    1CE0
....................       y = -y;  // correct sign
1CDA:  MOVF   x6A,W
1CDC:  XORLW  80
1CDE:  MOVWF  x6A
.................... 
....................    return (y);
1CE0:  MOVFF  269,00
1CE4:  MOVFF  26A,01
1CE8:  MOVFF  26B,02
1CEC:  MOVFF  26C,03
1CF0:  MOVLB  0
1CF2:  RETURN 0
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
1CF4:  BSF    FD8.1
1CF6:  MOVFF  260,296
1CFA:  MOVFF  25F,295
1CFE:  MOVFF  25E,294
1D02:  MOVFF  25D,293
1D06:  MOVLW  DB
1D08:  MOVLB  2
1D0A:  MOVWF  x9A
1D0C:  MOVLW  0F
1D0E:  MOVWF  x99
1D10:  MOVLW  49
1D12:  MOVWF  x98
1D14:  MOVLW  7F
1D16:  MOVWF  x97
1D18:  MOVLB  0
1D1A:  CALL   13AA
1D1E:  MOVFF  03,264
1D22:  MOVFF  02,263
1D26:  MOVFF  01,262
1D2A:  MOVFF  00,261
1D2E:  MOVFF  03,268
1D32:  MOVFF  02,267
1D36:  MOVFF  01,266
1D3A:  MOVFF  00,265
1D3E:  RCALL  197E
1D40:  GOTO   348C (RETURN)
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... #include <stdlibm.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... /*********************************************************************/
.................... #ifndef _STDLIBM
.................... #define _STDLIBM
.................... 
.................... /* Memory Management Functions*/
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #if defined(__PCB__)
.................... typedef struct nodet {
....................    unsigned int8 size;
....................    unsigned int8 next; }node_t;
.................... #elif defined(__PCM__)
.................... typedef struct nodet {
....................    unsigned int8 size;
....................    unsigned int16 next; }node_t;
.................... #elif defined(__PCH__)
.................... typedef struct nodet {
....................    unsigned int16 size;
....................    unsigned int16 next; }node_t;
.................... #elif defined(__PCD__)
.................... typedef struct nodet {
....................    unsigned int16 size;
....................    unsigned int16 next; }node_t;
.................... #endif
.................... 
.................... #if !defined(STDLIBM_MANUAL_DYNAMIC_MEMORY)
....................    #USE DYNAMIC_MEMORY
.................... #endif
.................... 
.................... #ifndef debug_stdlibm
....................    #define debug_stdlibm(s)
.................... #else
....................    #define __DO_DEBUG_STDLIBM
....................    
....................    char g_DebugStdlibmStr[50];
....................    
....................    #if defined(__PCD__)
....................       #if (defined(__PIC24E__)||defined(__dsPIC33E__))
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x800)) || bit_test(x, 0))
....................       #else
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x1000)) || bit_test(x, 0))
....................       #endif
....................    #else
....................       #define INVALID_MEMORY_LOCATION(x) (x >= getenv("RAM"))
....................    #endif
.................... #endif
.................... 
.................... #if defined(STDLIBM_TRACK_WORST_CASE)
....................    static size_t _g_StdlibmCurrentBytesUsed = 0;
....................    static size_t _g_StdlibmWorstCaseBytesUsed = 0;
....................    
....................    #define _STDLIBM_TRACK_WORST_INC(_x) \
....................       _g_StdlibmCurrentBytesUsed += _x;   \
....................       if (_g_StdlibmCurrentBytesUsed > _g_StdlibmWorstCaseBytesUsed) \
....................          _g_StdlibmWorstCaseBytesUsed = _g_StdlibmCurrentBytesUsed
....................    
....................    #define _STDLIBM_TRACK_WORST_DEC(_x) _g_StdlibmCurrentBytesUsed-=_x
.................... #else
....................    #define _STDLIBM_TRACK_WORST_INC(_x)
....................    #define _STDLIBM_TRACK_WORST_DEC(_x)
.................... #endif
.................... 
.................... #include <memmgmt.c>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #if defined(__PCH__)
....................  #define _MEMMGMT_CSIZE 32768
....................  #define _MEMMGMT_POS 15
.................... #elif defined(__PCD__)
....................    #define _MEMMGMT_CSIZE 32768
....................    #define _MEMMGMT_POS 15
.................... #else
....................    #define _MEMMGMT_CSIZE 127
....................    #define _MEMMGMT_POS 7
.................... #endif
.................... 
.................... node_t * create_node(unsigned int16 size, node_t *ptr) // create node at given location
.................... {
....................    node_t *result;
....................    result =ptr;
....................    result->size=size;
....................    result->next = NULL;
....................    return result;
.................... }
.................... void update_node(node_t *node, unsigned int16 size) // update the size of given node
.................... {
....................    node->size=size;
.................... }
.................... 
.................... /* Insert node immediately after place */ //old,new
.................... void insert_node_after(node_t *place, node_t *node)// place the node after another given node
.................... {
....................     if (place->next==NULL)
....................        node->next= NULL;
....................     else
....................        node->next=place->next;
....................     place->next=node;
.................... }
.................... 
.................... /////////////////////////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... void remove_node(node_t *node) {// remove the given node from the memlist
....................    node_t *ptr;
....................    for(ptr=__DYNAMIC_HEAD;ptr->next!=node;ptr=ptr->next);
....................    ptr->next=node->next;
....................    node=NULL;
.................... }
.................... 
.................... /////////////////////////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... #if defined(__DO_DEBUG_STDLIBM)
.................... void print_list() { // print the current memlist
....................     node_t *node;
....................     debug_stdlibm("\r\nThe list is \n\r");
....................     for(node = __DYNAMIC_HEAD; node != NULL; node = node->next)
....................     {
....................         sprintf(g_DebugStdlibmStr, "H:0x%lx S:0x%lx N:0x%lx\n\r", node, node->size, node->next);
....................         debug_stdlibm(g_DebugStdlibmStr);
....................         if (INVALID_MEMORY_LOCATION(node->next))
....................         {
....................            debug_stdlibm("Breaking because of invalid next node\r\n");
....................            break;
....................         }   
....................     }
....................     sprintf(g_DebugStdlibmStr, "size of node_t %u\r\n",sizeof(node_t));
....................     debug_stdlibm(g_DebugStdlibmStr);
.................... }
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... void traverse()
.................... {
....................    node_t *node,*temp;
....................    unsigned int16 nsize,nextsize;
....................    node=__DYNAMIC_HEAD;
....................    while(node!=NULL)
....................    {
....................      #if defined(__DO_DEBUG_STDLIBM)
....................       if (INVALID_MEMORY_LOCATION(node))
....................       {
....................          sprintf(g_DebugStdlibmStr, "traverse() invalid node (0x%LX)\r\n", node);
....................          debug_stdlibm(g_DebugStdlibmStr);
....................          break;
....................       }   
....................      #endif
....................      if(!bit_test(node->size,_MEMMGMT_POS))// node free
....................       {
....................          nsize=node->size;
....................          temp=(unsigned int16)node->next;
....................         #if defined(__DO_DEBUG_STDLIBM)
....................          if (INVALID_MEMORY_LOCATION(temp))
....................          {
....................             sprintf(g_DebugStdlibmStr, "traverse() invalid temp (0x%LX)\r\n", node);
....................             debug_stdlibm(g_DebugStdlibmStr);
....................             break;
....................          }
....................         #endif
....................          if(!bit_test(temp->size,_MEMMGMT_POS)&& (temp==((unsigned int16)node+nsize+sizeof(node_t))))//next node free and consecutive, so combine
....................          {
....................             nextsize=temp->size;
....................             nsize+=nextsize+sizeof(node_t);
....................             remove_node(temp);
....................             update_node(node,nsize);
....................          }
....................          else
....................          node=node->next;
....................       }
....................       else
....................       node=node->next;
....................    }
.................... }
.................... 
.................... char *malloc(size_t size)
.................... {
....................    node_t *node,*new;
....................    unsigned int16 nsize;
....................    #if defined(__PCD__)
....................    if (size % 2)
....................       size++;
....................    #endif
....................    node=__DYNAMIC_HEAD;
....................    
....................   #if defined(__DO_DEBUG_STDLIBM)
....................    sprintf(g_DebugStdlibmStr, "malloc() size=%lu ", size);
....................    debug_stdlibm(g_DebugStdlibmStr);
....................   #endif
....................         
....................    while(node!=NULL) // chk until end of memlist
....................    {
....................      #if defined(__DO_DEBUG_STDLIBM)
....................       if (INVALID_MEMORY_LOCATION(node))
....................       {
....................          sprintf(g_DebugStdlibmStr, " invalid node (0x%LX)\r\n", node);
....................          debug_stdlibm(g_DebugStdlibmStr);
....................          print_list();
....................          return(0);
....................       }
....................      #endif
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=size) // node is free and > = req size
....................       {
....................          nsize=node->size;    //nsize = size of the node that "node" being pointed at
....................          if(nsize>size +sizeof(node_t)) //node > req size, so split and add new node to memlist
....................          {
....................             new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size);
....................             insert_node_after(node,new);
....................             update_node(node,size+_MEMMGMT_CSIZE);
....................          }
....................          else//not enough space for new node so use original size
....................          update_node(node,nsize+_MEMMGMT_CSIZE);
....................          //end if
....................          break;
....................       }//end if
....................       node=node->next;
....................    }//end while
....................    if(node==NULL)// reached end without finding an appropriate node
....................    {
....................       debug_stdlibm("Not enough memory for mallocation\r\n");
....................       return NULL;
....................    }
....................    else
....................    {
....................      #if defined(__DO_DEBUG_STDLIBM)
....................       sprintf(g_DebugStdlibmStr, "%LX\r\n", (char *)node+sizeof(node_t));
....................       debug_stdlibm(g_DebugStdlibmStr);
....................      #endif
....................       _STDLIBM_TRACK_WORST_INC(size);
....................       return (char *)node+sizeof(node_t); // return pounsigned int8er to allocated space
....................    }
.................... }
.................... 
.................... char *calloc(size_t nmemb,size_t size)
.................... {
....................    node_t *node,*new;
....................    unsigned int16 nsize,resize;
....................    node=__DYNAMIC_HEAD;
....................    resize=nmemb*size;
....................    #if defined(__PCD__)
....................    if(resize%2)
....................       resize++;
....................    #endif
....................    while(node!=NULL) // chk until end of memlist
....................    {
....................      #if defined(__DO_DEBUG_STDLIBM)
....................       if (INVALID_MEMORY_LOCATION(node))
....................       {
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node);
....................          debug_stdlibm(g_DebugStdlibmStr);
....................          print_list();
....................          return(0);
....................       }
....................      #endif
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=resize)// node is free and > = req size
....................       {
....................          nsize=node->size;
....................          if(nsize>resize+sizeof(node_t))//node > req size, so split and add new node to memlist
....................          {
....................             new=create_node(nsize-resize-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+resize);
....................             insert_node_after(node,new);
....................             update_node(node,resize+_MEMMGMT_CSIZE);
....................          }
....................          else//not enough space for new node so use original size
....................          update_node(node,nsize+_MEMMGMT_CSIZE);
....................          //end if
....................          break;
....................       }//end if
....................       node=node->next;
....................    }//end while
....................    if(node==NULL)// reached end without finding an appropriate node
....................    {
....................       debug_stdlibm("Not enough memory for callocation\r\n");
....................       return NULL;
....................    }
....................    else
....................    {
....................       memset((unsigned int16)node+sizeof(node_t),0,resize);// initialize to 0
....................       _STDLIBM_TRACK_WORST_INC(resize);
....................       return (char *)(unsigned int16)node+sizeof(node_t);// return pounsigned int8er to allocated space
....................    }
.................... }
.................... void free( void * ptr)
.................... {
....................    node_t *node;
....................    unsigned int16 nsize;
.................... 
....................   #if defined(__DO_DEBUG_STDLIBM)
....................    sprintf(g_DebugStdlibmStr, "free() 0x%LX\r\n", ptr);
....................    debug_stdlibm(g_DebugStdlibmStr);
....................   #endif
.................... 
....................    if(ptr==NULL) // not a valid pounsigned int8er
....................       return;
....................    else
....................    {
....................       node=ptr-sizeof(node_t);
....................       if(bit_test(node->size,_MEMMGMT_POS))// node occupied
....................       {
....................          nsize=node->size-_MEMMGMT_CSIZE;
....................          update_node(node,nsize);
....................          ptr=NULL;
....................          _STDLIBM_TRACK_WORST_DEC(nsize);
....................       }
....................       else // wrong input, return
....................       {
....................          ptr=NULL;
....................          return;
....................       }
....................    }
....................    traverse();
.................... }
.................... 
.................... char *realloc(void *ptr,size_t size)
.................... {
....................    node_t *node,*new,*temp;
....................    unsigned int16 nsize,nextsize;
....................    char *newptr;
....................    #if defined(__PCD__)
....................    if(size %2)
....................       size++;
....................    #endif
....................    if(ptr==NULL)// null pounsigned int8er, so malloc the req memory
....................       return(malloc(size));
....................    else if(size==0)
....................    {
....................       free(ptr);
....................       return(NULL);
....................    }
....................    else
....................    {
....................       node=ptr-sizeof(node_t);
....................       if(bit_test(node->size,_MEMMGMT_POS))// chk if valid pounsigned int8er
....................       {
....................          nsize=node->size-_MEMMGMT_CSIZE;
....................          temp=(unsigned int16)node->next;
....................          if(nsize>size)// block > req size
....................          {
....................        
....................                if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive
....................                {
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block
....................                   nextsize=temp->size;
....................                   remove_node(temp);
....................                   new=create_node(nextsize+(nsize-size),(unsigned int16)node+size+sizeof(node_t));
....................                   insert_node_after(node,new);
....................                   _STDLIBM_TRACK_WORST_DEC(nsize);
....................                   _STDLIBM_TRACK_WORST_INC(size);
....................                }
....................                else if (nsize>size +sizeof(node_t))//node > req size, so split and add new node to memlist
....................                {
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block
....................                   new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size);
....................                   insert_node_after(node,new);
....................                   _STDLIBM_TRACK_WORST_DEC(nsize);
....................                   _STDLIBM_TRACK_WORST_INC(size);
....................                }
....................                else//not enough space for new node so use original size
....................                update_node(node,nsize+_MEMMGMT_CSIZE); // update block
.................... 
....................          }
....................          else // block < req size
....................          {
....................             if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive
....................             {
....................                nextsize=temp->size;
....................                if(nextsize>=size-nsize) // next block >=difference
....................                {
....................                   if(nextsize>size-nsize+sizeof(node_t))//next node > req size, so split and add new node to memlist
....................                   {
....................                       update_node(node,size+_MEMMGMT_CSIZE);// update block
....................                       remove_node(temp);
....................                       new=create_node(nextsize-(size-nsize),(unsigned int16)node+size+sizeof(node_t));
....................                       insert_node_after(node,new);
....................                      _STDLIBM_TRACK_WORST_DEC(nsize);
....................                      _STDLIBM_TRACK_WORST_INC(size);
....................                   }
....................                   else//not enough space for new node in next node, so use original size
....................                   {
....................                       update_node(node,nsize+nextsize+_MEMMGMT_CSIZE);// update block
....................                       remove_node(temp);
....................                   }
....................                }
....................                else  //next block free but too small for new size
....................                {
....................                   newptr = malloc(size);  //use malloc to find new block
....................                   if(newptr == NULL)
....................                      return(NULL);        //return NULL if malloc was unable to find new block
....................                    
....................                   memcpy(newptr, ptr, nsize);   //copy original data to new block
....................                   free(ptr);                    //free original block
....................                   return(newptr);               //return new pointer
....................                }
....................             }
....................             else  //next block not free
....................             {
....................                newptr = malloc(size);  //use malloc to find new block
....................                if(newptr == NULL)      
....................                   return(NULL);        //return NULL if malloc was unable to find new block
....................                
....................                memcpy(newptr, ptr, nsize);   //copy original data to new block
....................                free(ptr);                    //free original block
....................                return(newptr);               //return new pointer
....................             }
....................          }
....................          return (char *)node+sizeof(node_t); // return pounsigned int8er to the reallocated block
....................       }
....................       else // not allocated use malloc
....................       {
....................          return(malloc(size));
....................       }
....................    }
....................  }
....................  
.................... typedef struct
.................... {
....................    size_t bytesUsed;
....................    size_t largestUsedSeg;
....................    int segmentsUsed;
....................    size_t bytesFree;
....................    size_t largestFreeSeg;
....................    int segmentsFree;
....................   #if defined(STDLIBM_TRACK_WORST_CASE)
....................    size_t worstCaseBytesUsed;
....................   #endif
.................... } heap_status_t;
.................... 
.................... void GetHeapStatus(heap_status_t *pHeapStatus)
.................... {
....................    heap_status_t status;
....................    node_t *node;
....................    unsigned int16 nsize;
....................    
....................    node=__DYNAMIC_HEAD;
....................    
....................    memset(&status, 0, sizeof(status));
.................... 
....................    while(node!=NULL)
....................    {
....................       nsize = node->size;
....................       node = node->next;
....................       
....................       if(!bit_test(nsize, _MEMMGMT_POS)) // node free
....................       {
....................          status.bytesFree += nsize;
....................          
....................          status.segmentsFree++;
....................          
....................          if (nsize > status.largestFreeSeg)
....................          {
....................             status.largestFreeSeg = nsize;
....................          }
....................       }
....................       else
....................       {
....................          bit_clear(nsize, _MEMMGMT_POS);
....................          
....................          status.bytesUsed += nsize;
....................          
....................          status.segmentsUsed++;
....................          
....................          if (nsize > status.largestUsedSeg)
....................          {
....................             status.largestUsedSeg = nsize;
....................          }
....................       }
....................    }
.................... 
....................   #if defined(STDLIBM_TRACK_WORST_CASE)
....................    status.worstCaseBytesUsed = _g_StdlibmWorstCaseBytesUsed;
....................   #endif
.................... 
....................    memcpy(pHeapStatus, &status, sizeof(heap_status_t));
.................... }
.................... #ENDIF
.................... 
.................... 
.................... #include "setup_disp.h"
.................... 
.................... const BYTE TEXT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // !
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // "
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // #
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // %
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // &
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // '
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // (
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // )
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // *
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // +
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // ,
....................                          0x08, 0x08, 0x08, 0x08, 0x08, // -
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // .
....................                          0x20, 0x10, 0x08, 0x04, 0x02, // /
....................                          0x3E, 0x51, 0x49, 0x45, 0x3E, // 0
....................                          0x04, 0x02, 0x7F, 0x00, 0x00, // 1
....................                          0x42, 0x61, 0x51, 0x49, 0x46, // 2
....................                          0x22, 0x41, 0x49, 0x49, 0x36, // 3
....................                          0x18, 0x14, 0x12, 0x7F, 0x10, // 4
....................                          0x27, 0x45, 0x45, 0x45, 0x39, // 5
....................                          0x3E, 0x49, 0x49, 0x49, 0x32, // 6
....................                          0x01, 0x01, 0x71, 0x09, 0x07, // 7
....................                          0x36, 0x49, 0x49, 0x49, 0x36, // 8
....................                          0x26, 0x49, 0x49, 0x49, 0x3E, // 9
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // :
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ;
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // <
....................                          0x14, 0x14, 0x14, 0x14, 0x14, // =
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // >
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ?
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @
....................                          0x7E, 0x09, 0x09, 0x09, 0x7E, // A
....................                          0x7F, 0x49, 0x49, 0x49, 0x36, // B
....................                          0x3E, 0x41, 0x41, 0x41, 0x22, // C
....................                          0x7F, 0x41, 0x41, 0x41, 0x3E, // D
....................                          0x7F, 0x49, 0x49, 0x49, 0x41, // E
....................                          0x7F, 0x09, 0x09, 0x09, 0x01, // F
....................                          0x3E, 0x41, 0x41, 0x49, 0x3A, // G
....................                          0x7F, 0x08, 0x08, 0x08, 0x7F, // H
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I
....................                          0x30, 0x40, 0x40, 0x40, 0x3F, // J
....................                          0x7F, 0x08, 0x14, 0x22, 0x41, // K
....................                          0x7F, 0x40, 0x40, 0x40, 0x40, // L
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N
....................                          0x3E, 0x41, 0x41, 0x41, 0x3E, // O
....................                          0x7F, 0x09, 0x09, 0x09, 0x06, // P
....................                          0x1E, 0x21, 0x21, 0x21, 0x5E, // Q
....................                          0x7F, 0x09, 0x09, 0x09, 0x76};// R
.................... 
.................... const BYTE TEXT2[44][5]={0x26, 0x49, 0x49, 0x49, 0x32, // S
....................                          0x01, 0x01, 0x7F, 0x01, 0x01, // T
....................                          0x3F, 0x40, 0x40, 0x40, 0x3F, // U
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y
....................                          0x61, 0x51, 0x49, 0x45, 0x43, // Z
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ]
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^
....................                          0x40, 0x40, 0x40, 0x40, 0x40, // _
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // `
....................                          0x20, 0x54, 0x54, 0x54, 0x78, // a
....................                          0x7F, 0x44, 0x44, 0x44, 0x38, // b
....................                          0x38, 0x44, 0x44, 0x44, 0x44, // c
....................                          0x38, 0x44, 0x44, 0x44, 0x7F, // d
....................                          0x38, 0x54, 0x54, 0x54, 0x18, // e
....................                          0x04, 0x04, 0x7E, 0x05, 0x05, // f
....................                          0x08, 0x54, 0x54, 0x54, 0x3C, // g
....................                          0x7F, 0x08, 0x04, 0x04, 0x78, // h
....................                          0x00, 0x44, 0x7D, 0x40, 0x00, // i
....................                          0x20, 0x40, 0x44, 0x3D, 0x00, // j
....................                          0x7F, 0x10, 0x28, 0x44, 0x00, // k
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m
....................                          0x7C, 0x08, 0x04, 0x04, 0x78, // n
....................                          0x38, 0x44, 0x44, 0x44, 0x38, // o
....................                          0x7C, 0x14, 0x14, 0x14, 0x08, // p
....................                          0x08, 0x14, 0x14, 0x14, 0x7C, // q
....................                          0x00, 0x7C, 0x08, 0x04, 0x04, // r
....................                          0x48, 0x54, 0x54, 0x54, 0x20, // s
....................                          0x04, 0x04, 0x3F, 0x44, 0x44, // t
....................                          0x3C, 0x40, 0x40, 0x20, 0x7C, // u
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x
....................                          0x0C, 0x50, 0x50, 0x50, 0x3C, // y
....................                          0x44, 0x64, 0x54, 0x4C, 0x44, // z
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // {
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // |
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // }
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~
.................... 
.................... int personaje[16][16] = {
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0},
....................     {0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0},
....................     {0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0},
....................     {0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0},
....................     {0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0},
....................     {0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0},
....................     {0,0,0,1,1,1,1,0,0,1,1,1,1,0,0,0},
....................     {0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0},
....................     {0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0},
....................     {0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0},
....................     {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},
....................     {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... const int levels[30][20] = {
....................     {0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
....................     {3,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,2,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,2,0,0,1,0,1,0,0,0,0,0,0,1,0,1,0,0},
....................     {0,0,0,0,0,0,0,3,0,0,3,0,3,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... 
.................... 
.................... #use rs232(rcv=pin_c7,xmit=pin_c6,baud=9600,bits=8,parity=n)
.................... 
.................... // nave
.................... float last_ship_angle_1 = 0;
.................... float ship_angle_1 = 0;
.................... int last_x_pos_1;
.................... int last_y_pos_1;
.................... int x_pos_1 = 64;
.................... int y_pos_1 = 32;
.................... float dx_1 = 0; 
.................... float dy_1 = 0;
.................... 
.................... float last_ship_angle_2 = 0;
.................... float ship_angle_2 = 0;
.................... int last_x_pos_2;
.................... int last_y_pos_2;
.................... int x_pos_2 = 64;
.................... int y_pos_2 = 32;
.................... float dx_2 = 0; 
.................... float dy_2 = 0;
.................... 
.................... float last_ship_angle = 0;
.................... float ship_angle = 0;
.................... int last_x_pos;
.................... int last_y_pos;
.................... int x_pos = 64;
.................... int y_pos = 32;
.................... float dx = 0; 
.................... float dy = 0;
.................... // bala
.................... int1 bullet = 0;
.................... signed int last_last_bullet_x_pos;
.................... signed int last_last_bullet_y_pos;
.................... signed int last_bullet_x_pos;
.................... signed int last_bullet_y_pos;
.................... signed int16 bullet_x_pos;
.................... signed int16 bullet_y_pos;
.................... float bullet_dx = 0; 
.................... float bullet_dy = 0;
.................... const float bullet_speed = 6;
.................... 
.................... int1 bullet_1 = 0;
.................... signed int last_last_bullet_x_pos_1;
.................... signed int last_last_bullet_y_pos_1;
.................... signed int last_bullet_x_pos_1;
.................... signed int last_bullet_y_pos_1;
.................... signed int16 bullet_x_pos_1;
.................... signed int16 bullet_y_pos_1;
.................... float bullet_dx_1 = 0; 
.................... float bullet_dy_1 = 0;
.................... int1 bullet_collision_1 = 0;
.................... 
.................... int1 bullet_2 = 0;
.................... signed int last_last_bullet_x_pos_2;
.................... signed int last_last_bullet_y_pos_2;
.................... signed int last_bullet_x_pos_2;
.................... signed int last_bullet_y_pos_2;
.................... signed int16 bullet_x_pos_2;
.................... signed int16 bullet_y_pos_2;
.................... float bullet_dx_2 = 0; 
.................... float bullet_dy_2 = 0;
.................... int1 bullet_collision_2 = 0;
.................... // asteroides
.................... 
.................... int last_asteroids_x_pos[20];
.................... int last_asteroids_y_pos[20];
.................... unsigned int asteroids_x_pos[20];
.................... unsigned int asteroids_y_pos[20];
.................... signed int asteroids_dx[20] = {-2,1,-3,3,-2,3,-1,2,-3,3,-2,2,-1,2,-1,2,-2,3,-2,-1};
.................... signed int asteroids_dy[20] = {2,-1,-2,3,-2,2,-1,1,-2,3,-1,3,-2,-1,2,-3,-3,3,-2,1};
.................... 
.................... unsigned int level = 0;
.................... unsigned int best_level = 0;
.................... int1 new_level = 1;
.................... unsigned int16 score = 0;
.................... unsigned int16 best_score = 0;
.................... unsigned int16 last_score = 10;
.................... unsigned int last_level = 10;
.................... 
.................... const float internal_angle = (2*(float)PI)/3.0f;   
.................... // dibujar
.................... void glcd_line(int x1, int y1, int x2, int y2, int1 color);
.................... void draw_triangle(int x, int y, float starting_angle, int1 color);
.................... void glcd_lineTracing(int *xx, int *yy, int n_points, int1 color);
.................... void draw_asteroid(int x, int y, int life, int1 color);
.................... void glcd_text57(int x, int y, char* textptr, int size, int1 color);
.................... void inicio(int sec);
.................... void scores(unsigned int16 scr, unsigned int lvl, int1 color);
.................... void single_menu(int1 play);
.................... 
.................... float get_ship_angle();
.................... float get_x_vel();
.................... float get_y_vel();
.................... 
.................... char dataRS232;
.................... 
.................... char mode = 'i';
.................... char mode_inic = 't';
.................... 
.................... int1 flagg = 1;
.................... int1 flag_rec = 0;
.................... 
.................... int current_data = 0;
.................... 
.................... unsigned int p1_pot_x = 125;
.................... unsigned int p1_pot_y = 125;
.................... unsigned int p1_pot_xx = 125;
.................... unsigned int p1_pot_yy = 125;
.................... int1 p1_L = 0;
.................... int1 p1_R = 0;
.................... 
.................... float calc_ang_x(int x, int y);
.................... float calc_ang_y(int x, int y);
.................... 
.................... float get_d(unsigned int pp){
....................    return (float)((float)pp - 127.0f)/30.0f;
*
2232:  MOVLB  2
2234:  CLRF   x94
2236:  MOVFF  25D,293
223A:  MOVLB  0
223C:  CALL   11AE
2240:  MOVFF  03,261
2244:  MOVFF  02,260
2248:  MOVFF  01,25F
224C:  MOVFF  00,25E
2250:  BSF    FD8.1
2252:  MOVFF  03,296
2256:  MOVFF  02,295
225A:  MOVFF  01,294
225E:  MOVFF  00,293
2262:  MOVLB  2
2264:  CLRF   x9A
2266:  CLRF   x99
2268:  MOVLW  7E
226A:  MOVWF  x98
226C:  MOVLW  85
226E:  MOVWF  x97
2270:  MOVLB  0
2272:  CALL   13AA
2276:  MOVFF  03,261
227A:  MOVFF  02,260
227E:  MOVFF  01,25F
2282:  MOVFF  00,25E
2286:  MOVFF  03,268
228A:  MOVFF  02,267
228E:  MOVFF  01,266
2292:  MOVFF  00,265
2296:  MOVLB  2
2298:  CLRF   x6C
229A:  CLRF   x6B
229C:  MOVLW  70
229E:  MOVWF  x6A
22A0:  MOVLW  83
22A2:  MOVWF  x69
22A4:  MOVLB  0
22A6:  CALL   11E4
22AA:  RETURN 0
.................... }
.................... 
.................... unsigned int p2_pot_x = 125;
.................... unsigned int p2_pot_y = 125;
.................... unsigned int p2_pot_xx = 125;
.................... unsigned int p2_pot_yy = 125;
.................... int1 p2_L = 0;
.................... int1 p2_R = 0;
.................... 
.................... #int_rda
.................... void rcv_data(){
.................... 
....................    dataRS232 = getch();
*
0510:  BTFSS  F9E.5
0512:  BRA    0510
0514:  MOVFF  FAE,209
0518:  MOVLB  2
....................    
....................    switch(current_data){
051A:  MOVF   x0C,W
051C:  ADDLW  F7
051E:  BC    05AE
0520:  ADDLW  09
0522:  MOVLB  0
0524:  GOTO   05C0
....................       case 0:
....................          p1_pot_y = dataRS232; // x
0528:  MOVFF  209,20E
....................          break;
052C:  MOVLB  2
052E:  BRA    05AE
....................       case 1:
....................          p1_pot_x = dataRS232; // y
0530:  MOVFF  209,20D
....................          break;
0534:  MOVLB  2
0536:  BRA    05AE
....................       case 2:
....................          p1_pot_xx = dataRS232;
0538:  MOVFF  209,20F
....................          break;
053C:  MOVLB  2
053E:  BRA    05AE
....................       case 3:
....................          p1_pot_yy = dataRS232;
0540:  MOVFF  209,210
....................          break;
0544:  MOVLB  2
0546:  BRA    05AE
....................       case 4:
....................          p2_pot_y = dataRS232;
0548:  MOVFF  209,213
....................          break;
054C:  MOVLB  2
054E:  BRA    05AE
....................       case 5:
....................          p2_pot_x = dataRS232;
0550:  MOVFF  209,212
....................          break;
0554:  MOVLB  2
0556:  BRA    05AE
....................       case 6:
....................          p2_pot_xx = dataRS232;
0558:  MOVFF  209,214
....................          break;
055C:  MOVLB  2
055E:  BRA    05AE
....................       case 7:
....................          p2_pot_yy = dataRS232;
0560:  MOVFF  209,215
....................          break;
0564:  MOVLB  2
0566:  BRA    05AE
....................       case 8:
....................          p1_L = (dataRS232 & 0x01) ? 1 : 0;
0568:  MOVLB  2
056A:  BTFSS  x09.0
056C:  BRA    0572
056E:  MOVLW  01
0570:  BRA    0574
0572:  MOVLW  00
0574:  BCF    x11.0
0576:  BTFSC  FE8.0
0578:  BSF    x11.0
....................          p1_R = (dataRS232 & 0x02) ? 1 : 0;
057A:  BTFSS  x09.1
057C:  BRA    0582
057E:  MOVLW  01
0580:  BRA    0584
0582:  MOVLW  00
0584:  BCF    x11.1
0586:  BTFSC  FE8.0
0588:  BSF    x11.1
....................          p2_L = (dataRS232 & 0x04) ? 1 : 0;
058A:  BTFSS  x09.2
058C:  BRA    0592
058E:  MOVLW  01
0590:  BRA    0594
0592:  MOVLW  00
0594:  BCF    x11.2
0596:  BTFSC  FE8.0
0598:  BSF    x11.2
....................          p2_R = (dataRS232 & 0x08) ? 1 : 0;
059A:  BTFSS  x09.3
059C:  BRA    05A2
059E:  MOVLW  01
05A0:  BRA    05A4
05A2:  MOVLW  00
05A4:  BCF    x11.3
05A6:  BTFSC  FE8.0
05A8:  BSF    x11.3
....................          break;
05AA:  BRA    05AE
05AC:  MOVLB  2
....................    }
....................    
....................    current_data++;
05AE:  INCF   x0C,F
....................    if(current_data == 9)
05B0:  MOVF   x0C,W
05B2:  SUBLW  09
05B4:  BNZ   05B8
....................       current_data = 0;
05B6:  CLRF   x0C
05B8:  BCF    F9E.5
05BA:  MOVLB  0
05BC:  GOTO   0060
.................... }
.................... 
.................... void draw_cuadrito(int x,int y,int1 col);
.................... 
.................... void restart_screen(){
....................    glcd_fillScreen(0);
*
1130:  MOVLB  2
1132:  CLRF   x73
1134:  MOVLB  0
1136:  CALL   0658
....................    char text_asteroids[] = "Presiona para restart";
113A:  MOVLW  50
113C:  MOVLB  2
113E:  MOVWF  x5D
1140:  MOVLW  72
1142:  MOVWF  x5E
1144:  MOVLW  65
1146:  MOVWF  x5F
1148:  MOVLW  73
114A:  MOVWF  x60
114C:  MOVLW  69
114E:  MOVWF  x61
1150:  MOVLW  6F
1152:  MOVWF  x62
1154:  MOVLW  6E
1156:  MOVWF  x63
1158:  MOVLW  61
115A:  MOVWF  x64
115C:  MOVLW  20
115E:  MOVWF  x65
1160:  MOVLW  70
1162:  MOVWF  x66
1164:  MOVLW  61
1166:  MOVWF  x67
1168:  MOVLW  72
116A:  MOVWF  x68
116C:  MOVLW  61
116E:  MOVWF  x69
1170:  MOVLW  20
1172:  MOVWF  x6A
1174:  MOVLW  72
1176:  MOVWF  x6B
1178:  MOVLW  65
117A:  MOVWF  x6C
117C:  MOVLW  73
117E:  MOVWF  x6D
1180:  MOVLW  74
1182:  MOVWF  x6E
1184:  MOVLW  61
1186:  MOVWF  x6F
1188:  MOVLW  72
118A:  MOVWF  x70
118C:  MOVLW  74
118E:  MOVWF  x71
1190:  CLRF   x72
....................    glcd_text57(0,0,text_asteroids,1,1);
1192:  CLRF   x83
1194:  CLRF   x84
1196:  MOVLW  02
1198:  MOVWF  x86
119A:  MOVLW  5D
119C:  MOVWF  x85
119E:  MOVLW  01
11A0:  MOVWF  x87
11A2:  MOVWF  x88
11A4:  MOVLB  0
11A6:  CALL   08B4
11AA:  GOTO   2A0C (RETURN)
.................... }
.................... 
.................... void main(){
*
25CC:  CLRF   FF8
25CE:  BCF    FD0.7
25D0:  BSF    07.7
25D2:  BSF    FB8.3
25D4:  MOVLW  08
25D6:  MOVWF  FAF
25D8:  MOVLW  02
25DA:  MOVWF  FB0
25DC:  MOVLW  A6
25DE:  MOVWF  FAC
25E0:  MOVLW  90
25E2:  MOVWF  FAB
25E4:  MOVLB  1
25E6:  CLRF   x1E
25E8:  CLRF   x1D
25EA:  CLRF   x1C
25EC:  CLRF   x1B
25EE:  CLRF   x22
25F0:  CLRF   x21
25F2:  CLRF   x20
25F4:  CLRF   x1F
25F6:  MOVLW  40
25F8:  MOVWF  x25
25FA:  MOVLW  20
25FC:  MOVWF  x26
25FE:  CLRF   x2A
2600:  CLRF   x29
2602:  CLRF   x28
2604:  CLRF   x27
2606:  CLRF   x2E
2608:  CLRF   x2D
260A:  CLRF   x2C
260C:  CLRF   x2B
260E:  CLRF   x32
2610:  CLRF   x31
2612:  CLRF   x30
2614:  CLRF   x2F
2616:  CLRF   x36
2618:  CLRF   x35
261A:  CLRF   x34
261C:  CLRF   x33
261E:  MOVLW  40
2620:  MOVWF  x39
2622:  MOVLW  20
2624:  MOVWF  x3A
2626:  CLRF   x3E
2628:  CLRF   x3D
262A:  CLRF   x3C
262C:  CLRF   x3B
262E:  CLRF   x42
2630:  CLRF   x41
2632:  CLRF   x40
2634:  CLRF   x3F
2636:  CLRF   x46
2638:  CLRF   x45
263A:  CLRF   x44
263C:  CLRF   x43
263E:  CLRF   x4A
2640:  CLRF   x49
2642:  CLRF   x48
2644:  CLRF   x47
2646:  MOVLW  40
2648:  MOVWF  x4D
264A:  MOVLW  20
264C:  MOVWF  x4E
264E:  CLRF   x52
2650:  CLRF   x51
2652:  CLRF   x50
2654:  CLRF   x4F
2656:  CLRF   x56
2658:  CLRF   x55
265A:  CLRF   x54
265C:  CLRF   x53
265E:  BCF    x57.0
2660:  CLRF   x63
2662:  CLRF   x62
2664:  CLRF   x61
2666:  CLRF   x60
2668:  CLRF   x67
266A:  CLRF   x66
266C:  CLRF   x65
266E:  CLRF   x64
2670:  BCF    x57.1
2672:  CLRF   x73
2674:  CLRF   x72
2676:  CLRF   x71
2678:  CLRF   x70
267A:  CLRF   x77
267C:  CLRF   x76
267E:  CLRF   x75
2680:  CLRF   x74
2682:  BCF    x57.2
2684:  BCF    x57.3
2686:  CLRF   x83
2688:  CLRF   x82
268A:  CLRF   x81
268C:  CLRF   x80
268E:  CLRF   x87
2690:  CLRF   x86
2692:  CLRF   x85
2694:  CLRF   x84
2696:  BCF    x57.4
2698:  MOVLB  2
269A:  CLRF   x00
269C:  CLRF   x01
269E:  MOVLB  1
26A0:  BSF    x57.5
26A2:  MOVLB  2
26A4:  CLRF   x03
26A6:  CLRF   x02
26A8:  CLRF   x05
26AA:  CLRF   x04
26AC:  CLRF   x07
26AE:  MOVLW  0A
26B0:  MOVWF  x06
26B2:  MOVWF  x08
26B4:  MOVLW  69
26B6:  MOVWF  x0A
26B8:  MOVLW  74
26BA:  MOVWF  x0B
26BC:  MOVLB  1
26BE:  BSF    x57.6
26C0:  BCF    x57.7
26C2:  MOVLB  2
26C4:  CLRF   x0C
26C6:  MOVLW  7D
26C8:  MOVWF  x0D
26CA:  MOVWF  x0E
26CC:  MOVWF  x0F
26CE:  MOVWF  x10
26D0:  BCF    x11.0
26D2:  BCF    x11.1
26D4:  MOVWF  x12
26D6:  MOVWF  x13
26D8:  MOVWF  x14
26DA:  MOVWF  x15
26DC:  BCF    x11.2
26DE:  BCF    x11.3
26E0:  CLRF   x17
26E2:  CLRF   x16
26E4:  MOVF   FC1,W
26E6:  ANDLW  C0
26E8:  IORLW  0F
26EA:  MOVWF  FC1
26EC:  MOVLW  07
26EE:  MOVWF  FB4
26F0:  MOVLW  02
26F2:  MOVWF  1A
26F4:  MOVLW  A3
26F6:  MOVWF  19
26F8:  MOVLW  05
26FA:  MOVWF  xA4
26FC:  MOVLW  59
26FE:  MOVWF  xA3
2700:  CLRF   xA6
2702:  CLRF   xA5
2704:  MOVLB  0
2706:  BRA    2798
2708:  DATA 16,40
270A:  DATA 1B,00
270C:  DATA 04,C0
270E:  DATA 01,0B
2710:  DATA C0,00
2712:  DATA 06,C0
2714:  DATA 01,09
2716:  DATA C0,00
2718:  DATA 08,C0
271A:  DATA 01,08
271C:  DATA C0,00
271E:  DATA 08,C0
2720:  DATA 01,09
2722:  DATA C0,00
2724:  DATA 06,C0
2726:  DATA 01,0B
2728:  DATA C0,00
272A:  DATA 04,C0
272C:  DATA 01,1A
272E:  DATA C0,00
2730:  DATA 02,80
2732:  DATA 01,01
2734:  DATA 04,C0
2736:  DATA 00,02
2738:  DATA 80,01
273A:  DATA 01,07
273C:  DATA C0,00
273E:  DATA 04,C0
2740:  DATA 01,02
2742:  DATA 80,00
2744:  DATA 00,04
2746:  DATA C0,01
2748:  DATA 06,C0
274A:  DATA 00,0A
274C:  DATA C0,01
274E:  DATA 05,C0
2750:  DATA 00,0C
2752:  DATA C0,01
2754:  DATA 04,C0
2756:  DATA 00,0C
2758:  DATA C0,01
275A:  DATA 03,80
275C:  DATA 00,00
275E:  DATA 00,0E
2760:  DATA C0,01
2762:  DATA 02,80
2764:  DATA 00,00
2766:  DATA 0E,C0
2768:  DATA 01,11
276A:  DATA C0,00
276C:  DATA 28,01
276E:  DATA D8,FE
2770:  DATA 01,FD
2772:  DATA 03,FE
2774:  DATA 03,FF
2776:  DATA 02,FD
2778:  DATA 03,FE
277A:  DATA 02,FF
277C:  DATA 02,FF
277E:  DATA 02,FE
2780:  DATA 03,FE
2782:  DATA FF,02
2784:  DATA FF,FE
2786:  DATA 03,FE
2788:  DATA 02,FF
278A:  DATA 01,FE
278C:  DATA 03,FF
278E:  DATA 03,FE
2790:  DATA FF,02
2792:  DATA FD,FD
2794:  DATA 03,FE
2796:  DATA 01,00
2798:  MOVLW  00
279A:  MOVWF  FF8
279C:  MOVLW  27
279E:  MOVWF  FF7
27A0:  MOVLW  08
27A2:  MOVWF  FF6
27A4:  TBLRD*+
27A6:  MOVF   FF5,W
27A8:  MOVWF  00
27AA:  XORLW  00
27AC:  BZ    27D4
27AE:  TBLRD*+
27B0:  MOVF   FF5,W
27B2:  MOVWF  01
27B4:  BTFSC  FE8.7
27B6:  BRA    27C2
27B8:  ANDLW  3F
27BA:  MOVWF  FEA
27BC:  TBLRD*+
27BE:  MOVF   FF5,W
27C0:  MOVWF  FE9
27C2:  BTFSC  01.6
27C4:  TBLRD*+
27C6:  BTFSS  01.6
27C8:  TBLRD*+
27CA:  MOVF   FF5,W
27CC:  MOVWF  FEE
27CE:  DCFSNZ 00,F
27D0:  BRA    27A4
27D2:  BRA    27C6
27D4:  CLRF   FF8
....................       
....................    enable_interrupts(GLOBAL);
27D6:  MOVLW  C0
27D8:  IORWF  FF2,F
....................    enable_interrupts(int_rda);
27DA:  BSF    F9D.5
.................... 
....................    delay_ms(100);
27DC:  MOVLW  64
27DE:  MOVLB  2
27E0:  MOVWF  x60
27E2:  MOVLB  0
27E4:  CALL   05EC
.................... 
....................    glcd_init(ON);
27E8:  MOVLW  01
27EA:  MOVLB  2
27EC:  MOVWF  x5D
27EE:  MOVLB  0
27F0:  GOTO   06DE
....................    glcd_fillScreen(0);
27F4:  MOVLB  2
27F6:  CLRF   x73
27F8:  MOVLB  0
27FA:  CALL   0658
.................... 
....................    int inic_men = 0;
....................    int last_inic_men = 0;
....................    
....................    int single_men = 0;
....................    int last_single_men = 0;
27FE:  MOVLB  2
2800:  CLRF   x18
2802:  CLRF   x19
2804:  CLRF   x1A
2806:  CLRF   x1B
....................    
....................    inicio(1);
2808:  MOVLW  01
280A:  MOVWF  x5D
280C:  MOVLB  0
280E:  CALL   0C10
....................    
....................    int1 win = 0;
....................    int1 who = 0;
....................    
....................    int1 bullet_collision = 0;
....................    int sfx_time;
.................... 
....................    int asteroids_lifes[20]; // puede haber hasta 20 asteroides en la pantalla;
....................    int1 asteroid_lost_a_life[20] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
*
281A:  CLRF   x32
281C:  CLRF   x33
281E:  CLRF   x34
....................          
....................    int temp = 0;
....................    int1 new_game = 0;
*
2812:  MOVLB  2
2814:  BCF    x1C.0
2816:  BCF    x1C.1
2818:  BCF    x1C.2
*
2820:  CLRF   x35
2822:  BCF    x1C.3
.................... 
....................    while(TRUE){
....................       switch(mode){
2824:  MOVF   x0A,W
2826:  XORLW  69
2828:  MOVLB  0
282A:  BZ    2848
282C:  XORLW  1A
282E:  BZ    28DC
2830:  XORLW  1E
2832:  BTFSC  FD8.2
2834:  BRA    2940
2836:  XORLW  07
2838:  BTFSC  FD8.2
283A:  BRA    29A6
283C:  XORLW  20
283E:  BTFSC  FD8.2
2840:  GOTO   3A2A
2844:  GOTO   444C
....................          case 'i':{ // inicio
....................             if(p1_pot_y > 125){
2848:  MOVLB  2
284A:  MOVF   x0E,W
284C:  SUBLW  7D
284E:  BC    2854
....................                inic_men = 0;
2850:  CLRF   x18
....................             }
2852:  BRA    2864
....................             else{
....................                if(p1_pot_x > 125){
2854:  MOVF   x0D,W
2856:  SUBLW  7D
2858:  BC    2860
....................                   inic_men = 2;
285A:  MOVLW  02
285C:  MOVWF  x18
....................                }
285E:  BRA    2864
....................                else{
....................                   inic_men = 1;
2860:  MOVLW  01
2862:  MOVWF  x18
....................                }
....................             }
....................             
....................             if(inic_men != last_inic_men){
2864:  MOVF   x19,W
2866:  SUBWF  x18,W
2868:  BZ    287C
....................                glcd_fillScreen(0);
286A:  CLRF   x73
286C:  MOVLB  0
286E:  CALL   0658
....................                inicio(inic_men);
2872:  MOVFF  218,25D
2876:  CALL   0C10
287A:  MOVLB  2
....................             }
....................             if(p1_R){
287C:  BTFSS  x11.1
287E:  BRA    28D2
....................                switch(inic_men){
2880:  MOVF   x18,W
2882:  XORLW  01
2884:  MOVLB  0
2886:  BZ    288E
2888:  XORLW  03
288A:  BZ    28AA
288C:  BRA    28C6
....................                   case 1:
....................                      mode = 's';
288E:  MOVLW  73
2890:  MOVLB  2
2892:  MOVWF  x0A
....................                      glcd_fillScreen(0);
2894:  CLRF   x73
2896:  MOVLB  0
2898:  CALL   0658
....................                      single_menu(1);
289C:  MOVLW  01
289E:  MOVLB  2
28A0:  MOVWF  x5D
28A2:  MOVLB  0
28A4:  CALL   0FC8
....................                      break;
28A8:  BRA    28D0
....................                   case 2:
....................                      mode = 'm';
28AA:  MOVLW  6D
28AC:  MOVLB  2
28AE:  MOVWF  x0A
....................                      glcd_fillScreen(0);
28B0:  CLRF   x73
28B2:  MOVLB  0
28B4:  CALL   0658
....................                      single_menu(1);
28B8:  MOVLW  01
28BA:  MOVLB  2
28BC:  MOVWF  x5D
28BE:  MOVLB  0
28C0:  CALL   0FC8
....................                      break;
28C4:  BRA    28D0
....................                   default:
....................                      mode = 'i';
28C6:  MOVLW  69
28C8:  MOVLB  2
28CA:  MOVWF  x0A
....................                      new_game = 1;
28CC:  BSF    x1C.3
....................                      break;
28CE:  MOVLB  0
28D0:  MOVLB  2
....................                }
....................             }
....................             
....................             
....................             last_inic_men = inic_men;
28D2:  MOVFF  218,219
....................          break;
28D6:  GOTO   444E
28DA:  MOVLB  0
....................          }
....................          case 's':{ // single
....................             if(p1_pot_y >= 125){
28DC:  MOVLB  2
28DE:  MOVF   x0E,W
28E0:  SUBLW  7C
28E2:  BC    28EA
....................                single_men = 1;
28E4:  MOVLW  01
28E6:  MOVWF  x1A
....................             }
28E8:  BRA    28EC
....................             else{
....................                single_men = 0;
28EA:  CLRF   x1A
....................             }
....................             
....................             if(single_men != last_single_men){
28EC:  MOVF   x1B,W
28EE:  SUBWF  x1A,W
28F0:  BZ    2904
....................                glcd_fillScreen(0);
28F2:  CLRF   x73
28F4:  MOVLB  0
28F6:  CALL   0658
....................                single_menu(single_men);
28FA:  MOVFF  21A,25D
28FE:  CALL   0FC8
2902:  MOVLB  2
....................             }
....................             
....................             if(p1_L){
2904:  BTFSS  x11.0
2906:  BRA    2936
....................                switch(single_men){
2908:  MOVF   x1A,W
290A:  XORLW  00
290C:  MOVLB  0
290E:  BZ    2916
2910:  XORLW  01
2912:  BZ    2926
2914:  BRA    2934
....................                   case 0:
....................                      mode = 'i';
2916:  MOVLW  69
2918:  MOVLB  2
291A:  MOVWF  x0A
....................                      glcd_fillScreen(0);
291C:  CLRF   x73
291E:  MOVLB  0
2920:  CALL   0658
....................                      break;
2924:  BRA    2934
....................                   case 1:
....................                      mode = 'j';
2926:  MOVLW  6A
2928:  MOVLB  2
292A:  MOVWF  x0A
....................                      glcd_fillScreen(0);
292C:  CLRF   x73
292E:  MOVLB  0
2930:  CALL   0658
....................                      break;
2934:  MOVLB  2
....................                }
....................             }
....................             
....................             last_single_men = single_men;
2936:  MOVFF  21A,21B
....................             break;
293A:  GOTO   444E
293E:  MOVLB  0
....................          }
....................          case 'm':{ // multiplayer
....................             if(p1_pot_y >= 125){
2940:  MOVLB  2
2942:  MOVF   x0E,W
2944:  SUBLW  7C
2946:  BC    294E
....................                single_men = 1;
2948:  MOVLW  01
294A:  MOVWF  x1A
....................             }
294C:  BRA    2950
....................             else{
....................                single_men = 0;
294E:  CLRF   x1A
....................             }
....................             
....................             if(single_men != last_single_men){
2950:  MOVF   x1B,W
2952:  SUBWF  x1A,W
2954:  BZ    2968
....................                glcd_fillScreen(0);
2956:  CLRF   x73
2958:  MOVLB  0
295A:  CALL   0658
....................                single_menu(single_men);
295E:  MOVFF  21A,25D
2962:  CALL   0FC8
2966:  MOVLB  2
....................             }
....................             
....................             if(p1_L){
2968:  BTFSS  x11.0
296A:  BRA    299C
....................                switch(single_men){
296C:  MOVF   x1A,W
296E:  XORLW  00
2970:  MOVLB  0
2972:  BZ    297A
2974:  XORLW  01
2976:  BZ    298A
2978:  BRA    299A
....................                   case 0:
....................                      mode = 'i';
297A:  MOVLW  69
297C:  MOVLB  2
297E:  MOVWF  x0A
....................                      glcd_fillScreen(0);
2980:  CLRF   x73
2982:  MOVLB  0
2984:  CALL   0658
....................                      break;
2988:  BRA    299A
....................                   case 1:
....................                      mode = 'J';
298A:  MOVLW  4A
298C:  MOVLB  2
298E:  MOVWF  x0A
....................                      new_game = 1;
2990:  BSF    x1C.3
....................                      glcd_fillScreen(0);
2992:  CLRF   x73
2994:  MOVLB  0
2996:  CALL   0658
....................                      break;
299A:  MOVLB  2
....................                }
....................             }
....................             
....................             last_single_men = single_men;
299C:  MOVFF  21A,21B
....................             break;
29A0:  GOTO   444E
29A4:  MOVLB  0
....................          }
....................          case 'j':{ // jugnado single
....................             if(new_level){
29A6:  MOVLB  1
29A8:  BTFSS  x57.5
29AA:  BRA    2B58
....................                new_level = 0;
29AC:  BCF    x57.5
....................                for(int i = 0; i < 20; i++){
29AE:  MOVLB  2
29B0:  CLRF   x36
29B2:  MOVF   x36,W
29B4:  SUBLW  13
29B6:  BNC   2A02
....................                   asteroids_lifes[i] = levels[level][i];
29B8:  CLRF   03
29BA:  MOVF   x36,W
29BC:  ADDLW  1E
29BE:  MOVWF  FE9
29C0:  MOVLW  02
29C2:  ADDWFC 03,W
29C4:  MOVWF  FEA
29C6:  CLRF   x60
29C8:  MOVFF  200,25F
29CC:  CLRF   x62
29CE:  MOVLW  14
29D0:  MOVWF  x61
29D2:  MOVLB  0
29D4:  GOTO   110C
29D8:  MOVFF  02,260
29DC:  MOVFF  01,25F
29E0:  MOVLB  2
29E2:  MOVF   x36,W
29E4:  ADDWF  01,W
29E6:  MOVWF  01
29E8:  MOVLW  00
29EA:  ADDWFC 02,W
29EC:  MOVWF  03
29EE:  MOVF   01,W
29F0:  MOVFF  03,FF7
29F4:  MOVLB  0
29F6:  CALL   02AA
29FA:  MOVWF  FEF
29FC:  MOVLB  2
29FE:  INCF   x36,F
2A00:  BRA    29B2
....................                }
....................                if(!level){
2A02:  MOVF   x00,F
2A04:  BNZ   2A18
....................                   restart_screen();
2A06:  MOVLB  0
2A08:  GOTO   1130
....................                   //while(!p1_R);
....................                   x_pos = 63;
2A0C:  MOVLW  3F
2A0E:  MOVLB  1
2A10:  MOVWF  x4D
....................                   y_pos = 31;
2A12:  MOVLW  1F
2A14:  MOVWF  x4E
2A16:  MOVLB  2
....................                }
....................                level++;
2A18:  INCF   x00,F
....................                for(unsigned int i = 0; i < 20; i++){ // inicializar la posicion de los asteroides a la esquina superior izquierda de manera random
2A1A:  CLRF   x37
2A1C:  MOVF   x37,W
2A1E:  SUBLW  13
2A20:  BTFSS  FD8.0
2A22:  BRA    2B4A
....................                   asteroids_x_pos[i] = (int)(((float)i)/2.0f) % 10;
2A24:  CLRF   03
2A26:  MOVF   x37,W
2A28:  ADDLW  B0
2A2A:  MOVWF  FE9
2A2C:  MOVLW  01
2A2E:  ADDWFC 03,W
2A30:  MOVWF  FEA
2A32:  CLRF   x94
2A34:  MOVFF  237,293
2A38:  MOVLB  0
2A3A:  CALL   11AE
2A3E:  MOVFF  03,262
2A42:  MOVFF  02,261
2A46:  MOVFF  01,260
2A4A:  MOVFF  00,25F
2A4E:  MOVFF  03,268
2A52:  MOVFF  02,267
2A56:  MOVFF  01,266
2A5A:  MOVFF  00,265
2A5E:  MOVLB  2
2A60:  CLRF   x6C
2A62:  CLRF   x6B
2A64:  CLRF   x6A
2A66:  MOVLW  80
2A68:  MOVWF  x69
2A6A:  MOVLB  0
2A6C:  CALL   11E4
2A70:  MOVFF  03,292
2A74:  MOVFF  02,291
2A78:  MOVFF  01,290
2A7C:  MOVFF  00,28F
2A80:  CALL   1342
2A84:  MOVFF  01,26D
2A88:  MOVLW  0A
2A8A:  MOVLB  2
2A8C:  MOVWF  x6E
2A8E:  MOVLB  0
2A90:  CALL   137E
2A94:  MOVFF  00,FEF
....................                   asteroids_x_pos[i] = (int)((20.0f-(float)i)/2.0f) % 10;
2A98:  CLRF   03
2A9A:  MOVLB  2
2A9C:  MOVF   x37,W
2A9E:  ADDLW  B0
2AA0:  MOVWF  FE9
2AA2:  MOVLW  01
2AA4:  ADDWFC 03,W
2AA6:  MOVWF  FEA
2AA8:  CLRF   x94
2AAA:  MOVFF  237,293
2AAE:  MOVLB  0
2AB0:  CALL   11AE
2AB4:  MOVFF  FEA,260
2AB8:  MOVFF  FE9,25F
2ABC:  BSF    FD8.1
2ABE:  MOVLB  2
2AC0:  CLRF   x96
2AC2:  CLRF   x95
2AC4:  MOVLW  20
2AC6:  MOVWF  x94
2AC8:  MOVLW  83
2ACA:  MOVWF  x93
2ACC:  MOVFF  03,29A
2AD0:  MOVFF  02,299
2AD4:  MOVFF  01,298
2AD8:  MOVFF  00,297
2ADC:  MOVLB  0
2ADE:  CALL   13AA
2AE2:  MOVFF  260,FEA
2AE6:  MOVFF  25F,FE9
2AEA:  MOVFF  03,264
2AEE:  MOVFF  02,263
2AF2:  MOVFF  01,262
2AF6:  MOVFF  00,261
2AFA:  MOVFF  03,268
2AFE:  MOVFF  02,267
2B02:  MOVFF  01,266
2B06:  MOVFF  00,265
2B0A:  MOVLB  2
2B0C:  CLRF   x6C
2B0E:  CLRF   x6B
2B10:  CLRF   x6A
2B12:  MOVLW  80
2B14:  MOVWF  x69
2B16:  MOVLB  0
2B18:  CALL   11E4
2B1C:  MOVFF  03,292
2B20:  MOVFF  02,291
2B24:  MOVFF  01,290
2B28:  MOVFF  00,28F
2B2C:  CALL   1342
2B30:  MOVFF  01,26D
2B34:  MOVLW  0A
2B36:  MOVLB  2
2B38:  MOVWF  x6E
2B3A:  MOVLB  0
2B3C:  CALL   137E
2B40:  MOVFF  00,FEF
2B44:  MOVLB  2
2B46:  INCF   x37,F
2B48:  BRA    2A1C
....................                }
....................                glcd_fillScreen(0);
2B4A:  CLRF   x73
2B4C:  MOVLB  0
2B4E:  CALL   0658
....................             }
2B52:  GOTO   3A22
2B56:  MOVLB  1
....................             else{
....................                ship_angle = (get_ship_angle()*3.1416f)/180.0f; // potenciometros angulos
2B58:  MOVLB  0
2B5A:  GOTO   1622
2B5E:  MOVFF  03,260
2B62:  MOVFF  02,25F
2B66:  MOVFF  01,25E
2B6A:  MOVFF  00,25D
2B6E:  MOVFF  03,296
2B72:  MOVFF  02,295
2B76:  MOVFF  01,294
2B7A:  MOVFF  00,293
2B7E:  MOVLW  F9
2B80:  MOVLB  2
2B82:  MOVWF  x9A
2B84:  MOVLW  0F
2B86:  MOVWF  x99
2B88:  MOVLW  49
2B8A:  MOVWF  x98
2B8C:  MOVLW  80
2B8E:  MOVWF  x97
2B90:  MOVLB  0
2B92:  CALL   16E0
2B96:  MOVFF  03,260
2B9A:  MOVFF  02,25F
2B9E:  MOVFF  01,25E
2BA2:  MOVFF  00,25D
2BA6:  MOVFF  03,268
2BAA:  MOVFF  02,267
2BAE:  MOVFF  01,266
2BB2:  MOVFF  00,265
2BB6:  MOVLB  2
2BB8:  CLRF   x6C
2BBA:  CLRF   x6B
2BBC:  MOVLW  34
2BBE:  MOVWF  x6A
2BC0:  MOVLW  86
2BC2:  MOVWF  x69
2BC4:  MOVLB  0
2BC6:  CALL   11E4
2BCA:  MOVFF  03,14A
2BCE:  MOVFF  02,149
2BD2:  MOVFF  01,148
2BD6:  MOVFF  00,147
.................... 
....................          dx = get_x_vel(); // potenciometro movimiento
2BDA:  GOTO   17D6
2BDE:  MOVFF  03,152
2BE2:  MOVFF  02,151
2BE6:  MOVFF  01,150
2BEA:  MOVFF  00,14F
....................          dy = get_y_vel(); // potenciometro movimiento
2BEE:  GOTO   184C
2BF2:  MOVFF  03,156
2BF6:  MOVFF  02,155
2BFA:  MOVFF  01,154
2BFE:  MOVFF  00,153
....................          if((float)x_pos + dx < 0) // mover jugador
2C02:  MOVLB  2
2C04:  CLRF   x94
2C06:  MOVFF  14D,293
2C0A:  MOVLB  0
2C0C:  CALL   11AE
2C10:  MOVFF  03,260
2C14:  MOVFF  02,25F
2C18:  MOVFF  01,25E
2C1C:  MOVFF  00,25D
2C20:  BCF    FD8.1
2C22:  MOVFF  03,296
2C26:  MOVFF  02,295
2C2A:  MOVFF  01,294
2C2E:  MOVFF  00,293
2C32:  MOVFF  152,29A
2C36:  MOVFF  151,299
2C3A:  MOVFF  150,298
2C3E:  MOVFF  14F,297
2C42:  CALL   13AA
2C46:  MOVFF  03,260
2C4A:  MOVFF  02,25F
2C4E:  MOVFF  01,25E
2C52:  MOVFF  00,25D
2C56:  MOVFF  03,292
2C5A:  MOVFF  02,291
2C5E:  MOVFF  01,290
2C62:  MOVFF  00,28F
2C66:  MOVLB  2
2C68:  CLRF   x96
2C6A:  CLRF   x95
2C6C:  CLRF   x94
2C6E:  CLRF   x93
2C70:  MOVLB  0
2C72:  CALL   18C2
2C76:  BNC   2CDC
....................             x_pos = 127 + (int)((float)x_pos + dx);
2C78:  MOVLB  2
2C7A:  CLRF   x94
2C7C:  MOVFF  14D,293
2C80:  MOVLB  0
2C82:  CALL   11AE
2C86:  MOVFF  03,260
2C8A:  MOVFF  02,25F
2C8E:  MOVFF  01,25E
2C92:  MOVFF  00,25D
2C96:  BCF    FD8.1
2C98:  MOVFF  03,296
2C9C:  MOVFF  02,295
2CA0:  MOVFF  01,294
2CA4:  MOVFF  00,293
2CA8:  MOVFF  152,29A
2CAC:  MOVFF  151,299
2CB0:  MOVFF  150,298
2CB4:  MOVFF  14F,297
2CB8:  CALL   13AA
2CBC:  MOVFF  03,292
2CC0:  MOVFF  02,291
2CC4:  MOVFF  01,290
2CC8:  MOVFF  00,28F
2CCC:  CALL   1342
2CD0:  MOVLW  7F
2CD2:  ADDWF  01,W
2CD4:  MOVLB  1
2CD6:  MOVWF  x4D
2CD8:  BRA    2D0C
2CDA:  MOVLB  0
....................          else
....................             x_pos = (x_pos + (int)dx) % 127;
2CDC:  MOVFF  152,292
2CE0:  MOVFF  151,291
2CE4:  MOVFF  150,290
2CE8:  MOVFF  14F,28F
2CEC:  CALL   1342
2CF0:  MOVF   01,W
2CF2:  MOVLB  1
2CF4:  ADDWF  x4D,W
2CF6:  MOVLB  2
2CF8:  MOVWF  x5E
2CFA:  MOVWF  x6D
2CFC:  MOVLW  7F
2CFE:  MOVWF  x6E
2D00:  MOVLB  0
2D02:  CALL   137E
2D06:  MOVFF  00,14D
2D0A:  MOVLB  1
.................... 
....................          if((float)y_pos - dy < 0) // mover jugador
2D0C:  MOVLB  2
2D0E:  CLRF   x94
2D10:  MOVFF  14E,293
2D14:  MOVLB  0
2D16:  CALL   11AE
2D1A:  MOVFF  03,260
2D1E:  MOVFF  02,25F
2D22:  MOVFF  01,25E
2D26:  MOVFF  00,25D
2D2A:  BSF    FD8.1
2D2C:  MOVFF  03,296
2D30:  MOVFF  02,295
2D34:  MOVFF  01,294
2D38:  MOVFF  00,293
2D3C:  MOVFF  156,29A
2D40:  MOVFF  155,299
2D44:  MOVFF  154,298
2D48:  MOVFF  153,297
2D4C:  CALL   13AA
2D50:  MOVFF  03,260
2D54:  MOVFF  02,25F
2D58:  MOVFF  01,25E
2D5C:  MOVFF  00,25D
2D60:  MOVFF  03,292
2D64:  MOVFF  02,291
2D68:  MOVFF  01,290
2D6C:  MOVFF  00,28F
2D70:  MOVLB  2
2D72:  CLRF   x96
2D74:  CLRF   x95
2D76:  CLRF   x94
2D78:  CLRF   x93
2D7A:  MOVLB  0
2D7C:  CALL   18C2
2D80:  BNC   2DE6
....................             y_pos = 63 + (int)((float)y_pos - dy);
2D82:  MOVLB  2
2D84:  CLRF   x94
2D86:  MOVFF  14E,293
2D8A:  MOVLB  0
2D8C:  CALL   11AE
2D90:  MOVFF  03,260
2D94:  MOVFF  02,25F
2D98:  MOVFF  01,25E
2D9C:  MOVFF  00,25D
2DA0:  BSF    FD8.1
2DA2:  MOVFF  03,296
2DA6:  MOVFF  02,295
2DAA:  MOVFF  01,294
2DAE:  MOVFF  00,293
2DB2:  MOVFF  156,29A
2DB6:  MOVFF  155,299
2DBA:  MOVFF  154,298
2DBE:  MOVFF  153,297
2DC2:  CALL   13AA
2DC6:  MOVFF  03,292
2DCA:  MOVFF  02,291
2DCE:  MOVFF  01,290
2DD2:  MOVFF  00,28F
2DD6:  CALL   1342
2DDA:  MOVLW  3F
2DDC:  ADDWF  01,W
2DDE:  MOVLB  1
2DE0:  MOVWF  x4E
2DE2:  BRA    2E16
2DE4:  MOVLB  0
....................          else
....................             y_pos = (y_pos - (int)dy) % 63;
2DE6:  MOVFF  156,292
2DEA:  MOVFF  155,291
2DEE:  MOVFF  154,290
2DF2:  MOVFF  153,28F
2DF6:  CALL   1342
2DFA:  MOVF   01,W
2DFC:  MOVLB  1
2DFE:  SUBWF  x4E,W
2E00:  MOVLB  2
2E02:  MOVWF  x5E
2E04:  MOVWF  x6D
2E06:  MOVLW  3F
2E08:  MOVWF  x6E
2E0A:  MOVLB  0
2E0C:  CALL   137E
2E10:  MOVFF  00,14E
2E14:  MOVLB  1
.................... 
....................          for(unsigned int i = 0; i < 20; i++){ // mover asteroides
2E16:  MOVLB  2
2E18:  CLRF   x38
2E1A:  MOVF   x38,W
2E1C:  SUBLW  13
2E1E:  BTFSS  FD8.0
2E20:  BRA    305A
....................             if((signed int)asteroids_x_pos[i] + asteroids_dx[i] < 0)
2E22:  CLRF   03
2E24:  MOVF   x38,W
2E26:  ADDLW  B0
2E28:  MOVWF  FE9
2E2A:  MOVLW  01
2E2C:  ADDWFC 03,W
2E2E:  MOVWF  FEA
2E30:  MOVFF  FEF,25D
2E34:  CLRF   03
2E36:  MOVF   x38,W
2E38:  ADDLW  D8
2E3A:  MOVWF  FE9
2E3C:  MOVLW  01
2E3E:  ADDWFC 03,W
2E40:  MOVWF  FEA
2E42:  MOVF   FEF,W
2E44:  ADDWF  x5D,W
2E46:  MOVWF  00
2E48:  BTFSS  FE8.7
2E4A:  BRA    2E94
....................                asteroids_x_pos[i] = 127 + ((signed int)asteroids_x_pos[i] + asteroids_dx[i]);
2E4C:  CLRF   03
2E4E:  MOVF   x38,W
2E50:  ADDLW  B0
2E52:  MOVWF  01
2E54:  MOVLW  01
2E56:  ADDWFC 03,F
2E58:  MOVFF  01,25D
2E5C:  MOVFF  03,25E
2E60:  CLRF   03
2E62:  MOVF   x38,W
2E64:  ADDLW  B0
2E66:  MOVWF  FE9
2E68:  MOVLW  01
2E6A:  ADDWFC 03,W
2E6C:  MOVWF  FEA
2E6E:  MOVFF  FEF,25F
2E72:  CLRF   03
2E74:  MOVF   x38,W
2E76:  ADDLW  D8
2E78:  MOVWF  FE9
2E7A:  MOVLW  01
2E7C:  ADDWFC 03,W
2E7E:  MOVWF  FEA
2E80:  MOVF   FEF,W
2E82:  ADDWF  x5F,W
2E84:  ADDLW  7F
2E86:  MOVWF  x5F
2E88:  MOVFF  25E,FEA
2E8C:  MOVFF  01,FE9
2E90:  MOVWF  FEF
2E92:  BRA    2F3C
....................             else if(asteroids_x_pos[i] + (unsigned int)asteroids_dx[i] > 127)
2E94:  CLRF   03
2E96:  MOVF   x38,W
2E98:  ADDLW  B0
2E9A:  MOVWF  FE9
2E9C:  MOVLW  01
2E9E:  ADDWFC 03,W
2EA0:  MOVWF  FEA
2EA2:  MOVFF  FEF,25D
2EA6:  CLRF   03
2EA8:  MOVF   x38,W
2EAA:  ADDLW  D8
2EAC:  MOVWF  FE9
2EAE:  MOVLW  01
2EB0:  ADDWFC 03,W
2EB2:  MOVWF  FEA
2EB4:  MOVF   FEF,W
2EB6:  ADDWF  x5D,W
2EB8:  SUBLW  7F
2EBA:  BC    2F04
....................                asteroids_x_pos[i] = 0 + ((asteroids_x_pos[i] + (unsigned int)asteroids_dx[i])-127);
2EBC:  CLRF   03
2EBE:  MOVF   x38,W
2EC0:  ADDLW  B0
2EC2:  MOVWF  01
2EC4:  MOVLW  01
2EC6:  ADDWFC 03,F
2EC8:  MOVFF  01,25D
2ECC:  MOVFF  03,25E
2ED0:  CLRF   03
2ED2:  MOVF   x38,W
2ED4:  ADDLW  B0
2ED6:  MOVWF  FE9
2ED8:  MOVLW  01
2EDA:  ADDWFC 03,W
2EDC:  MOVWF  FEA
2EDE:  MOVFF  FEF,25F
2EE2:  CLRF   03
2EE4:  MOVF   x38,W
2EE6:  ADDLW  D8
2EE8:  MOVWF  FE9
2EEA:  MOVLW  01
2EEC:  ADDWFC 03,W
2EEE:  MOVWF  FEA
2EF0:  MOVF   FEF,W
2EF2:  ADDWF  x5F,W
2EF4:  ADDLW  81
2EF6:  MOVWF  x5F
2EF8:  MOVFF  25E,FEA
2EFC:  MOVFF  01,FE9
2F00:  MOVWF  FEF
2F02:  BRA    2F3C
....................             else
....................                asteroids_x_pos[i] += asteroids_dx[i];
2F04:  CLRF   03
2F06:  MOVF   x38,W
2F08:  ADDLW  B0
2F0A:  MOVWF  01
2F0C:  MOVLW  01
2F0E:  ADDWFC 03,F
2F10:  MOVFF  03,25E
2F14:  MOVFF  03,FEA
2F18:  MOVFF  01,FE9
2F1C:  MOVFF  FEF,25F
2F20:  CLRF   03
2F22:  MOVF   x38,W
2F24:  ADDLW  D8
2F26:  MOVWF  FE9
2F28:  MOVLW  01
2F2A:  ADDWFC 03,W
2F2C:  MOVWF  FEA
2F2E:  MOVF   FEF,W
2F30:  ADDWF  x5F,W
2F32:  MOVFF  25E,FEA
2F36:  MOVFF  01,FE9
2F3A:  MOVWF  FEF
.................... 
....................             if((signed int)asteroids_y_pos[i] + asteroids_dy[i] < 0)
2F3C:  CLRF   03
2F3E:  MOVF   x38,W
2F40:  ADDLW  C4
2F42:  MOVWF  FE9
2F44:  MOVLW  01
2F46:  ADDWFC 03,W
2F48:  MOVWF  FEA
2F4A:  MOVFF  FEF,25D
2F4E:  CLRF   03
2F50:  MOVF   x38,W
2F52:  ADDLW  EC
2F54:  MOVWF  FE9
2F56:  MOVLW  01
2F58:  ADDWFC 03,W
2F5A:  MOVWF  FEA
2F5C:  MOVF   FEF,W
2F5E:  ADDWF  x5D,W
2F60:  MOVWF  00
2F62:  BTFSS  FE8.7
2F64:  BRA    2FAE
....................                asteroids_y_pos[i] = 63 + ((signed int)asteroids_y_pos[i] + asteroids_dy[i]);
2F66:  CLRF   03
2F68:  MOVF   x38,W
2F6A:  ADDLW  C4
2F6C:  MOVWF  01
2F6E:  MOVLW  01
2F70:  ADDWFC 03,F
2F72:  MOVFF  01,25D
2F76:  MOVFF  03,25E
2F7A:  CLRF   03
2F7C:  MOVF   x38,W
2F7E:  ADDLW  C4
2F80:  MOVWF  FE9
2F82:  MOVLW  01
2F84:  ADDWFC 03,W
2F86:  MOVWF  FEA
2F88:  MOVFF  FEF,25F
2F8C:  CLRF   03
2F8E:  MOVF   x38,W
2F90:  ADDLW  EC
2F92:  MOVWF  FE9
2F94:  MOVLW  01
2F96:  ADDWFC 03,W
2F98:  MOVWF  FEA
2F9A:  MOVF   FEF,W
2F9C:  ADDWF  x5F,W
2F9E:  ADDLW  3F
2FA0:  MOVWF  x5F
2FA2:  MOVFF  25E,FEA
2FA6:  MOVFF  01,FE9
2FAA:  MOVWF  FEF
2FAC:  BRA    3056
....................             else if(asteroids_y_pos[i] + (unsigned int)asteroids_dy[i] > 63)
2FAE:  CLRF   03
2FB0:  MOVF   x38,W
2FB2:  ADDLW  C4
2FB4:  MOVWF  FE9
2FB6:  MOVLW  01
2FB8:  ADDWFC 03,W
2FBA:  MOVWF  FEA
2FBC:  MOVFF  FEF,25D
2FC0:  CLRF   03
2FC2:  MOVF   x38,W
2FC4:  ADDLW  EC
2FC6:  MOVWF  FE9
2FC8:  MOVLW  01
2FCA:  ADDWFC 03,W
2FCC:  MOVWF  FEA
2FCE:  MOVF   FEF,W
2FD0:  ADDWF  x5D,W
2FD2:  SUBLW  3F
2FD4:  BC    301E
....................                asteroids_y_pos[i] = 0 + ((asteroids_y_pos[i] + (unsigned int)asteroids_dy[i])-63);
2FD6:  CLRF   03
2FD8:  MOVF   x38,W
2FDA:  ADDLW  C4
2FDC:  MOVWF  01
2FDE:  MOVLW  01
2FE0:  ADDWFC 03,F
2FE2:  MOVFF  01,25D
2FE6:  MOVFF  03,25E
2FEA:  CLRF   03
2FEC:  MOVF   x38,W
2FEE:  ADDLW  C4
2FF0:  MOVWF  FE9
2FF2:  MOVLW  01
2FF4:  ADDWFC 03,W
2FF6:  MOVWF  FEA
2FF8:  MOVFF  FEF,25F
2FFC:  CLRF   03
2FFE:  MOVF   x38,W
3000:  ADDLW  EC
3002:  MOVWF  FE9
3004:  MOVLW  01
3006:  ADDWFC 03,W
3008:  MOVWF  FEA
300A:  MOVF   FEF,W
300C:  ADDWF  x5F,W
300E:  ADDLW  C1
3010:  MOVWF  x5F
3012:  MOVFF  25E,FEA
3016:  MOVFF  01,FE9
301A:  MOVWF  FEF
301C:  BRA    3056
....................             else
....................                asteroids_y_pos[i] += asteroids_dy[i];
301E:  CLRF   03
3020:  MOVF   x38,W
3022:  ADDLW  C4
3024:  MOVWF  01
3026:  MOVLW  01
3028:  ADDWFC 03,F
302A:  MOVFF  03,25E
302E:  MOVFF  03,FEA
3032:  MOVFF  01,FE9
3036:  MOVFF  FEF,25F
303A:  CLRF   03
303C:  MOVF   x38,W
303E:  ADDLW  EC
3040:  MOVWF  FE9
3042:  MOVLW  01
3044:  ADDWFC 03,W
3046:  MOVWF  FEA
3048:  MOVF   FEF,W
304A:  ADDWF  x5F,W
304C:  MOVFF  25E,FEA
3050:  MOVFF  01,FE9
3054:  MOVWF  FEF
3056:  INCF   x38,F
3058:  BRA    2E1A
....................          }
....................          
....................          for(unsigned int i = 0; i < 20; i++){ // checar si la posicion del jugador coincide con algun asteroide
305A:  CLRF   x39
305C:  MOVF   x39,W
305E:  SUBLW  13
3060:  BTFSS  FD8.0
3062:  BRA    3158
....................             if(asteroids_lifes[i]){
3064:  CLRF   03
3066:  MOVF   x39,W
3068:  ADDLW  1E
306A:  MOVWF  FE9
306C:  MOVLW  02
306E:  ADDWFC 03,W
3070:  MOVWF  FEA
3072:  MOVF   FEF,F
3074:  BTFSC  FD8.2
3076:  BRA    3150
....................                if( ((x_pos > asteroids_x_pos[i])  && (x_pos < (asteroids_x_pos[i] + asteroids_lifes[i]*8) )) && ((y_pos > asteroids_y_pos[i])  && (y_pos < (asteroids_y_pos[i] + asteroids_lifes[i]*8) )) ){ // perder
3078:  CLRF   03
307A:  MOVF   x39,W
307C:  ADDLW  B0
307E:  MOVWF  FE9
3080:  MOVLW  01
3082:  ADDWFC 03,W
3084:  MOVWF  FEA
3086:  MOVF   FEF,W
3088:  MOVLB  1
308A:  SUBWF  x4D,W
308C:  BZ    3152
308E:  BNC   3152
3090:  CLRF   03
3092:  MOVLB  2
3094:  MOVF   x39,W
3096:  ADDLW  B0
3098:  MOVWF  FE9
309A:  MOVLW  01
309C:  ADDWFC 03,W
309E:  MOVWF  FEA
30A0:  MOVFF  FEF,25D
30A4:  CLRF   03
30A6:  MOVF   x39,W
30A8:  ADDLW  1E
30AA:  MOVWF  FE9
30AC:  MOVLW  02
30AE:  ADDWFC 03,W
30B0:  MOVWF  FEA
30B2:  MOVF   FEF,W
30B4:  MULLW  08
30B6:  MOVF   FF3,W
30B8:  ADDWF  x5D,W
30BA:  MOVLB  1
30BC:  SUBWF  x4D,W
30BE:  BC    3152
30C0:  CLRF   03
30C2:  MOVLB  2
30C4:  MOVF   x39,W
30C6:  ADDLW  C4
30C8:  MOVWF  FE9
30CA:  MOVLW  01
30CC:  ADDWFC 03,W
30CE:  MOVWF  FEA
30D0:  MOVF   FEF,W
30D2:  MOVLB  1
30D4:  SUBWF  x4E,W
30D6:  BZ    3152
30D8:  BNC   3152
30DA:  CLRF   03
30DC:  MOVLB  2
30DE:  MOVF   x39,W
30E0:  ADDLW  C4
30E2:  MOVWF  FE9
30E4:  MOVLW  01
30E6:  ADDWFC 03,W
30E8:  MOVWF  FEA
30EA:  MOVFF  FEF,25D
30EE:  CLRF   03
30F0:  MOVF   x39,W
30F2:  ADDLW  1E
30F4:  MOVWF  FE9
30F6:  MOVLW  02
30F8:  ADDWFC 03,W
30FA:  MOVWF  FEA
30FC:  MOVF   FEF,W
30FE:  MULLW  08
3100:  MOVF   FF3,W
3102:  ADDWF  x5D,W
3104:  MOVLB  1
3106:  SUBWF  x4E,W
3108:  BC    3152
....................                   mode = 'i';
310A:  MOVLW  69
310C:  MOVLB  2
310E:  MOVWF  x0A
....................                   new_level = 1;
3110:  MOVLB  1
3112:  BSF    x57.5
....................                   glcd_fillScreen(0);
3114:  MOVLB  2
3116:  CLRF   x73
3118:  MOVLB  0
311A:  CALL   0658
....................                   inicio(0);
311E:  MOVLB  2
3120:  CLRF   x5D
3122:  MOVLB  0
3124:  CALL   0C10
....................                   if(score > best_score)
3128:  MOVLB  2
312A:  MOVF   x05,W
312C:  SUBWF  x03,W
312E:  BNC   3140
3130:  BNZ   3138
3132:  MOVF   x02,W
3134:  SUBWF  x04,W
3136:  BC    3140
....................                      best_score = score;
3138:  MOVFF  203,205
313C:  MOVFF  202,204
....................                   if(level > best_level)
3140:  MOVF   x00,W
3142:  SUBWF  x01,W
3144:  BC    314A
....................                      best_level = level;
3146:  MOVFF  200,201
....................                   score = 0;
314A:  CLRF   x03
314C:  CLRF   x02
....................                   level = 0;
314E:  CLRF   x00
3150:  MOVLB  1
....................                }
....................             }
3152:  MOVLB  2
3154:  INCF   x39,F
3156:  BRA    305C
....................          }
....................          
.................... 
....................          if(bullet){ // si hay una bala, calcular su posicion, y si hay impacto o se pierde la bala
3158:  MOVLB  1
315A:  BTFSS  x57.0
315C:  BRA    3414
....................             bullet_x_pos += (signed int)bullet_dx;
315E:  MOVFF  163,292
3162:  MOVFF  162,291
3166:  MOVFF  161,290
316A:  MOVFF  160,28F
316E:  MOVLB  0
3170:  CALL   1342
3174:  CLRF   03
3176:  MOVF   01,W
3178:  BTFSC  FE8.7
317A:  DECF   03,F
317C:  MOVLB  1
317E:  ADDWF  x5C,F
3180:  MOVF   03,W
3182:  ADDWFC x5D,F
....................             bullet_y_pos += (signed int)bullet_dy;
3184:  MOVFF  167,292
3188:  MOVFF  166,291
318C:  MOVFF  165,290
3190:  MOVFF  164,28F
3194:  MOVLB  0
3196:  CALL   1342
319A:  CLRF   03
319C:  MOVF   01,W
319E:  BTFSC  FE8.7
31A0:  DECF   03,F
31A2:  MOVLB  1
31A4:  ADDWF  x5E,F
31A6:  MOVF   03,W
31A8:  ADDWFC x5F,F
....................             // checar collision con asteroides
....................             for(int i = 0; i < 20; i++){
31AA:  MOVLB  2
31AC:  CLRF   x3A
31AE:  MOVF   x3A,W
31B0:  SUBLW  13
31B2:  BTFSS  FD8.0
31B4:  BRA    336E
....................                if(asteroids_lifes[i]){
31B6:  CLRF   03
31B8:  MOVF   x3A,W
31BA:  ADDLW  1E
31BC:  MOVWF  FE9
31BE:  MOVLW  02
31C0:  ADDWFC 03,W
31C2:  MOVWF  FEA
31C4:  MOVF   FEF,F
31C6:  BTFSC  FD8.2
31C8:  BRA    3366
....................                   if( ( ((bullet_x_pos > asteroids_x_pos[i])  && (bullet_x_pos < (asteroids_x_pos[i] + asteroids_lifes[i]*8) )) && ((bullet_y_pos > asteroids_y_pos[i])  && (bullet_y_pos < (asteroids_y_pos[i] + asteroids_lifes[i]*8) )) ) || ( ((last_bullet_x_pos > asteroids_x_pos[i])  && (last_bullet_x_pos < (asteroids_x_pos[i] + asteroids_lifes[i]*8) )) && ((last_bullet_y_pos > asteroids_y_pos[i])  && (last_bullet_y_pos < (asteroids_y_pos[i] + asteroids_lifes[i]*8) )) ) ){
31CA:  CLRF   03
31CC:  MOVF   x3A,W
31CE:  ADDLW  B0
31D0:  MOVWF  FE9
31D2:  MOVLW  01
31D4:  ADDWFC 03,W
31D6:  MOVWF  FEA
31D8:  MOVF   FEF,W
31DA:  MOVLB  1
31DC:  BTFSC  x5D.7
31DE:  BRA    327C
31E0:  MOVF   x5D,F
31E2:  BNZ   31EA
31E4:  SUBWF  x5C,W
31E6:  BZ    327C
31E8:  BNC   327C
31EA:  CLRF   03
31EC:  MOVLB  2
31EE:  MOVF   x3A,W
31F0:  ADDLW  B0
31F2:  MOVWF  FE9
31F4:  MOVLW  01
31F6:  ADDWFC 03,W
31F8:  MOVWF  FEA
31FA:  MOVFF  FEF,25D
31FE:  CLRF   03
3200:  MOVF   x3A,W
3202:  ADDLW  1E
3204:  MOVWF  FE9
3206:  MOVLW  02
3208:  ADDWFC 03,W
320A:  MOVWF  FEA
320C:  MOVF   FEF,W
320E:  MULLW  08
3210:  MOVF   FF3,W
3212:  ADDWF  x5D,W
3214:  MOVLB  1
3216:  BTFSC  x5D.7
3218:  BRA    3222
321A:  MOVF   x5D,F
321C:  BNZ   327C
321E:  SUBWF  x5C,W
3220:  BC    327C
3222:  CLRF   03
3224:  MOVLB  2
3226:  MOVF   x3A,W
3228:  ADDLW  C4
322A:  MOVWF  FE9
322C:  MOVLW  01
322E:  ADDWFC 03,W
3230:  MOVWF  FEA
3232:  MOVF   FEF,W
3234:  MOVLB  1
3236:  BTFSC  x5F.7
3238:  BRA    327C
323A:  MOVF   x5F,F
323C:  BNZ   3244
323E:  SUBWF  x5E,W
3240:  BZ    327C
3242:  BNC   327C
3244:  CLRF   03
3246:  MOVLB  2
3248:  MOVF   x3A,W
324A:  ADDLW  C4
324C:  MOVWF  FE9
324E:  MOVLW  01
3250:  ADDWFC 03,W
3252:  MOVWF  FEA
3254:  MOVFF  FEF,25D
3258:  CLRF   03
325A:  MOVF   x3A,W
325C:  ADDLW  1E
325E:  MOVWF  FE9
3260:  MOVLW  02
3262:  ADDWFC 03,W
3264:  MOVWF  FEA
3266:  MOVF   FEF,W
3268:  MULLW  08
326A:  MOVF   FF3,W
326C:  ADDWF  x5D,W
326E:  MOVLB  1
3270:  BTFSC  x5F.7
3272:  BRA    3320
3274:  MOVF   x5F,F
3276:  BNZ   327C
3278:  SUBWF  x5E,W
327A:  BNC   3320
327C:  CLRF   03
327E:  MOVLB  2
3280:  MOVF   x3A,W
3282:  ADDLW  B0
3284:  MOVWF  FE9
3286:  MOVLW  01
3288:  ADDWFC 03,W
328A:  MOVWF  FEA
328C:  MOVF   FEF,W
328E:  MOVLB  1
3290:  BTFSC  x5A.7
3292:  BRA    3368
3294:  SUBWF  x5A,W
3296:  BZ    3368
3298:  BNC   3368
329A:  CLRF   03
329C:  MOVLB  2
329E:  MOVF   x3A,W
32A0:  ADDLW  B0
32A2:  MOVWF  FE9
32A4:  MOVLW  01
32A6:  ADDWFC 03,W
32A8:  MOVWF  FEA
32AA:  MOVFF  FEF,25D
32AE:  CLRF   03
32B0:  MOVF   x3A,W
32B2:  ADDLW  1E
32B4:  MOVWF  FE9
32B6:  MOVLW  02
32B8:  ADDWFC 03,W
32BA:  MOVWF  FEA
32BC:  MOVF   FEF,W
32BE:  MULLW  08
32C0:  MOVF   FF3,W
32C2:  ADDWF  x5D,W
32C4:  MOVLB  1
32C6:  BTFSC  x5A.7
32C8:  BRA    32CE
32CA:  SUBWF  x5A,W
32CC:  BC    3368
32CE:  CLRF   03
32D0:  MOVLB  2
32D2:  MOVF   x3A,W
32D4:  ADDLW  C4
32D6:  MOVWF  FE9
32D8:  MOVLW  01
32DA:  ADDWFC 03,W
32DC:  MOVWF  FEA
32DE:  MOVF   FEF,W
32E0:  MOVLB  1
32E2:  BTFSC  x5B.7
32E4:  BRA    3368
32E6:  SUBWF  x5B,W
32E8:  BZ    3368
32EA:  BNC   3368
32EC:  CLRF   03
32EE:  MOVLB  2
32F0:  MOVF   x3A,W
32F2:  ADDLW  C4
32F4:  MOVWF  FE9
32F6:  MOVLW  01
32F8:  ADDWFC 03,W
32FA:  MOVWF  FEA
32FC:  MOVFF  FEF,25D
3300:  CLRF   03
3302:  MOVF   x3A,W
3304:  ADDLW  1E
3306:  MOVWF  FE9
3308:  MOVLW  02
330A:  ADDWFC 03,W
330C:  MOVWF  FEA
330E:  MOVF   FEF,W
3310:  MULLW  08
3312:  MOVF   FF3,W
3314:  ADDWF  x5D,W
3316:  MOVLB  1
3318:  BTFSC  x5B.7
331A:  BRA    3320
331C:  SUBWF  x5B,W
331E:  BC    3368
....................                      score += (4-asteroids_lifes[i]);
3320:  CLRF   03
3322:  MOVLB  2
3324:  MOVF   x3A,W
3326:  ADDLW  1E
3328:  MOVWF  FE9
332A:  MOVLW  02
332C:  ADDWFC 03,W
332E:  MOVWF  FEA
3330:  MOVF   FEF,W
3332:  XORLW  FF
3334:  ADDLW  05
3336:  ADDWF  x02,F
3338:  MOVLW  00
333A:  ADDWFC x03,F
....................                      asteroids_lifes[i]--;
333C:  CLRF   03
333E:  MOVF   x3A,W
3340:  ADDLW  1E
3342:  MOVWF  FE9
3344:  MOVLW  02
3346:  ADDWFC 03,W
3348:  MOVWF  FEA
334A:  DECF   FEF,F
....................                      asteroid_lost_a_life[i] = 1;
334C:  MOVFF  23A,25D
3350:  MOVLW  01
3352:  MOVWF  x5E
3354:  MOVLW  02
3356:  MOVWF  x60
3358:  MOVLW  32
335A:  MOVWF  x5F
335C:  MOVLB  0
335E:  CALL   193C
....................                      bullet_collision = 1;
3362:  MOVLB  2
3364:  BSF    x1C.2
3366:  MOVLB  1
....................                   }
....................                }
3368:  MOVLB  2
336A:  INCF   x3A,F
336C:  BRA    31AE
....................             }
.................... 
.................... 
....................             glcd_line(last_last_bullet_x_pos,last_last_bullet_y_pos,last_bullet_x_pos,last_bullet_y_pos,0);
336E:  MOVFF  158,283
3372:  MOVFF  159,284
3376:  MOVFF  15A,285
337A:  MOVFF  15B,286
337E:  CLRF   x87
3380:  MOVLB  0
3382:  CALL   0A70
....................             glcd_line(last_bullet_x_pos,last_bullet_y_pos,bullet_x_pos,bullet_y_pos,1);
3386:  MOVFF  15A,283
338A:  MOVFF  15B,284
338E:  MOVFF  15C,285
3392:  MOVFF  15E,286
3396:  MOVLW  01
3398:  MOVLB  2
339A:  MOVWF  x87
339C:  MOVLB  0
339E:  CALL   0A70
....................             if(!bullet_collision){ // si no hay colision, checar si se pierde la bala
33A2:  MOVLB  2
33A4:  BTFSC  x1C.2
33A6:  BRA    33F0
....................                if(bullet_x_pos > 127 || bullet_x_pos < 0 || bullet_y_pos > 63 || bullet_y_pos < 0){ // bala sali
33A8:  MOVLB  1
33AA:  BTFSC  x5D.7
33AC:  BRA    33B8
33AE:  MOVF   x5D,F
33B0:  BNZ   33CE
33B2:  MOVF   x5C,W
33B4:  SUBLW  7F
33B6:  BNC   33CE
33B8:  BTFSC  x5D.7
33BA:  BRA    33CE
33BC:  BTFSC  x5F.7
33BE:  BRA    33CA
33C0:  MOVF   x5F,F
33C2:  BNZ   33CE
33C4:  MOVF   x5E,W
33C6:  SUBLW  3F
33C8:  BNC   33CE
33CA:  BTFSS  x5F.7
33CC:  BRA    33EC
....................                   bullet = 0;
33CE:  BCF    x57.0
....................                   glcd_line(last_bullet_x_pos,last_bullet_y_pos,bullet_x_pos,bullet_y_pos,0);
33D0:  MOVFF  15A,283
33D4:  MOVFF  15B,284
33D8:  MOVFF  15C,285
33DC:  MOVFF  15E,286
33E0:  MOVLB  2
33E2:  CLRF   x87
33E4:  MOVLB  0
33E6:  CALL   0A70
33EA:  MOVLB  1
....................                }
....................             }
33EC:  BRA    3412
33EE:  MOVLB  2
....................             else{
....................                bullet_collision = 0;
33F0:  BCF    x1C.2
....................                bullet = 0;
33F2:  MOVLB  1
33F4:  BCF    x57.0
....................                glcd_line(last_bullet_x_pos,last_bullet_y_pos,bullet_x_pos,bullet_y_pos,0);
33F6:  MOVFF  15A,283
33FA:  MOVFF  15B,284
33FE:  MOVFF  15C,285
3402:  MOVFF  15E,286
3406:  MOVLB  2
3408:  CLRF   x87
340A:  MOVLB  0
340C:  CALL   0A70
3410:  MOVLB  1
....................             }
....................          }
3412:  BRA    34E6
....................          else{
....................             if(p1_R){ // disparar si no hay una bala actualmente
3414:  MOVLB  2
3416:  BTFSS  x11.1
3418:  BRA    34E4
....................                bullet = 1;
341A:  MOVLB  1
341C:  BSF    x57.0
....................                bullet_dx = cos(ship_angle)*(float)bullet_speed;// dispararla segun el angulo q se mira
341E:  MOVFF  14A,268
3422:  MOVFF  149,267
3426:  MOVFF  148,266
342A:  MOVFF  147,265
342E:  MOVLB  0
3430:  CALL   197E
3434:  MOVFF  03,260
3438:  MOVFF  02,25F
343C:  MOVFF  01,25E
3440:  MOVFF  00,25D
3444:  MOVFF  03,296
3448:  MOVFF  02,295
344C:  MOVFF  01,294
3450:  MOVFF  00,293
3454:  MOVLB  2
3456:  CLRF   x9A
3458:  CLRF   x99
345A:  MOVLW  40
345C:  MOVWF  x98
345E:  MOVLW  81
3460:  MOVWF  x97
3462:  MOVLB  0
3464:  CALL   16E0
3468:  MOVFF  03,163
346C:  MOVFF  02,162
3470:  MOVFF  01,161
3474:  MOVFF  00,160
....................                bullet_dy = sin(ship_angle)*(float)bullet_speed;
3478:  MOVFF  14A,260
347C:  MOVFF  149,25F
3480:  MOVFF  148,25E
3484:  MOVFF  147,25D
3488:  GOTO   1CF4
348C:  MOVFF  03,260
3490:  MOVFF  02,25F
3494:  MOVFF  01,25E
3498:  MOVFF  00,25D
349C:  MOVFF  03,296
34A0:  MOVFF  02,295
34A4:  MOVFF  01,294
34A8:  MOVFF  00,293
34AC:  MOVLB  2
34AE:  CLRF   x9A
34B0:  CLRF   x99
34B2:  MOVLW  40
34B4:  MOVWF  x98
34B6:  MOVLW  81
34B8:  MOVWF  x97
34BA:  MOVLB  0
34BC:  CALL   16E0
34C0:  MOVFF  03,167
34C4:  MOVFF  02,166
34C8:  MOVFF  01,165
34CC:  MOVFF  00,164
....................                bullet_x_pos = x_pos;
34D0:  MOVLB  1
34D2:  MOVFF  14D,15C
34D6:  CLRF   x5D
....................                bullet_y_pos = y_pos;
34D8:  MOVFF  14E,15E
34DC:  CLRF   x5F
....................                sfx_time = 2;
34DE:  MOVLW  02
34E0:  MOVLB  2
34E2:  MOVWF  x1D
34E4:  MOVLB  1
....................             }
....................          }
....................       
....................          for(unsigned int i = 0; i < 20; i++){ // dibuar asteroides actuales
34E6:  MOVLB  2
34E8:  CLRF   x3B
34EA:  MOVF   x3B,W
34EC:  SUBLW  13
34EE:  BTFSS  FD8.0
34F0:  BRA    36D0
....................             if(asteroids_lifes[i]){
34F2:  CLRF   03
34F4:  MOVF   x3B,W
34F6:  ADDLW  1E
34F8:  MOVWF  FE9
34FA:  MOVLW  02
34FC:  ADDWFC 03,W
34FE:  MOVWF  FEA
3500:  MOVF   FEF,F
3502:  BTFSC  FD8.2
3504:  BRA    35FE
....................                if(asteroid_lost_a_life[i]){
3506:  MOVFF  23B,25D
350A:  MOVLW  02
350C:  MOVWF  x5F
350E:  MOVLW  32
3510:  MOVWF  x5E
3512:  MOVLB  0
3514:  CALL   1D44
3518:  BTFSS  01.0
351A:  BRA    3578
....................                   draw_asteroid(last_asteroids_x_pos[i],last_asteroids_y_pos[i],asteroids_lifes[i]+1,0);
351C:  CLRF   03
351E:  MOVLB  2
3520:  MOVF   x3B,W
3522:  ADDLW  88
3524:  MOVWF  FE9
3526:  MOVLW  01
3528:  ADDWFC 03,W
352A:  MOVWF  FEA
352C:  MOVFF  FEF,260
3530:  CLRF   03
3532:  MOVF   x3B,W
3534:  ADDLW  9C
3536:  MOVWF  FE9
3538:  MOVLW  01
353A:  ADDWFC 03,W
353C:  MOVWF  FEA
353E:  MOVFF  FEF,261
3542:  CLRF   03
3544:  MOVF   x3B,W
3546:  ADDLW  1E
3548:  MOVWF  FE9
354A:  MOVLW  02
354C:  ADDWFC 03,W
354E:  MOVWF  FEA
3550:  MOVLW  01
3552:  ADDWF  FEF,W
3554:  MOVWF  x5F
3556:  MOVWF  x62
3558:  CLRF   x63
355A:  MOVLB  0
355C:  CALL   1D7A
....................                   asteroid_lost_a_life[i] = 0;
3560:  MOVFF  23B,25D
3564:  MOVLB  2
3566:  CLRF   x5E
3568:  MOVLW  02
356A:  MOVWF  x60
356C:  MOVLW  32
356E:  MOVWF  x5F
3570:  MOVLB  0
3572:  CALL   193C
....................                }
3576:  BRA    35B8
....................                else{
....................                   draw_asteroid(last_asteroids_x_pos[i],last_asteroids_y_pos[i],asteroids_lifes[i],0);
3578:  CLRF   03
357A:  MOVLB  2
357C:  MOVF   x3B,W
357E:  ADDLW  88
3580:  MOVWF  FE9
3582:  MOVLW  01
3584:  ADDWFC 03,W
3586:  MOVWF  FEA
3588:  MOVFF  FEF,260
358C:  CLRF   03
358E:  MOVF   x3B,W
3590:  ADDLW  9C
3592:  MOVWF  FE9
3594:  MOVLW  01
3596:  ADDWFC 03,W
3598:  MOVWF  FEA
359A:  MOVFF  FEF,261
359E:  CLRF   03
35A0:  MOVF   x3B,W
35A2:  ADDLW  1E
35A4:  MOVWF  FE9
35A6:  MOVLW  02
35A8:  ADDWFC 03,W
35AA:  MOVWF  FEA
35AC:  MOVFF  FEF,262
35B0:  CLRF   x63
35B2:  MOVLB  0
35B4:  CALL   1D7A
....................                }
....................                draw_asteroid(asteroids_x_pos[i],asteroids_y_pos[i],asteroids_lifes[i],1);
35B8:  CLRF   03
35BA:  MOVLB  2
35BC:  MOVF   x3B,W
35BE:  ADDLW  B0
35C0:  MOVWF  FE9
35C2:  MOVLW  01
35C4:  ADDWFC 03,W
35C6:  MOVWF  FEA
35C8:  MOVFF  FEF,260
35CC:  CLRF   03
35CE:  MOVF   x3B,W
35D0:  ADDLW  C4
35D2:  MOVWF  FE9
35D4:  MOVLW  01
35D6:  ADDWFC 03,W
35D8:  MOVWF  FEA
35DA:  MOVFF  FEF,261
35DE:  CLRF   03
35E0:  MOVF   x3B,W
35E2:  ADDLW  1E
35E4:  MOVWF  FE9
35E6:  MOVLW  02
35E8:  ADDWFC 03,W
35EA:  MOVWF  FEA
35EC:  MOVFF  FEF,262
35F0:  MOVLW  01
35F2:  MOVWF  x63
35F4:  MOVLB  0
35F6:  CALL   1D7A
....................             }
35FA:  BRA    366E
35FC:  MOVLB  2
....................             else{
....................                if(asteroid_lost_a_life[i]){
35FE:  MOVFF  23B,25D
3602:  MOVLW  02
3604:  MOVWF  x5F
3606:  MOVLW  32
3608:  MOVWF  x5E
360A:  MOVLB  0
360C:  CALL   1D44
3610:  BTFSS  01.0
3612:  BRA    366E
....................                   draw_asteroid(last_asteroids_x_pos[i],last_asteroids_y_pos[i],asteroids_lifes[i]+1,0);
3614:  CLRF   03
3616:  MOVLB  2
3618:  MOVF   x3B,W
361A:  ADDLW  88
361C:  MOVWF  FE9
361E:  MOVLW  01
3620:  ADDWFC 03,W
3622:  MOVWF  FEA
3624:  MOVFF  FEF,260
3628:  CLRF   03
362A:  MOVF   x3B,W
362C:  ADDLW  9C
362E:  MOVWF  FE9
3630:  MOVLW  01
3632:  ADDWFC 03,W
3634:  MOVWF  FEA
3636:  MOVFF  FEF,261
363A:  CLRF   03
363C:  MOVF   x3B,W
363E:  ADDLW  1E
3640:  MOVWF  FE9
3642:  MOVLW  02
3644:  ADDWFC 03,W
3646:  MOVWF  FEA
3648:  MOVLW  01
364A:  ADDWF  FEF,W
364C:  MOVWF  x5F
364E:  MOVWF  x62
3650:  CLRF   x63
3652:  MOVLB  0
3654:  CALL   1D7A
....................                   asteroid_lost_a_life[i] = 0;
3658:  MOVFF  23B,25D
365C:  MOVLB  2
365E:  CLRF   x5E
3660:  MOVLW  02
3662:  MOVWF  x60
3664:  MOVLW  32
3666:  MOVWF  x5F
3668:  MOVLB  0
366A:  CALL   193C
....................                }
....................             }
....................             last_asteroids_x_pos[i] = asteroids_x_pos[i];
366E:  CLRF   03
3670:  MOVLB  2
3672:  MOVF   x3B,W
3674:  ADDLW  88
3676:  MOVWF  01
3678:  MOVLW  01
367A:  ADDWFC 03,F
367C:  MOVFF  03,25E
3680:  CLRF   03
3682:  MOVF   x3B,W
3684:  ADDLW  B0
3686:  MOVWF  FE9
3688:  MOVLW  01
368A:  ADDWFC 03,W
368C:  MOVWF  FEA
368E:  MOVFF  FEF,25F
3692:  MOVFF  25E,FEA
3696:  MOVFF  01,FE9
369A:  MOVFF  25F,FEF
....................             last_asteroids_y_pos[i] = asteroids_y_pos[i];
369E:  CLRF   03
36A0:  MOVF   x3B,W
36A2:  ADDLW  9C
36A4:  MOVWF  01
36A6:  MOVLW  01
36A8:  ADDWFC 03,F
36AA:  MOVFF  03,25E
36AE:  CLRF   03
36B0:  MOVF   x3B,W
36B2:  ADDLW  C4
36B4:  MOVWF  FE9
36B6:  MOVLW  01
36B8:  ADDWFC 03,W
36BA:  MOVWF  FEA
36BC:  MOVFF  FEF,25F
36C0:  MOVFF  25E,FEA
36C4:  MOVFF  01,FE9
36C8:  MOVFF  25F,FEF
36CC:  INCF   x3B,F
36CE:  BRA    34EA
....................          }
.................... 
....................          if(bullet){ // dibujar la nueva bala
36D0:  MOVLB  1
36D2:  BTFSS  x57.0
36D4:  BRA    36E8
....................             last_last_bullet_x_pos = last_bullet_x_pos;
36D6:  MOVFF  15A,158
....................             last_last_bullet_y_pos = last_bullet_y_pos;
36DA:  MOVFF  15B,159
....................             last_bullet_x_pos = bullet_x_pos;
36DE:  MOVFF  15C,15A
....................             last_bullet_y_pos = bullet_y_pos;
36E2:  MOVFF  15E,15B
....................          }
36E6:  BRA    36F8
....................          else{
....................             last_last_bullet_x_pos =  x_pos;
36E8:  MOVFF  14D,158
....................             last_last_bullet_y_pos = y_pos;
36EC:  MOVFF  14E,159
....................             last_bullet_x_pos =  x_pos;
36F0:  MOVFF  14D,15A
....................             last_bullet_y_pos = y_pos;
36F4:  MOVFF  14E,15B
....................          }
.................... 
....................          glcd_line(last_x_pos-1,last_y_pos+1,last_x_pos+1,last_y_pos+1,0);
36F8:  MOVLW  01
36FA:  SUBWF  x4B,W
36FC:  MOVLB  2
36FE:  MOVWF  x5D
3700:  MOVLW  01
3702:  MOVLB  1
3704:  ADDWF  x4C,W
3706:  MOVLB  2
3708:  MOVWF  x5E
370A:  MOVLW  01
370C:  MOVLB  1
370E:  ADDWF  x4B,W
3710:  MOVLB  2
3712:  MOVWF  x5F
3714:  MOVLW  01
3716:  MOVLB  1
3718:  ADDWF  x4C,W
371A:  MOVLB  2
371C:  MOVWF  x60
371E:  MOVFF  25D,283
3722:  MOVFF  25E,284
3726:  MOVFF  25F,285
372A:  MOVWF  x86
372C:  CLRF   x87
372E:  MOVLB  0
3730:  CALL   0A70
....................          glcd_line(last_x_pos-1,last_y_pos-1,last_x_pos+1,last_y_pos-1,0);
3734:  MOVLW  01
3736:  MOVLB  1
3738:  SUBWF  x4B,W
373A:  MOVLB  2
373C:  MOVWF  x5D
373E:  MOVLW  01
3740:  MOVLB  1
3742:  SUBWF  x4C,W
3744:  MOVLB  2
3746:  MOVWF  x5E
3748:  MOVLW  01
374A:  MOVLB  1
374C:  ADDWF  x4B,W
374E:  MOVLB  2
3750:  MOVWF  x5F
3752:  MOVLW  01
3754:  MOVLB  1
3756:  SUBWF  x4C,W
3758:  MOVLB  2
375A:  MOVWF  x60
375C:  MOVFF  25D,283
3760:  MOVFF  25E,284
3764:  MOVFF  25F,285
3768:  MOVWF  x86
376A:  CLRF   x87
376C:  MOVLB  0
376E:  CALL   0A70
....................          glcd_line(last_x_pos-1,last_y_pos+1,last_x_pos-1,last_y_pos-1,0);
3772:  MOVLW  01
3774:  MOVLB  1
3776:  SUBWF  x4B,W
3778:  MOVLB  2
377A:  MOVWF  x5D
377C:  MOVLW  01
377E:  MOVLB  1
3780:  ADDWF  x4C,W
3782:  MOVLB  2
3784:  MOVWF  x5E
3786:  MOVLW  01
3788:  MOVLB  1
378A:  SUBWF  x4B,W
378C:  MOVLB  2
378E:  MOVWF  x5F
3790:  MOVLW  01
3792:  MOVLB  1
3794:  SUBWF  x4C,W
3796:  MOVLB  2
3798:  MOVWF  x60
379A:  MOVFF  25D,283
379E:  MOVFF  25E,284
37A2:  MOVFF  25F,285
37A6:  MOVWF  x86
37A8:  CLRF   x87
37AA:  MOVLB  0
37AC:  CALL   0A70
....................          glcd_line(last_x_pos+1,last_y_pos+1,last_x_pos+1,last_y_pos-1,0);
37B0:  MOVLW  01
37B2:  MOVLB  1
37B4:  ADDWF  x4B,W
37B6:  MOVLB  2
37B8:  MOVWF  x5D
37BA:  MOVLW  01
37BC:  MOVLB  1
37BE:  ADDWF  x4C,W
37C0:  MOVLB  2
37C2:  MOVWF  x5E
37C4:  MOVLW  01
37C6:  MOVLB  1
37C8:  ADDWF  x4B,W
37CA:  MOVLB  2
37CC:  MOVWF  x5F
37CE:  MOVLW  01
37D0:  MOVLB  1
37D2:  SUBWF  x4C,W
37D4:  MOVLB  2
37D6:  MOVWF  x60
37D8:  MOVFF  25D,283
37DC:  MOVFF  25E,284
37E0:  MOVFF  25F,285
37E4:  MOVWF  x86
37E6:  CLRF   x87
37E8:  MOVLB  0
37EA:  CALL   0A70
....................          
....................          glcd_line(x_pos-1,y_pos+1,x_pos+1,y_pos+1,1);
37EE:  MOVLW  01
37F0:  MOVLB  1
37F2:  SUBWF  x4D,W
37F4:  MOVLB  2
37F6:  MOVWF  x5D
37F8:  MOVLW  01
37FA:  MOVLB  1
37FC:  ADDWF  x4E,W
37FE:  MOVLB  2
3800:  MOVWF  x5E
3802:  MOVLW  01
3804:  MOVLB  1
3806:  ADDWF  x4D,W
3808:  MOVLB  2
380A:  MOVWF  x5F
380C:  MOVLW  01
380E:  MOVLB  1
3810:  ADDWF  x4E,W
3812:  MOVLB  2
3814:  MOVWF  x60
3816:  MOVFF  25D,283
381A:  MOVFF  25E,284
381E:  MOVFF  25F,285
3822:  MOVWF  x86
3824:  MOVLW  01
3826:  MOVWF  x87
3828:  MOVLB  0
382A:  CALL   0A70
....................          glcd_line(x_pos-1,y_pos-1,x_pos+1,y_pos-1,1);
382E:  MOVLW  01
3830:  MOVLB  1
3832:  SUBWF  x4D,W
3834:  MOVLB  2
3836:  MOVWF  x5D
3838:  MOVLW  01
383A:  MOVLB  1
383C:  SUBWF  x4E,W
383E:  MOVLB  2
3840:  MOVWF  x5E
3842:  MOVLW  01
3844:  MOVLB  1
3846:  ADDWF  x4D,W
3848:  MOVLB  2
384A:  MOVWF  x5F
384C:  MOVLW  01
384E:  MOVLB  1
3850:  SUBWF  x4E,W
3852:  MOVLB  2
3854:  MOVWF  x60
3856:  MOVFF  25D,283
385A:  MOVFF  25E,284
385E:  MOVFF  25F,285
3862:  MOVWF  x86
3864:  MOVLW  01
3866:  MOVWF  x87
3868:  MOVLB  0
386A:  CALL   0A70
....................          glcd_line(x_pos-1,y_pos+1,x_pos-1,y_pos-1,1);
386E:  MOVLW  01
3870:  MOVLB  1
3872:  SUBWF  x4D,W
3874:  MOVLB  2
3876:  MOVWF  x5D
3878:  MOVLW  01
387A:  MOVLB  1
387C:  ADDWF  x4E,W
387E:  MOVLB  2
3880:  MOVWF  x5E
3882:  MOVLW  01
3884:  MOVLB  1
3886:  SUBWF  x4D,W
3888:  MOVLB  2
388A:  MOVWF  x5F
388C:  MOVLW  01
388E:  MOVLB  1
3890:  SUBWF  x4E,W
3892:  MOVLB  2
3894:  MOVWF  x60
3896:  MOVFF  25D,283
389A:  MOVFF  25E,284
389E:  MOVFF  25F,285
38A2:  MOVWF  x86
38A4:  MOVLW  01
38A6:  MOVWF  x87
38A8:  MOVLB  0
38AA:  CALL   0A70
....................          glcd_line(x_pos+1,y_pos+1,x_pos+1,y_pos-1,1);
38AE:  MOVLW  01
38B0:  MOVLB  1
38B2:  ADDWF  x4D,W
38B4:  MOVLB  2
38B6:  MOVWF  x5D
38B8:  MOVLW  01
38BA:  MOVLB  1
38BC:  ADDWF  x4E,W
38BE:  MOVLB  2
38C0:  MOVWF  x5E
38C2:  MOVLW  01
38C4:  MOVLB  1
38C6:  ADDWF  x4D,W
38C8:  MOVLB  2
38CA:  MOVWF  x5F
38CC:  MOVLW  01
38CE:  MOVLB  1
38D0:  SUBWF  x4E,W
38D2:  MOVLB  2
38D4:  MOVWF  x60
38D6:  MOVFF  25D,283
38DA:  MOVFF  25E,284
38DE:  MOVFF  25F,285
38E2:  MOVWF  x86
38E4:  MOVLW  01
38E6:  MOVWF  x87
38E8:  MOVLB  0
38EA:  CALL   0A70
....................          
....................          
.................... 
....................          last_ship_angle = ship_angle; // guardar la posicion anterior
38EE:  MOVFF  14A,146
38F2:  MOVFF  149,145
38F6:  MOVFF  148,144
38FA:  MOVFF  147,143
....................          last_x_pos = x_pos;
38FE:  MOVFF  14D,14B
....................          last_y_pos = y_pos;
3902:  MOVFF  14E,14C
.................... 
....................          
.................... 
.................... 
....................       
....................          for(int i = 0; i < 20; i++){ // checa si ya mataste todos los asteroides
3906:  MOVLB  2
3908:  CLRF   x3C
390A:  MOVF   x3C,W
390C:  SUBLW  13
390E:  BNC   3926
....................             temp += asteroids_lifes[i];
3910:  CLRF   03
3912:  MOVF   x3C,W
3914:  ADDLW  1E
3916:  MOVWF  FE9
3918:  MOVLW  02
391A:  ADDWFC 03,W
391C:  MOVWF  FEA
391E:  MOVF   FEF,W
3920:  ADDWF  x35,F
3922:  INCF   x3C,F
3924:  BRA    390A
....................          }
....................          if(!temp || new_level){
3926:  MOVF   x35,F
3928:  BZ    3932
392A:  MOVLB  1
392C:  BTFSS  x57.5
392E:  BRA    3936
3930:  MOVLB  2
....................             new_level = 1;
3932:  MOVLB  1
3934:  BSF    x57.5
....................             //glcd_fillScreen(1);
....................          }
....................          scores(last_score,last_level,0);
3936:  MOVFF  207,25E
393A:  MOVFF  206,25D
393E:  MOVFF  208,25F
3942:  MOVLB  2
3944:  CLRF   x60
3946:  MOVLB  0
3948:  CALL   21A2
....................          scores(score,level,1);
394C:  MOVFF  203,25E
3950:  MOVFF  202,25D
3954:  MOVFF  200,25F
3958:  MOVLW  01
395A:  MOVLB  2
395C:  MOVWF  x60
395E:  MOVLB  0
3960:  CALL   21A2
....................          last_score = score;
3964:  MOVFF  203,207
3968:  MOVFF  202,206
....................          last_level = level;
396C:  MOVFF  200,208
.................... 
....................          delay_ms((int16)( 22.0f - ( (float)temp*0.2f ))); // manten los frames constantes segun cuantas cosas hayas dibujado
3970:  MOVLB  2
3972:  CLRF   x94
3974:  MOVFF  235,293
3978:  MOVLB  0
397A:  CALL   11AE
397E:  MOVFF  03,260
3982:  MOVFF  02,25F
3986:  MOVFF  01,25E
398A:  MOVFF  00,25D
398E:  MOVFF  03,296
3992:  MOVFF  02,295
3996:  MOVFF  01,294
399A:  MOVFF  00,293
399E:  MOVLW  CD
39A0:  MOVLB  2
39A2:  MOVWF  x9A
39A4:  MOVLW  CC
39A6:  MOVWF  x99
39A8:  MOVLW  4C
39AA:  MOVWF  x98
39AC:  MOVLW  7C
39AE:  MOVWF  x97
39B0:  MOVLB  0
39B2:  CALL   16E0
39B6:  BSF    FD8.1
39B8:  MOVLB  2
39BA:  CLRF   x96
39BC:  CLRF   x95
39BE:  MOVLW  30
39C0:  MOVWF  x94
39C2:  MOVLW  83
39C4:  MOVWF  x93
39C6:  MOVFF  03,29A
39CA:  MOVFF  02,299
39CE:  MOVFF  01,298
39D2:  MOVFF  00,297
39D6:  MOVLB  0
39D8:  CALL   13AA
39DC:  MOVFF  03,292
39E0:  MOVFF  02,291
39E4:  MOVFF  01,290
39E8:  MOVFF  00,28F
39EC:  CALL   1342
39F0:  MOVFF  02,25E
39F4:  MOVFF  01,25D
39F8:  MOVFF  02,25F
39FC:  MOVLB  2
39FE:  INCF   x5F,F
3A00:  DECF   x5F,F
3A02:  BTFSC  FD8.2
3A04:  BRA    3A12
3A06:  SETF   x60
3A08:  MOVLB  0
3A0A:  CALL   05EC
3A0E:  MOVLB  2
3A10:  BRA    3A00
3A12:  MOVFF  25D,260
3A16:  MOVLB  0
3A18:  CALL   05EC
.................... 
....................          temp = 0;
3A1C:  MOVLB  2
3A1E:  CLRF   x35
3A20:  MOVLB  0
....................             
....................             }
....................             break;
3A22:  MOVLB  2
3A24:  GOTO   444E
3A28:  MOVLB  0
....................          }
....................          case 'J':{ // jugando multiplayer
....................             if(new_game){
3A2A:  MOVLB  2
3A2C:  BTFSS  x1C.3
3A2E:  BRA    3A4A
....................                x_pos_1 = 10;
3A30:  MOVLW  0A
3A32:  MOVLB  1
3A34:  MOVWF  x25
....................                y_pos_1 = 20;
3A36:  MOVLW  14
3A38:  MOVWF  x26
....................                x_pos_2 = 120;
3A3A:  MOVLW  78
3A3C:  MOVWF  x39
....................                y_pos_2 = 40;
3A3E:  MOVLW  28
3A40:  MOVWF  x3A
....................                bullet_1 = 0;
3A42:  BCF    x57.1
....................                bullet_2 = 0;
3A44:  BCF    x57.3
....................                new_game = 0;
3A46:  MOVLB  2
3A48:  BCF    x1C.3
....................             }
....................             
....................             
....................             
....................             dx_1 = get_d(p1_pot_x); // potenciometro movimiento
3A4A:  MOVFF  20D,25D
3A4E:  MOVLB  0
3A50:  CALL   2232
3A54:  MOVFF  03,12A
3A58:  MOVFF  02,129
3A5C:  MOVFF  01,128
3A60:  MOVFF  00,127
....................             dy_1 = get_d(p1_pot_y); // potenciometro movimiento
3A64:  MOVFF  20E,25D
3A68:  CALL   2232
3A6C:  MOVFF  03,12E
3A70:  MOVFF  02,12D
3A74:  MOVFF  01,12C
3A78:  MOVFF  00,12B
....................             if((float)x_pos_1 + dx_1 < 0) // mover jugador
3A7C:  MOVLB  2
3A7E:  CLRF   x94
3A80:  MOVFF  125,293
3A84:  MOVLB  0
3A86:  CALL   11AE
3A8A:  MOVFF  03,260
3A8E:  MOVFF  02,25F
3A92:  MOVFF  01,25E
3A96:  MOVFF  00,25D
3A9A:  BCF    FD8.1
3A9C:  MOVFF  03,296
3AA0:  MOVFF  02,295
3AA4:  MOVFF  01,294
3AA8:  MOVFF  00,293
3AAC:  MOVFF  12A,29A
3AB0:  MOVFF  129,299
3AB4:  MOVFF  128,298
3AB8:  MOVFF  127,297
3ABC:  CALL   13AA
3AC0:  MOVFF  03,260
3AC4:  MOVFF  02,25F
3AC8:  MOVFF  01,25E
3ACC:  MOVFF  00,25D
3AD0:  MOVFF  03,292
3AD4:  MOVFF  02,291
3AD8:  MOVFF  01,290
3ADC:  MOVFF  00,28F
3AE0:  MOVLB  2
3AE2:  CLRF   x96
3AE4:  CLRF   x95
3AE6:  CLRF   x94
3AE8:  CLRF   x93
3AEA:  MOVLB  0
3AEC:  CALL   18C2
3AF0:  BNC   3B56
....................                x_pos_1 = 127 + (int)((float)x_pos_1 + dx_1);
3AF2:  MOVLB  2
3AF4:  CLRF   x94
3AF6:  MOVFF  125,293
3AFA:  MOVLB  0
3AFC:  CALL   11AE
3B00:  MOVFF  03,260
3B04:  MOVFF  02,25F
3B08:  MOVFF  01,25E
3B0C:  MOVFF  00,25D
3B10:  BCF    FD8.1
3B12:  MOVFF  03,296
3B16:  MOVFF  02,295
3B1A:  MOVFF  01,294
3B1E:  MOVFF  00,293
3B22:  MOVFF  12A,29A
3B26:  MOVFF  129,299
3B2A:  MOVFF  128,298
3B2E:  MOVFF  127,297
3B32:  CALL   13AA
3B36:  MOVFF  03,292
3B3A:  MOVFF  02,291
3B3E:  MOVFF  01,290
3B42:  MOVFF  00,28F
3B46:  CALL   1342
3B4A:  MOVLW  7F
3B4C:  ADDWF  01,W
3B4E:  MOVLB  1
3B50:  MOVWF  x25
3B52:  BRA    3B86
3B54:  MOVLB  0
....................             else
....................                x_pos_1 = (x_pos_1 + (int)dx_1) % 127;
3B56:  MOVFF  12A,292
3B5A:  MOVFF  129,291
3B5E:  MOVFF  128,290
3B62:  MOVFF  127,28F
3B66:  CALL   1342
3B6A:  MOVF   01,W
3B6C:  MOVLB  1
3B6E:  ADDWF  x25,W
3B70:  MOVLB  2
3B72:  MOVWF  x5E
3B74:  MOVWF  x6D
3B76:  MOVLW  7F
3B78:  MOVWF  x6E
3B7A:  MOVLB  0
3B7C:  CALL   137E
3B80:  MOVFF  00,125
3B84:  MOVLB  1
.................... 
....................             if((float)y_pos_1 - dy_1 < 0) // mover jugador
3B86:  MOVLB  2
3B88:  CLRF   x94
3B8A:  MOVFF  126,293
3B8E:  MOVLB  0
3B90:  CALL   11AE
3B94:  MOVFF  03,260
3B98:  MOVFF  02,25F
3B9C:  MOVFF  01,25E
3BA0:  MOVFF  00,25D
3BA4:  BSF    FD8.1
3BA6:  MOVFF  03,296
3BAA:  MOVFF  02,295
3BAE:  MOVFF  01,294
3BB2:  MOVFF  00,293
3BB6:  MOVFF  12E,29A
3BBA:  MOVFF  12D,299
3BBE:  MOVFF  12C,298
3BC2:  MOVFF  12B,297
3BC6:  CALL   13AA
3BCA:  MOVFF  03,260
3BCE:  MOVFF  02,25F
3BD2:  MOVFF  01,25E
3BD6:  MOVFF  00,25D
3BDA:  MOVFF  03,292
3BDE:  MOVFF  02,291
3BE2:  MOVFF  01,290
3BE6:  MOVFF  00,28F
3BEA:  MOVLB  2
3BEC:  CLRF   x96
3BEE:  CLRF   x95
3BF0:  CLRF   x94
3BF2:  CLRF   x93
3BF4:  MOVLB  0
3BF6:  CALL   18C2
3BFA:  BNC   3C60
....................                y_pos_1 = 63 + (int)((float)y_pos_1 - dy_1);
3BFC:  MOVLB  2
3BFE:  CLRF   x94
3C00:  MOVFF  126,293
3C04:  MOVLB  0
3C06:  CALL   11AE
3C0A:  MOVFF  03,260
3C0E:  MOVFF  02,25F
3C12:  MOVFF  01,25E
3C16:  MOVFF  00,25D
3C1A:  BSF    FD8.1
3C1C:  MOVFF  03,296
3C20:  MOVFF  02,295
3C24:  MOVFF  01,294
3C28:  MOVFF  00,293
3C2C:  MOVFF  12E,29A
3C30:  MOVFF  12D,299
3C34:  MOVFF  12C,298
3C38:  MOVFF  12B,297
3C3C:  CALL   13AA
3C40:  MOVFF  03,292
3C44:  MOVFF  02,291
3C48:  MOVFF  01,290
3C4C:  MOVFF  00,28F
3C50:  CALL   1342
3C54:  MOVLW  3F
3C56:  ADDWF  01,W
3C58:  MOVLB  1
3C5A:  MOVWF  x26
3C5C:  BRA    3C90
3C5E:  MOVLB  0
....................             else
....................                y_pos_1 = (y_pos_1 - (int)dy_1) % 63;
3C60:  MOVFF  12E,292
3C64:  MOVFF  12D,291
3C68:  MOVFF  12C,290
3C6C:  MOVFF  12B,28F
3C70:  CALL   1342
3C74:  MOVF   01,W
3C76:  MOVLB  1
3C78:  SUBWF  x26,W
3C7A:  MOVLB  2
3C7C:  MOVWF  x5E
3C7E:  MOVWF  x6D
3C80:  MOVLW  3F
3C82:  MOVWF  x6E
3C84:  MOVLB  0
3C86:  CALL   137E
3C8A:  MOVFF  00,126
3C8E:  MOVLB  1
....................                
....................             dx_2 = get_d(p2_pot_x); // potenciometro movimiento
3C90:  MOVFF  212,25D
3C94:  MOVLB  0
3C96:  CALL   2232
3C9A:  MOVFF  03,13E
3C9E:  MOVFF  02,13D
3CA2:  MOVFF  01,13C
3CA6:  MOVFF  00,13B
....................             dy_2 = get_d(p2_pot_y); // potenciometro movimiento
3CAA:  MOVFF  213,25D
3CAE:  CALL   2232
3CB2:  MOVFF  03,142
3CB6:  MOVFF  02,141
3CBA:  MOVFF  01,140
3CBE:  MOVFF  00,13F
....................             if((float)x_pos_2 + dx_2 < 0) // mover jugador
3CC2:  MOVLB  2
3CC4:  CLRF   x94
3CC6:  MOVFF  139,293
3CCA:  MOVLB  0
3CCC:  CALL   11AE
3CD0:  MOVFF  03,260
3CD4:  MOVFF  02,25F
3CD8:  MOVFF  01,25E
3CDC:  MOVFF  00,25D
3CE0:  BCF    FD8.1
3CE2:  MOVFF  03,296
3CE6:  MOVFF  02,295
3CEA:  MOVFF  01,294
3CEE:  MOVFF  00,293
3CF2:  MOVFF  13E,29A
3CF6:  MOVFF  13D,299
3CFA:  MOVFF  13C,298
3CFE:  MOVFF  13B,297
3D02:  CALL   13AA
3D06:  MOVFF  03,260
3D0A:  MOVFF  02,25F
3D0E:  MOVFF  01,25E
3D12:  MOVFF  00,25D
3D16:  MOVFF  03,292
3D1A:  MOVFF  02,291
3D1E:  MOVFF  01,290
3D22:  MOVFF  00,28F
3D26:  MOVLB  2
3D28:  CLRF   x96
3D2A:  CLRF   x95
3D2C:  CLRF   x94
3D2E:  CLRF   x93
3D30:  MOVLB  0
3D32:  CALL   18C2
3D36:  BNC   3D9C
....................                x_pos_2 = 127 + (int)((float)x_pos_2 + dx_2);
3D38:  MOVLB  2
3D3A:  CLRF   x94
3D3C:  MOVFF  139,293
3D40:  MOVLB  0
3D42:  CALL   11AE
3D46:  MOVFF  03,260
3D4A:  MOVFF  02,25F
3D4E:  MOVFF  01,25E
3D52:  MOVFF  00,25D
3D56:  BCF    FD8.1
3D58:  MOVFF  03,296
3D5C:  MOVFF  02,295
3D60:  MOVFF  01,294
3D64:  MOVFF  00,293
3D68:  MOVFF  13E,29A
3D6C:  MOVFF  13D,299
3D70:  MOVFF  13C,298
3D74:  MOVFF  13B,297
3D78:  CALL   13AA
3D7C:  MOVFF  03,292
3D80:  MOVFF  02,291
3D84:  MOVFF  01,290
3D88:  MOVFF  00,28F
3D8C:  CALL   1342
3D90:  MOVLW  7F
3D92:  ADDWF  01,W
3D94:  MOVLB  1
3D96:  MOVWF  x39
3D98:  BRA    3DCC
3D9A:  MOVLB  0
....................             else
....................                x_pos_2 = (x_pos_2 + (int)dx_2) % 127;
3D9C:  MOVFF  13E,292
3DA0:  MOVFF  13D,291
3DA4:  MOVFF  13C,290
3DA8:  MOVFF  13B,28F
3DAC:  CALL   1342
3DB0:  MOVF   01,W
3DB2:  MOVLB  1
3DB4:  ADDWF  x39,W
3DB6:  MOVLB  2
3DB8:  MOVWF  x5E
3DBA:  MOVWF  x6D
3DBC:  MOVLW  7F
3DBE:  MOVWF  x6E
3DC0:  MOVLB  0
3DC2:  CALL   137E
3DC6:  MOVFF  00,139
3DCA:  MOVLB  1
.................... 
....................             if((float)y_pos_2 - dy_2 < 0) // mover jugador
3DCC:  MOVLB  2
3DCE:  CLRF   x94
3DD0:  MOVFF  13A,293
3DD4:  MOVLB  0
3DD6:  CALL   11AE
3DDA:  MOVFF  03,260
3DDE:  MOVFF  02,25F
3DE2:  MOVFF  01,25E
3DE6:  MOVFF  00,25D
3DEA:  BSF    FD8.1
3DEC:  MOVFF  03,296
3DF0:  MOVFF  02,295
3DF4:  MOVFF  01,294
3DF8:  MOVFF  00,293
3DFC:  MOVFF  142,29A
3E00:  MOVFF  141,299
3E04:  MOVFF  140,298
3E08:  MOVFF  13F,297
3E0C:  CALL   13AA
3E10:  MOVFF  03,260
3E14:  MOVFF  02,25F
3E18:  MOVFF  01,25E
3E1C:  MOVFF  00,25D
3E20:  MOVFF  03,292
3E24:  MOVFF  02,291
3E28:  MOVFF  01,290
3E2C:  MOVFF  00,28F
3E30:  MOVLB  2
3E32:  CLRF   x96
3E34:  CLRF   x95
3E36:  CLRF   x94
3E38:  CLRF   x93
3E3A:  MOVLB  0
3E3C:  CALL   18C2
3E40:  BNC   3EA6
....................                y_pos_2 = 63 + (int)((float)y_pos_2 - dy_2);
3E42:  MOVLB  2
3E44:  CLRF   x94
3E46:  MOVFF  13A,293
3E4A:  MOVLB  0
3E4C:  CALL   11AE
3E50:  MOVFF  03,260
3E54:  MOVFF  02,25F
3E58:  MOVFF  01,25E
3E5C:  MOVFF  00,25D
3E60:  BSF    FD8.1
3E62:  MOVFF  03,296
3E66:  MOVFF  02,295
3E6A:  MOVFF  01,294
3E6E:  MOVFF  00,293
3E72:  MOVFF  142,29A
3E76:  MOVFF  141,299
3E7A:  MOVFF  140,298
3E7E:  MOVFF  13F,297
3E82:  CALL   13AA
3E86:  MOVFF  03,292
3E8A:  MOVFF  02,291
3E8E:  MOVFF  01,290
3E92:  MOVFF  00,28F
3E96:  CALL   1342
3E9A:  MOVLW  3F
3E9C:  ADDWF  01,W
3E9E:  MOVLB  1
3EA0:  MOVWF  x3A
3EA2:  BRA    3ED6
3EA4:  MOVLB  0
....................             else
....................                y_pos_2 = (y_pos_2 - (int)dy_2) % 63;
3EA6:  MOVFF  142,292
3EAA:  MOVFF  141,291
3EAE:  MOVFF  140,290
3EB2:  MOVFF  13F,28F
3EB6:  CALL   1342
3EBA:  MOVF   01,W
3EBC:  MOVLB  1
3EBE:  SUBWF  x3A,W
3EC0:  MOVLB  2
3EC2:  MOVWF  x5E
3EC4:  MOVWF  x6D
3EC6:  MOVLW  3F
3EC8:  MOVWF  x6E
3ECA:  MOVLB  0
3ECC:  CALL   137E
3ED0:  MOVFF  00,13A
3ED4:  MOVLB  1
....................                
....................             if(bullet_1){ // si hay una bala, calcular su posicion, y si hay impacto o se pierde la bala
3ED6:  BTFSS  x57.1
3ED8:  BRA    409E
....................             
....................             bullet_x_pos_1 += 0;
....................             bullet_y_pos_1 += 0;
....................             // checar collision con asteroides
....................             if( ( (  bullet_x_pos_1 < x_pos_2+4 ) && (bullet_x_pos_1 > x_pos_2-4 ) && ( bullet_y_pos_1 < y_pos_2 + 4 ) && (bullet_y_pos_1 > y_pos_2 - 4 ) ) || ( (  last_bullet_x_pos_1 < x_pos_2+4 ) && (last_bullet_x_pos_1 > x_pos_2-4 ) && ( last_bullet_y_pos_1 < y_pos_2 + 4 ) && (last_bullet_y_pos_1 > y_pos_2 - 4 ) )){
3EDA:  MOVLW  04
3EDC:  ADDWF  x39,W
3EDE:  BTFSC  x6D.7
3EE0:  BRA    3EEA
3EE2:  MOVF   x6D,F
3EE4:  BNZ   3F1E
3EE6:  SUBWF  x6C,W
3EE8:  BC    3F1E
3EEA:  MOVLW  04
3EEC:  SUBWF  x39,W
3EEE:  BTFSC  x6D.7
3EF0:  BRA    3F1E
3EF2:  MOVF   x6D,F
3EF4:  BNZ   3EFC
3EF6:  SUBWF  x6C,W
3EF8:  BZ    3F1E
3EFA:  BNC   3F1E
3EFC:  MOVLW  04
3EFE:  ADDWF  x3A,W
3F00:  BTFSC  x6F.7
3F02:  BRA    3F0C
3F04:  MOVF   x6F,F
3F06:  BNZ   3F1E
3F08:  SUBWF  x6E,W
3F0A:  BC    3F1E
3F0C:  MOVLW  04
3F0E:  SUBWF  x3A,W
3F10:  BTFSC  x6F.7
3F12:  BRA    3F1E
3F14:  MOVF   x6F,F
3F16:  BNZ   3F52
3F18:  SUBWF  x6E,W
3F1A:  BZ    3F1E
3F1C:  BC    3F52
3F1E:  MOVLW  04
3F20:  ADDWF  x39,W
3F22:  BTFSC  x6A.7
3F24:  BRA    3F2A
3F26:  SUBWF  x6A,W
3F28:  BC    3F66
3F2A:  MOVLW  04
3F2C:  SUBWF  x39,W
3F2E:  BTFSC  x6A.7
3F30:  BRA    3F66
3F32:  SUBWF  x6A,W
3F34:  BZ    3F66
3F36:  BNC   3F66
3F38:  MOVLW  04
3F3A:  ADDWF  x3A,W
3F3C:  BTFSC  x6B.7
3F3E:  BRA    3F44
3F40:  SUBWF  x6B,W
3F42:  BC    3F66
3F44:  MOVLW  04
3F46:  SUBWF  x3A,W
3F48:  BTFSC  x6B.7
3F4A:  BRA    3F66
3F4C:  SUBWF  x6B,W
3F4E:  BZ    3F66
3F50:  BNC   3F66
....................                   win = 1;
3F52:  MOVLB  2
3F54:  BSF    x1C.0
....................                   who = 0;
3F56:  BCF    x1C.1
....................                   mode = 'i';
3F58:  MOVLW  69
3F5A:  MOVWF  x0A
....................                   bullet_collision_1 = 1;
3F5C:  MOVLB  1
3F5E:  BSF    x57.2
....................                   new_game = 1;
3F60:  MOVLB  2
3F62:  BSF    x1C.3
3F64:  MOVLB  1
....................                }
....................                glcd_line(last_last_bullet_x_pos_1,last_last_bullet_y_pos_1,last_bullet_x_pos_1,last_bullet_y_pos_1,0);
3F66:  MOVFF  168,283
3F6A:  MOVFF  169,284
3F6E:  MOVFF  16A,285
3F72:  MOVFF  16B,286
3F76:  MOVLB  2
3F78:  CLRF   x87
3F7A:  MOVLB  0
3F7C:  CALL   0A70
....................                glcd_line(last_bullet_x_pos_1,last_bullet_y_pos_1,bullet_x_pos_1,bullet_y_pos_1,1);
3F80:  MOVFF  16A,283
3F84:  MOVFF  16B,284
3F88:  MOVFF  16C,285
3F8C:  MOVFF  16E,286
3F90:  MOVLW  01
3F92:  MOVLB  2
3F94:  MOVWF  x87
3F96:  MOVLB  0
3F98:  CALL   0A70
....................                
....................                char as[6];
....................                sprintf(as, "%u", (unsigned int)bullet_x_pos_1);
3F9C:  MOVLW  02
3F9E:  MOVLB  2
3FA0:  MOVWF  x17
3FA2:  MOVLW  3D
3FA4:  MOVWF  x16
3FA6:  MOVFF  16C,26B
3FAA:  MOVLW  1B
3FAC:  MOVWF  x6C
3FAE:  MOVLB  0
3FB0:  CALL   2122
....................                glcd_text57(0, 54, as, 1, 1);
3FB4:  MOVLB  2
3FB6:  CLRF   x83
3FB8:  MOVLW  36
3FBA:  MOVWF  x84
3FBC:  MOVLW  02
3FBE:  MOVWF  x86
3FC0:  MOVLW  3D
3FC2:  MOVWF  x85
3FC4:  MOVLW  01
3FC6:  MOVWF  x87
3FC8:  MOVWF  x88
3FCA:  MOVLB  0
3FCC:  CALL   08B4
....................                
....................                sprintf(as, "%u", (unsigned int)bullet_y_pos_1);
3FD0:  MOVLW  02
3FD2:  MOVLB  2
3FD4:  MOVWF  x17
3FD6:  MOVLW  3D
3FD8:  MOVWF  x16
3FDA:  MOVFF  16E,26B
3FDE:  MOVLW  1B
3FE0:  MOVWF  x6C
3FE2:  MOVLB  0
3FE4:  CALL   2122
....................                glcd_text57(20, 54, as, 1, 1);
3FE8:  MOVLW  14
3FEA:  MOVLB  2
3FEC:  MOVWF  x83
3FEE:  MOVLW  36
3FF0:  MOVWF  x84
3FF2:  MOVLW  02
3FF4:  MOVWF  x86
3FF6:  MOVLW  3D
3FF8:  MOVWF  x85
3FFA:  MOVLW  01
3FFC:  MOVWF  x87
3FFE:  MOVWF  x88
4000:  MOVLB  0
4002:  CALL   08B4
....................                
....................                sprintf(as, "%u", bullet_1);
4006:  MOVLW  00
4008:  MOVLB  1
400A:  BTFSC  x57.1
400C:  MOVLW  01
400E:  MOVLB  2
4010:  MOVWF  x5D
4012:  MOVLW  02
4014:  MOVWF  x17
4016:  MOVLW  3D
4018:  MOVWF  x16
401A:  MOVFF  25D,26B
401E:  MOVLW  1B
4020:  MOVWF  x6C
4022:  MOVLB  0
4024:  CALL   2122
....................                glcd_text57(0, 44, as, 1, 1);
4028:  MOVLB  2
402A:  CLRF   x83
402C:  MOVLW  2C
402E:  MOVWF  x84
4030:  MOVLW  02
4032:  MOVWF  x86
4034:  MOVLW  3D
4036:  MOVWF  x85
4038:  MOVLW  01
403A:  MOVWF  x87
403C:  MOVWF  x88
403E:  MOVLB  0
4040:  CALL   08B4
....................                
....................                
....................                if(!bullet_collision_1){ // si no hay colision, checar si se pierde la bala
4044:  MOVLB  1
4046:  BTFSC  x57.2
4048:  BRA    408C
....................                   if(bullet_x_pos_1 > 127 || bullet_x_pos_1 < 0 || bullet_y_pos_1 > 63 || bullet_y_pos_1 < 0){ // bala sali
404A:  BTFSC  x6D.7
404C:  BRA    4058
404E:  MOVF   x6D,F
4050:  BNZ   406E
4052:  MOVF   x6C,W
4054:  SUBLW  7F
4056:  BNC   406E
4058:  BTFSC  x6D.7
405A:  BRA    406E
405C:  BTFSC  x6F.7
405E:  BRA    406A
4060:  MOVF   x6F,F
4062:  BNZ   406E
4064:  MOVF   x6E,W
4066:  SUBLW  3F
4068:  BNC   406E
406A:  BTFSS  x6F.7
406C:  BRA    408C
....................                      bullet_1 = 0;
406E:  BCF    x57.1
....................                      glcd_line(last_bullet_x_pos_1,last_bullet_y_pos_1,bullet_x_pos_1,bullet_y_pos_1,0);
4070:  MOVFF  16A,283
4074:  MOVFF  16B,284
4078:  MOVFF  16C,285
407C:  MOVFF  16E,286
4080:  MOVLB  2
4082:  CLRF   x87
4084:  MOVLB  0
4086:  CALL   0A70
408A:  MOVLB  1
....................                   }
....................                }
....................                
....................                last_last_bullet_x_pos_1 = last_bullet_x_pos_1;
408C:  MOVFF  16A,168
....................                last_last_bullet_y_pos_1 = last_bullet_y_pos_1;
4090:  MOVFF  16B,169
....................                last_bullet_x_pos_1 = bullet_x_pos_1;
4094:  MOVFF  16C,16A
....................                last_bullet_y_pos_1 = bullet_y_pos_1;
4098:  MOVFF  16E,16B
....................              }
409C:  BRA    4144
....................              else{
....................                //if(p1_R){ // disparar si no hay una bala actualmente
....................                   bullet_1 = 1;
409E:  BSF    x57.1
....................                   bullet_dx_1 = 8;
40A0:  CLRF   x73
40A2:  CLRF   x72
40A4:  CLRF   x71
40A6:  MOVLW  82
40A8:  MOVWF  x70
....................                   bullet_dy_1 = 0;
40AA:  CLRF   x77
40AC:  CLRF   x76
40AE:  CLRF   x75
40B0:  CLRF   x74
....................                   bullet_x_pos_1 = 64;
40B2:  CLRF   x6D
40B4:  MOVLW  40
40B6:  MOVWF  x6C
....................                   bullet_y_pos_1 = 32;
40B8:  CLRF   x6F
40BA:  MOVLW  20
40BC:  MOVWF  x6E
....................                 char wazaazaz[] = "     ";  
40BE:  MOVLB  2
40C0:  MOVWF  x43
40C2:  MOVWF  x44
40C4:  MOVWF  x45
40C6:  MOVWF  x46
40C8:  MOVWF  x47
40CA:  CLRF   x48
....................                glcd_text57(0, 54, wazaazaz, 1, 1);
40CC:  CLRF   x83
40CE:  MOVLW  36
40D0:  MOVWF  x84
40D2:  MOVLW  02
40D4:  MOVWF  x86
40D6:  MOVLW  43
40D8:  MOVWF  x85
40DA:  MOVLW  01
40DC:  MOVWF  x87
40DE:  MOVWF  x88
40E0:  MOVLB  0
40E2:  CALL   08B4
....................                glcd_text57(20, 54, wazaazaz, 1, 1);
40E6:  MOVLW  14
40E8:  MOVLB  2
40EA:  MOVWF  x83
40EC:  MOVLW  36
40EE:  MOVWF  x84
40F0:  MOVLW  02
40F2:  MOVWF  x86
40F4:  MOVLW  43
40F6:  MOVWF  x85
40F8:  MOVLW  01
40FA:  MOVWF  x87
40FC:  MOVWF  x88
40FE:  MOVLB  0
4100:  CALL   08B4
....................                char as[6];
....................                sprintf(as, "%u", bullet_1);
4104:  MOVLW  00
4106:  MOVLB  1
4108:  BTFSC  x57.1
410A:  MOVLW  01
410C:  MOVLB  2
410E:  MOVWF  x5D
4110:  MOVLW  02
4112:  MOVWF  x17
4114:  MOVLW  49
4116:  MOVWF  x16
4118:  MOVFF  25D,26B
411C:  MOVLW  1B
411E:  MOVWF  x6C
4120:  MOVLB  0
4122:  CALL   2122
....................                glcd_text57(0, 44, as, 1, 1);
4126:  MOVLB  2
4128:  CLRF   x83
412A:  MOVLW  2C
412C:  MOVWF  x84
412E:  MOVLW  02
4130:  MOVWF  x86
4132:  MOVLW  49
4134:  MOVWF  x85
4136:  MOVLW  01
4138:  MOVWF  x87
413A:  MOVWF  x88
413C:  MOVLB  0
413E:  CALL   08B4
4142:  MOVLB  1
....................                //}
....................             }
....................              
....................             if(bullet_2){ // si hay una bala, calcular su posicion, y si hay impacto o se pierde la bala
4144:  BTFSS  x57.3
4146:  BRA    42A0
....................             bullet_x_pos_2 += (signed int)bullet_dx_2;
4148:  MOVFF  183,292
414C:  MOVFF  182,291
4150:  MOVFF  181,290
4154:  MOVFF  180,28F
4158:  MOVLB  0
415A:  CALL   1342
415E:  CLRF   03
4160:  MOVF   01,W
4162:  BTFSC  FE8.7
4164:  DECF   03,F
4166:  MOVLB  1
4168:  ADDWF  x7C,F
416A:  MOVF   03,W
416C:  ADDWFC x7D,F
....................             bullet_y_pos_2 += (signed int)bullet_dy_2;
416E:  MOVFF  187,292
4172:  MOVFF  186,291
4176:  MOVFF  185,290
417A:  MOVFF  184,28F
417E:  MOVLB  0
4180:  CALL   1342
4184:  CLRF   03
4186:  MOVF   01,W
4188:  BTFSC  FE8.7
418A:  DECF   03,F
418C:  MOVLB  1
418E:  ADDWF  x7E,F
4190:  MOVF   03,W
4192:  ADDWFC x7F,F
....................             // checar collision con asteroides
....................             if( ((  bullet_x_pos_2 < (x_pos_1+4) ) && (bullet_x_pos_2 > x_pos_1-4 ) && ( bullet_y_pos_2 < y_pos_1 + 4 ) && (bullet_y_pos_2 > y_pos_1 - 4 )) ||((  last_bullet_x_pos_2 < (x_pos_1+4) ) && (last_bullet_x_pos_2 > x_pos_1-4 ) && ( last_bullet_y_pos_2 < y_pos_1 + 4 ) && (last_bullet_y_pos_2 > y_pos_1 - 4 )) ){
4194:  MOVLW  04
4196:  ADDWF  x25,W
4198:  BTFSC  x7D.7
419A:  BRA    41A4
419C:  MOVF   x7D,F
419E:  BNZ   41D8
41A0:  SUBWF  x7C,W
41A2:  BC    41D8
41A4:  MOVLW  04
41A6:  SUBWF  x25,W
41A8:  BTFSC  x7D.7
41AA:  BRA    41D8
41AC:  MOVF   x7D,F
41AE:  BNZ   41B6
41B0:  SUBWF  x7C,W
41B2:  BZ    41D8
41B4:  BNC   41D8
41B6:  MOVLW  04
41B8:  ADDWF  x26,W
41BA:  BTFSC  x7F.7
41BC:  BRA    41C6
41BE:  MOVF   x7F,F
41C0:  BNZ   41D8
41C2:  SUBWF  x7E,W
41C4:  BC    41D8
41C6:  MOVLW  04
41C8:  SUBWF  x26,W
41CA:  BTFSC  x7F.7
41CC:  BRA    41D8
41CE:  MOVF   x7F,F
41D0:  BNZ   420C
41D2:  SUBWF  x7E,W
41D4:  BZ    41D8
41D6:  BC    420C
41D8:  MOVLW  04
41DA:  ADDWF  x25,W
41DC:  BTFSC  x7A.7
41DE:  BRA    41E4
41E0:  SUBWF  x7A,W
41E2:  BC    4220
41E4:  MOVLW  04
41E6:  SUBWF  x25,W
41E8:  BTFSC  x7A.7
41EA:  BRA    4220
41EC:  SUBWF  x7A,W
41EE:  BZ    4220
41F0:  BNC   4220
41F2:  MOVLW  04
41F4:  ADDWF  x26,W
41F6:  BTFSC  x7B.7
41F8:  BRA    41FE
41FA:  SUBWF  x7B,W
41FC:  BC    4220
41FE:  MOVLW  04
4200:  SUBWF  x26,W
4202:  BTFSC  x7B.7
4204:  BRA    4220
4206:  SUBWF  x7B,W
4208:  BZ    4220
420A:  BNC   4220
....................                   win = 1;
420C:  MOVLB  2
420E:  BSF    x1C.0
....................                   who = 1;
4210:  BSF    x1C.1
....................                   mode = 'i';
4212:  MOVLW  69
4214:  MOVWF  x0A
....................                   bullet_collision_2 = 1;
4216:  MOVLB  1
4218:  BSF    x57.4
....................                   new_game = 1;
421A:  MOVLB  2
421C:  BSF    x1C.3
421E:  MOVLB  1
....................                }
....................                glcd_line(last_last_bullet_x_pos_2,last_last_bullet_y_pos_2,last_bullet_x_pos_2,last_bullet_y_pos_2,0);
4220:  MOVFF  178,283
4224:  MOVFF  179,284
4228:  MOVFF  17A,285
422C:  MOVFF  17B,286
4230:  MOVLB  2
4232:  CLRF   x87
4234:  MOVLB  0
4236:  CALL   0A70
....................                glcd_line(last_bullet_x_pos_2,last_bullet_y_pos_2,bullet_x_pos_2,bullet_y_pos_2,1);
423A:  MOVFF  17A,283
423E:  MOVFF  17B,284
4242:  MOVFF  17C,285
4246:  MOVFF  17E,286
424A:  MOVLW  01
424C:  MOVLB  2
424E:  MOVWF  x87
4250:  MOVLB  0
4252:  CALL   0A70
....................               
....................                if(!bullet_collision_2){ // si no hay colision, checar si se pierde la bala
4256:  MOVLB  1
4258:  BTFSC  x57.4
425A:  BRA    429E
....................                   if(bullet_x_pos_2 > 127 || bullet_x_pos_2 < 0 || bullet_y_pos_2 > 63 || bullet_y_pos_2 < 0){ // bala sali
425C:  BTFSC  x7D.7
425E:  BRA    426A
4260:  MOVF   x7D,F
4262:  BNZ   4280
4264:  MOVF   x7C,W
4266:  SUBLW  7F
4268:  BNC   4280
426A:  BTFSC  x7D.7
426C:  BRA    4280
426E:  BTFSC  x7F.7
4270:  BRA    427C
4272:  MOVF   x7F,F
4274:  BNZ   4280
4276:  MOVF   x7E,W
4278:  SUBLW  3F
427A:  BNC   4280
427C:  BTFSS  x7F.7
427E:  BRA    429E
....................                      bullet_1 = 0;
4280:  BCF    x57.1
....................                      glcd_line(last_bullet_x_pos_2,last_bullet_y_pos_2,bullet_x_pos_2,bullet_y_pos_2,0);
4282:  MOVFF  17A,283
4286:  MOVFF  17B,284
428A:  MOVFF  17C,285
428E:  MOVFF  17E,286
4292:  MOVLB  2
4294:  CLRF   x87
4296:  MOVLB  0
4298:  CALL   0A70
429C:  MOVLB  1
....................                   }
....................                }
....................              }
429E:  BRA    42EA
....................              else{
....................                //if(p2_R){ // disparar si no hay una bala actualmente
....................                   bullet_2 = 1;
42A0:  BSF    x57.3
....................                   bullet_dx_2 = calc_ang_x(p2_pot_xx,p2_pot_yy);
42A2:  MOVFF  214,25D
42A6:  MOVFF  215,25E
42AA:  MOVLB  0
42AC:  GOTO   22AC
42B0:  MOVFF  03,183
42B4:  MOVFF  02,182
42B8:  MOVFF  01,181
42BC:  MOVFF  00,180
....................                   bullet_dy_2 = calc_ang_y(p2_pot_xx,p2_pot_yy);
42C0:  MOVFF  214,25D
42C4:  MOVFF  215,25E
42C8:  GOTO   2374
42CC:  MOVFF  03,187
42D0:  MOVFF  02,186
42D4:  MOVFF  01,185
42D8:  MOVFF  00,184
....................                   bullet_x_pos_2 = x_pos_2;
42DC:  MOVLB  1
42DE:  MOVFF  139,17C
42E2:  CLRF   x7D
....................                   bullet_y_pos_2 = y_pos_2;
42E4:  MOVFF  13A,17E
42E8:  CLRF   x7F
....................                //}
....................             }
....................             
....................          if(bullet_1){ // dibujar la nueva bala
42EA:  BTFSS  x57.1
42EC:  BRA    4300
....................             last_last_bullet_x_pos_1 = last_bullet_x_pos_1;
42EE:  MOVFF  16A,168
....................             last_last_bullet_y_pos_1 = last_bullet_y_pos_1;
42F2:  MOVFF  16B,169
....................             last_bullet_x_pos_1 = bullet_x_pos_1;
42F6:  MOVFF  16C,16A
....................             last_bullet_y_pos_1 = bullet_y_pos_1;
42FA:  MOVFF  16E,16B
....................          }
42FE:  BRA    4310
....................          else{
....................             last_last_bullet_x_pos_1 =  x_pos_1;
4300:  MOVFF  125,168
....................             last_last_bullet_y_pos_1 = y_pos_1;
4304:  MOVFF  126,169
....................             last_bullet_x_pos_1 =  x_pos_1;
4308:  MOVFF  125,16A
....................             last_bullet_y_pos_1 = y_pos_1;
430C:  MOVFF  126,16B
....................          }
....................          
....................          if(bullet_2){ // dibujar la nueva bala
4310:  BTFSS  x57.3
4312:  BRA    4326
....................             last_last_bullet_x_pos_2 = last_bullet_x_pos_2;
4314:  MOVFF  17A,178
....................             last_last_bullet_y_pos_2 = last_bullet_y_pos_2;
4318:  MOVFF  17B,179
....................             last_bullet_x_pos_2 = bullet_x_pos_2;
431C:  MOVFF  17C,17A
....................             last_bullet_y_pos_2 = bullet_y_pos_2;
4320:  MOVFF  17E,17B
....................          }
4324:  BRA    4336
....................          else{
....................             last_last_bullet_x_pos_2 =  x_pos_2;
4326:  MOVFF  139,178
....................             last_last_bullet_y_pos_2 = y_pos_2;
432A:  MOVFF  13A,179
....................             last_bullet_x_pos_2 =  x_pos_2;
432E:  MOVFF  139,17A
....................             last_bullet_y_pos_2 = y_pos_2;
4332:  MOVFF  13A,17B
....................          }
....................          
....................          draw_cuadrito(last_x_pos_1,last_y_pos_1,0);
4336:  MOVFF  123,25D
433A:  MOVFF  124,25E
433E:  MOVLB  2
4340:  CLRF   x5F
4342:  MOVLB  0
4344:  CALL   243A
....................          draw_cuadrito(x_pos_1,y_pos_1,1);
4348:  MOVFF  125,25D
434C:  MOVFF  126,25E
4350:  MOVLW  01
4352:  MOVLB  2
4354:  MOVWF  x5F
4356:  MOVLB  0
4358:  CALL   243A
.................... 
....................          last_x_pos_1 = x_pos_1;
435C:  MOVFF  125,123
....................          last_y_pos_1 = y_pos_1;
4360:  MOVFF  126,124
....................          
....................          draw_cuadrito(last_x_pos_2,last_y_pos_2,0);
4364:  MOVFF  137,25D
4368:  MOVFF  138,25E
436C:  MOVLB  2
436E:  CLRF   x5F
4370:  MOVLB  0
4372:  CALL   243A
....................          draw_cuadrito(x_pos_2,y_pos_2,1);
4376:  MOVFF  139,25D
437A:  MOVFF  13A,25E
437E:  MOVLW  01
4380:  MOVLB  2
4382:  MOVWF  x5F
4384:  MOVLB  0
4386:  CALL   243A
.................... 
....................          last_x_pos_2 = x_pos_2;
438A:  MOVFF  139,137
....................          last_y_pos_2 = y_pos_2;
438E:  MOVFF  13A,138
....................             delay_ms(35);
4392:  MOVLW  23
4394:  MOVLB  2
4396:  MOVWF  x60
4398:  MOVLB  0
439A:  CALL   05EC
....................             
....................             if(win){
439E:  MOVLB  2
43A0:  BTFSS  x1C.0
43A2:  BRA    4448
....................                win = 0;
43A4:  BCF    x1C.0
....................                if(!who){
43A6:  BTFSC  x1C.1
43A8:  BRA    43FA
....................                   glcd_fillScreen(0);
43AA:  CLRF   x73
43AC:  MOVLB  0
43AE:  CALL   0658
....................                   inicio(1);
43B2:  MOVLW  01
43B4:  MOVLB  2
43B6:  MOVWF  x5D
43B8:  MOVLB  0
43BA:  CALL   0C10
....................                   char tewion[] = "GANA 1";
43BE:  MOVLW  47
43C0:  MOVLB  2
43C2:  MOVWF  x4F
43C4:  MOVLW  41
43C6:  MOVWF  x50
43C8:  MOVLW  4E
43CA:  MOVWF  x51
43CC:  MOVLW  41
43CE:  MOVWF  x52
43D0:  MOVLW  20
43D2:  MOVWF  x53
43D4:  MOVLW  31
43D6:  MOVWF  x54
43D8:  CLRF   x55
....................                   glcd_text57(22,50,tewion,1,1);
43DA:  MOVLW  16
43DC:  MOVWF  x83
43DE:  MOVLW  32
43E0:  MOVWF  x84
43E2:  MOVLW  02
43E4:  MOVWF  x86
43E6:  MOVLW  4F
43E8:  MOVWF  x85
43EA:  MOVLW  01
43EC:  MOVWF  x87
43EE:  MOVWF  x88
43F0:  MOVLB  0
43F2:  CALL   08B4
....................                }
43F6:  BRA    4446
43F8:  MOVLB  2
....................                else{
....................                   glcd_fillScreen(0);
43FA:  CLRF   x73
43FC:  MOVLB  0
43FE:  CALL   0658
....................                   inicio(1);
4402:  MOVLW  01
4404:  MOVLB  2
4406:  MOVWF  x5D
4408:  MOVLB  0
440A:  CALL   0C10
....................                   char tewion[] = "GANA 2";
440E:  MOVLW  47
4410:  MOVLB  2
4412:  MOVWF  x56
4414:  MOVLW  41
4416:  MOVWF  x57
4418:  MOVLW  4E
441A:  MOVWF  x58
441C:  MOVLW  41
441E:  MOVWF  x59
4420:  MOVLW  20
4422:  MOVWF  x5A
4424:  MOVLW  32
4426:  MOVWF  x5B
4428:  CLRF   x5C
....................                   glcd_text57(22,50,tewion,1,1);
442A:  MOVLW  16
442C:  MOVWF  x83
442E:  MOVLW  32
4430:  MOVWF  x84
4432:  MOVLW  02
4434:  MOVWF  x86
4436:  MOVLW  56
4438:  MOVWF  x85
443A:  MOVLW  01
443C:  MOVWF  x87
443E:  MOVWF  x88
4440:  MOVLB  0
4442:  CALL   08B4
4446:  MOVLB  2
....................                }
....................             }
....................             
....................             break;
4448:  BRA    444E
444A:  MOVLB  0
....................             }
....................          default:{
....................             break;
444C:  MOVLB  2
....................          }
....................       }
.................... 
....................             printf("p");
444E:  MOVLW  70
4450:  BTFSS  F9E.4
4452:  BRA    4450
4454:  MOVWF  FAD
4456:  GOTO   2824
....................             
....................    }
.................... }
.................... 
445A:  SLEEP 
.................... void glcd_line(int x1, int y1, int x2, int y2, int1 color){
....................    signed int  x, y, addx, addy, dx, dy;
....................    signed long P;
....................    int i;
....................    dx = abs((signed int)(x2 - x1));
*
0A70:  MOVLB  2
0A72:  MOVF   x83,W
0A74:  SUBWF  x85,W
0A76:  MOVWF  x91
0A78:  MOVF   x91,W
0A7A:  BTFSS  x91.7
0A7C:  BRA    0A84
0A7E:  MOVLW  00
0A80:  BSF    FD8.0
0A82:  SUBFWB x91,W
0A84:  MOVWF  x8C
....................    dy = abs((signed int)(y2 - y1));
0A86:  MOVF   x84,W
0A88:  SUBWF  x86,W
0A8A:  MOVWF  x91
0A8C:  MOVF   x91,W
0A8E:  BTFSS  x91.7
0A90:  BRA    0A98
0A92:  MOVLW  00
0A94:  BSF    FD8.0
0A96:  SUBFWB x91,W
0A98:  MOVWF  x8D
....................    x = x1;
0A9A:  MOVFF  283,288
....................    y = y1;
0A9E:  MOVFF  284,289
.................... 
....................    if(x1 > x2)
0AA2:  MOVF   x83,W
0AA4:  SUBWF  x85,W
0AA6:  BC    0AAC
....................       addx = -1;
0AA8:  SETF   x8A
0AAA:  BRA    0AB0
....................    else
....................       addx = 1;
0AAC:  MOVLW  01
0AAE:  MOVWF  x8A
....................    if(y1 > y2)
0AB0:  MOVF   x84,W
0AB2:  SUBWF  x86,W
0AB4:  BC    0ABA
....................       addy = -1;
0AB6:  SETF   x8B
0AB8:  BRA    0ABE
....................    else
....................       addy = 1;
0ABA:  MOVLW  01
0ABC:  MOVWF  x8B
.................... 
....................    if(dx >= dy)
0ABE:  MOVF   x8D,W
0AC0:  XORLW  80
0AC2:  MOVWF  00
0AC4:  MOVF   x8C,W
0AC6:  XORLW  80
0AC8:  SUBWF  00,W
0ACA:  BZ    0ACE
0ACC:  BC    0B6E
....................    {
....................       P = 2*dy - dx;
0ACE:  MOVLW  02
0AD0:  MOVWF  x92
0AD2:  MOVFF  28D,293
0AD6:  MOVLB  0
0AD8:  RCALL  0A22
0ADA:  MOVLB  2
0ADC:  MOVF   x8C,W
0ADE:  SUBWF  01,W
0AE0:  CLRF   03
0AE2:  BTFSC  FE8.7
0AE4:  DECF   03,F
0AE6:  MOVWF  x8E
0AE8:  MOVFF  03,28F
.................... 
....................       for(i=0; i<=dx; ++i)
0AEC:  CLRF   x90
0AEE:  BTFSC  x8C.7
0AF0:  BRA    0B6C
0AF2:  MOVF   x90,W
0AF4:  SUBWF  x8C,W
0AF6:  BNC   0B6C
....................       {
....................          glcd_pixel(x, y, color);
0AF8:  MOVFF  288,295
0AFC:  MOVFF  289,296
0B00:  MOVFF  287,297
0B04:  MOVLB  0
0B06:  RCALL  07C8
.................... 
....................          if(P < 0)
0B08:  MOVLB  2
0B0A:  BTFSS  x8F.7
0B0C:  BRA    0B30
....................          {
....................             P += 2*dy;
0B0E:  MOVLW  02
0B10:  MOVWF  x92
0B12:  MOVFF  28D,293
0B16:  MOVLB  0
0B18:  RCALL  0A22
0B1A:  MOVF   01,W
0B1C:  CLRF   03
0B1E:  BTFSC  FE8.7
0B20:  DECF   03,F
0B22:  MOVLB  2
0B24:  ADDWF  x8E,F
0B26:  MOVF   03,W
0B28:  ADDWFC x8F,F
....................             x += addx;
0B2A:  MOVF   x8A,W
0B2C:  ADDWF  x88,F
....................          }
0B2E:  BRA    0B68
....................          else
....................          {
....................             P += 2*dy - 2*dx;
0B30:  MOVLW  02
0B32:  MOVWF  x92
0B34:  MOVFF  28D,293
0B38:  MOVLB  0
0B3A:  RCALL  0A22
0B3C:  MOVFF  01,291
0B40:  MOVLW  02
0B42:  MOVLB  2
0B44:  MOVWF  x92
0B46:  MOVFF  28C,293
0B4A:  MOVLB  0
0B4C:  RCALL  0A22
0B4E:  MOVF   01,W
0B50:  MOVLB  2
0B52:  SUBWF  x91,W
0B54:  CLRF   03
0B56:  BTFSC  FE8.7
0B58:  DECF   03,F
0B5A:  ADDWF  x8E,F
0B5C:  MOVF   03,W
0B5E:  ADDWFC x8F,F
....................             x += addx;
0B60:  MOVF   x8A,W
0B62:  ADDWF  x88,F
....................             y += addy;
0B64:  MOVF   x8B,W
0B66:  ADDWF  x89,F
....................          }
0B68:  INCF   x90,F
0B6A:  BRA    0AEE
....................       }
....................    }
0B6C:  BRA    0C0C
....................    else
....................    {
....................       P = 2*dx - dy;
0B6E:  MOVLW  02
0B70:  MOVWF  x92
0B72:  MOVFF  28C,293
0B76:  MOVLB  0
0B78:  RCALL  0A22
0B7A:  MOVLB  2
0B7C:  MOVF   x8D,W
0B7E:  SUBWF  01,W
0B80:  CLRF   03
0B82:  BTFSC  FE8.7
0B84:  DECF   03,F
0B86:  MOVWF  x8E
0B88:  MOVFF  03,28F
.................... 
....................       for(i=0; i<=dy; ++i)
0B8C:  CLRF   x90
0B8E:  BTFSC  x8D.7
0B90:  BRA    0C0C
0B92:  MOVF   x90,W
0B94:  SUBWF  x8D,W
0B96:  BNC   0C0C
....................       {
....................          glcd_pixel(x, y, color);
0B98:  MOVFF  288,295
0B9C:  MOVFF  289,296
0BA0:  MOVFF  287,297
0BA4:  MOVLB  0
0BA6:  RCALL  07C8
.................... 
....................          if(P < 0)
0BA8:  MOVLB  2
0BAA:  BTFSS  x8F.7
0BAC:  BRA    0BD0
....................          {
....................             P += 2*dx;
0BAE:  MOVLW  02
0BB0:  MOVWF  x92
0BB2:  MOVFF  28C,293
0BB6:  MOVLB  0
0BB8:  RCALL  0A22
0BBA:  MOVF   01,W
0BBC:  CLRF   03
0BBE:  BTFSC  FE8.7
0BC0:  DECF   03,F
0BC2:  MOVLB  2
0BC4:  ADDWF  x8E,F
0BC6:  MOVF   03,W
0BC8:  ADDWFC x8F,F
....................             y += addy;
0BCA:  MOVF   x8B,W
0BCC:  ADDWF  x89,F
....................          }
0BCE:  BRA    0C08
....................          else
....................          {
....................             P += 2*dx - 2*dy;
0BD0:  MOVLW  02
0BD2:  MOVWF  x92
0BD4:  MOVFF  28C,293
0BD8:  MOVLB  0
0BDA:  RCALL  0A22
0BDC:  MOVFF  01,291
0BE0:  MOVLW  02
0BE2:  MOVLB  2
0BE4:  MOVWF  x92
0BE6:  MOVFF  28D,293
0BEA:  MOVLB  0
0BEC:  RCALL  0A22
0BEE:  MOVF   01,W
0BF0:  MOVLB  2
0BF2:  SUBWF  x91,W
0BF4:  CLRF   03
0BF6:  BTFSC  FE8.7
0BF8:  DECF   03,F
0BFA:  ADDWF  x8E,F
0BFC:  MOVF   03,W
0BFE:  ADDWFC x8F,F
....................             x += addx;
0C00:  MOVF   x8A,W
0C02:  ADDWF  x88,F
....................             y += addy;
0C04:  MOVF   x8B,W
0C06:  ADDWF  x89,F
....................          }
0C08:  INCF   x90,F
0C0A:  BRA    0B8E
....................       }
....................    }
0C0C:  MOVLB  0
0C0E:  RETURN 0
.................... }
.................... void glcd_lineTracing(int *xx, int *yy, int n_points, int1 color){
....................     int i;
....................     for (i = 0; i < n_points-1; i++) {      // Iterate thru all points, drawing a line between each point
....................         glcd_line((xx+i),(yy+i),(xx+i+1),(yy+i+1),color);
....................     }
....................     glcd_line((xx+i),(yy+i),(xx),(yy),color);
.................... }
.................... void draw_triangle(int x, int y, float starting_angle, int1 color){
....................    int x_points_on_glcd = (int)malloc(3 * sizeof(int));
....................    int y_points_on_glcd = (int)malloc(3 * sizeof(int));
....................    
....................    for(char i = 0; i < 3; i++){    
....................        *(x_points_on_glcd+i) = x + (char)((float)5*cos((float)i*internal_angle - starting_angle));
....................        *(y_points_on_glcd+i) = y + (char)((float)5*sin((float)i*internal_angle - starting_angle));
....................    }
....................                                             
....................    glcd_lineTracing(x_points_on_glcd,y_points_on_glcd,3,color);
....................    
....................    free(x_points_on_glcd);
....................    free(y_points_on_glcd);
.................... }
.................... void draw_asteroid(int x, int y, int life, int1 color){
*
1D7A:  MOVLB  2
1D7C:  MOVF   x62,W
1D7E:  MULLW  08
1D80:  MOVF   FF3,W
1D82:  ADDWF  x60,W
1D84:  MOVWF  x64
1D86:  MOVF   x62,W
1D88:  MULLW  08
1D8A:  MOVF   FF3,W
1D8C:  ADDWF  x61,W
1D8E:  MOVWF  x65
....................    int x2 = x + life*8;
....................    int y2 = y + life*8;
....................    
....................    if(x2 > 127){
1D90:  MOVF   x64,W
1D92:  SUBLW  7F
1D94:  BTFSC  FD8.0
1D96:  BRA    1F30
....................       glcd_line(x,y,127,y,color);
1D98:  MOVFF  260,283
1D9C:  MOVFF  261,284
1DA0:  MOVLW  7F
1DA2:  MOVWF  x85
1DA4:  MOVFF  261,286
1DA8:  MOVFF  263,287
1DAC:  MOVLB  0
1DAE:  CALL   0A70
....................       glcd_line(0,y,x2-127,y,color);
1DB2:  MOVLW  7F
1DB4:  MOVLB  2
1DB6:  SUBWF  x64,W
1DB8:  MOVWF  x66
1DBA:  CLRF   x83
1DBC:  MOVFF  261,284
1DC0:  MOVWF  x85
1DC2:  MOVFF  261,286
1DC6:  MOVFF  263,287
1DCA:  MOVLB  0
1DCC:  CALL   0A70
....................       if(y2 > 63){
1DD0:  MOVLB  2
1DD2:  MOVF   x65,W
1DD4:  SUBLW  3F
1DD6:  BC    1EB6
....................          glcd_line(x,y2-63,127,y2-63,color);
1DD8:  MOVLW  3F
1DDA:  SUBWF  x65,W
1DDC:  MOVWF  x66
1DDE:  MOVLW  3F
1DE0:  SUBWF  x65,W
1DE2:  MOVWF  x67
1DE4:  MOVFF  260,283
1DE8:  MOVFF  266,284
1DEC:  MOVLW  7F
1DEE:  MOVWF  x85
1DF0:  MOVFF  267,286
1DF4:  MOVFF  263,287
1DF8:  MOVLB  0
1DFA:  CALL   0A70
....................          glcd_line(0,y2-63,x2-127,y2-63,color);
1DFE:  MOVLW  3F
1E00:  MOVLB  2
1E02:  SUBWF  x65,W
1E04:  MOVWF  x66
1E06:  MOVLW  7F
1E08:  SUBWF  x64,W
1E0A:  MOVWF  x67
1E0C:  MOVLW  3F
1E0E:  SUBWF  x65,W
1E10:  MOVWF  x68
1E12:  CLRF   x83
1E14:  MOVFF  266,284
1E18:  MOVFF  267,285
1E1C:  MOVWF  x86
1E1E:  MOVFF  263,287
1E22:  MOVLB  0
1E24:  CALL   0A70
.................... 
....................          glcd_line(x,y,x,63,color);
1E28:  MOVFF  260,283
1E2C:  MOVFF  261,284
1E30:  MOVFF  260,285
1E34:  MOVLW  3F
1E36:  MOVLB  2
1E38:  MOVWF  x86
1E3A:  MOVFF  263,287
1E3E:  MOVLB  0
1E40:  CALL   0A70
....................          glcd_line(x,0,x,y2-63,color);
1E44:  MOVLW  3F
1E46:  MOVLB  2
1E48:  SUBWF  x65,W
1E4A:  MOVWF  x66
1E4C:  MOVFF  260,283
1E50:  CLRF   x84
1E52:  MOVFF  260,285
1E56:  MOVWF  x86
1E58:  MOVFF  263,287
1E5C:  MOVLB  0
1E5E:  CALL   0A70
....................          
....................          glcd_line(x2-127,y,x2-127,63,color);
1E62:  MOVLW  7F
1E64:  MOVLB  2
1E66:  SUBWF  x64,W
1E68:  MOVWF  x66
1E6A:  MOVLW  7F
1E6C:  SUBWF  x64,W
1E6E:  MOVWF  x67
1E70:  MOVFF  266,283
1E74:  MOVFF  261,284
1E78:  MOVWF  x85
1E7A:  MOVLW  3F
1E7C:  MOVWF  x86
1E7E:  MOVFF  263,287
1E82:  MOVLB  0
1E84:  CALL   0A70
....................          glcd_line(x2-127,0,x2-127,y2-63,color);
1E88:  MOVLW  7F
1E8A:  MOVLB  2
1E8C:  SUBWF  x64,W
1E8E:  MOVWF  x66
1E90:  MOVLW  7F
1E92:  SUBWF  x64,W
1E94:  MOVWF  x67
1E96:  MOVLW  3F
1E98:  SUBWF  x65,W
1E9A:  MOVWF  x68
1E9C:  MOVFF  266,283
1EA0:  CLRF   x84
1EA2:  MOVFF  267,285
1EA6:  MOVWF  x86
1EA8:  MOVFF  263,287
1EAC:  MOVLB  0
1EAE:  CALL   0A70
....................       }
1EB2:  BRA    1F2C
1EB4:  MOVLB  2
....................       else{
....................          glcd_line(x,y2,127,y2,color);
1EB6:  MOVFF  260,283
1EBA:  MOVFF  265,284
1EBE:  MOVLW  7F
1EC0:  MOVWF  x85
1EC2:  MOVFF  265,286
1EC6:  MOVFF  263,287
1ECA:  MOVLB  0
1ECC:  CALL   0A70
....................          glcd_line(0,y2,x2-127,y2,color);
1ED0:  MOVLW  7F
1ED2:  MOVLB  2
1ED4:  SUBWF  x64,W
1ED6:  MOVWF  x66
1ED8:  CLRF   x83
1EDA:  MOVFF  265,284
1EDE:  MOVWF  x85
1EE0:  MOVFF  265,286
1EE4:  MOVFF  263,287
1EE8:  MOVLB  0
1EEA:  CALL   0A70
.................... 
....................          glcd_line(x,y,x,y2,color);
1EEE:  MOVFF  260,283
1EF2:  MOVFF  261,284
1EF6:  MOVFF  260,285
1EFA:  MOVFF  265,286
1EFE:  MOVFF  263,287
1F02:  CALL   0A70
.................... 
....................          glcd_line(x2-127,y,x2-127,y2,color);
1F06:  MOVLW  7F
1F08:  MOVLB  2
1F0A:  SUBWF  x64,W
1F0C:  MOVWF  x66
1F0E:  MOVLW  7F
1F10:  SUBWF  x64,W
1F12:  MOVWF  x67
1F14:  MOVFF  266,283
1F18:  MOVFF  261,284
1F1C:  MOVWF  x85
1F1E:  MOVFF  265,286
1F22:  MOVFF  263,287
1F26:  MOVLB  0
1F28:  CALL   0A70
....................       }
....................    }
1F2C:  BRA    2038
1F2E:  MOVLB  2
....................    else{
....................       glcd_line(x,y,x2,y,color);
1F30:  MOVFF  260,283
1F34:  MOVFF  261,284
1F38:  MOVFF  264,285
1F3C:  MOVFF  261,286
1F40:  MOVFF  263,287
1F44:  MOVLB  0
1F46:  CALL   0A70
....................       if(y2 > 63){
1F4A:  MOVLB  2
1F4C:  MOVF   x65,W
1F4E:  SUBLW  3F
1F50:  BC    1FEE
....................          glcd_line(x,y2-63,x2,y2-63,color);
1F52:  MOVLW  3F
1F54:  SUBWF  x65,W
1F56:  MOVWF  x66
1F58:  MOVLW  3F
1F5A:  SUBWF  x65,W
1F5C:  MOVWF  x67
1F5E:  MOVFF  260,283
1F62:  MOVFF  266,284
1F66:  MOVFF  264,285
1F6A:  MOVWF  x86
1F6C:  MOVFF  263,287
1F70:  MOVLB  0
1F72:  CALL   0A70
.................... 
....................          glcd_line(x,y,x,63,color);
1F76:  MOVFF  260,283
1F7A:  MOVFF  261,284
1F7E:  MOVFF  260,285
1F82:  MOVLW  3F
1F84:  MOVLB  2
1F86:  MOVWF  x86
1F88:  MOVFF  263,287
1F8C:  MOVLB  0
1F8E:  CALL   0A70
....................          glcd_line(x,0,x,y2-63,color);
1F92:  MOVLW  3F
1F94:  MOVLB  2
1F96:  SUBWF  x65,W
1F98:  MOVWF  x66
1F9A:  MOVFF  260,283
1F9E:  CLRF   x84
1FA0:  MOVFF  260,285
1FA4:  MOVWF  x86
1FA6:  MOVFF  263,287
1FAA:  MOVLB  0
1FAC:  CALL   0A70
....................          
....................          glcd_line(x2,y,x2,63,color);
1FB0:  MOVFF  264,283
1FB4:  MOVFF  261,284
1FB8:  MOVFF  264,285
1FBC:  MOVLW  3F
1FBE:  MOVLB  2
1FC0:  MOVWF  x86
1FC2:  MOVFF  263,287
1FC6:  MOVLB  0
1FC8:  CALL   0A70
....................          glcd_line(x2,0,x2,y2-63,color);
1FCC:  MOVLW  3F
1FCE:  MOVLB  2
1FD0:  SUBWF  x65,W
1FD2:  MOVWF  x66
1FD4:  MOVFF  264,283
1FD8:  CLRF   x84
1FDA:  MOVFF  264,285
1FDE:  MOVWF  x86
1FE0:  MOVFF  263,287
1FE4:  MOVLB  0
1FE6:  CALL   0A70
....................       }
1FEA:  BRA    2038
1FEC:  MOVLB  2
....................       else{
....................          glcd_line(x,y2,x2,y2,color);
1FEE:  MOVFF  260,283
1FF2:  MOVFF  265,284
1FF6:  MOVFF  264,285
1FFA:  MOVFF  265,286
1FFE:  MOVFF  263,287
2002:  MOVLB  0
2004:  CALL   0A70
.................... 
....................          glcd_line(x,y,x,y2,color);
2008:  MOVFF  260,283
200C:  MOVFF  261,284
2010:  MOVFF  260,285
2014:  MOVFF  265,286
2018:  MOVFF  263,287
201C:  CALL   0A70
.................... 
....................          glcd_line(x2,y,x2,y2,color);
2020:  MOVFF  264,283
2024:  MOVFF  261,284
2028:  MOVFF  264,285
202C:  MOVFF  265,286
2030:  MOVFF  263,287
2034:  CALL   0A70
....................       }
....................    }
2038:  RETURN 0
.................... }
.................... 
.................... void glcd_text57(int x, int y, char* textptr, int size, int1 color){
.................... 
....................    int i, j, k, l, m;                     // Loop counters
....................    BYTE pixelData[5];                     // Stores character data
.................... 
....................    for(i=0; textptr[i] != '\0'; ++i, ++x) // Loop through the passed string
*
08B4:  MOVLB  2
08B6:  CLRF   x89
08B8:  MOVF   x89,W
08BA:  ADDWF  x85,W
08BC:  MOVWF  FE9
08BE:  MOVLW  00
08C0:  ADDWFC x86,W
08C2:  MOVWF  FEA
08C4:  MOVF   FEF,F
08C6:  BTFSC  FD8.2
08C8:  BRA    0A1E
....................    {
....................       if(textptr[i] < 'S') // Checks if the letter is in the first text array
08CA:  MOVF   x89,W
08CC:  ADDWF  x85,W
08CE:  MOVWF  FE9
08D0:  MOVLW  00
08D2:  ADDWFC x86,W
08D4:  MOVWF  FEA
08D6:  MOVF   FEF,W
08D8:  SUBLW  52
08DA:  BNC   0920
....................          memcpy(pixelData, TEXT[textptr[i]-' '], 5);
08DC:  MOVF   x89,W
08DE:  ADDWF  x85,W
08E0:  MOVWF  FE9
08E2:  MOVLW  00
08E4:  ADDWFC x86,W
08E6:  MOVWF  FEA
08E8:  MOVLW  20
08EA:  SUBWF  FEF,W
08EC:  MULLW  05
08EE:  MOVF   FF3,W
08F0:  CLRF   03
08F2:  MOVWF  x93
08F4:  MOVLW  02
08F6:  MOVWF  FEA
08F8:  MOVLW  8E
08FA:  MOVWF  FE9
08FC:  CLRF   x97
08FE:  MOVFF  293,296
0902:  MOVLW  05
0904:  MOVWF  01
0906:  CLRF   FF7
0908:  MOVF   x93,W
090A:  MOVLB  0
090C:  CALL   00AE
0910:  TBLRD*-
0912:  TBLRD*+
0914:  MOVFF  FF5,FEE
0918:  DECFSZ 01,F
091A:  BRA    0912
091C:  BRA    0980
091E:  MOVLB  2
....................       else if(textptr[i] <= '~') // Check if the letter is in the second array
0920:  MOVF   x89,W
0922:  ADDWF  x85,W
0924:  MOVWF  FE9
0926:  MOVLW  00
0928:  ADDWFC x86,W
092A:  MOVWF  FEA
092C:  MOVF   FEF,W
092E:  SUBLW  7E
0930:  BNC   0974
....................          memcpy(pixelData, TEXT2[textptr[i]-'S'], 5);
0932:  MOVF   x89,W
0934:  ADDWF  x85,W
0936:  MOVWF  FE9
0938:  MOVLW  00
093A:  ADDWFC x86,W
093C:  MOVWF  FEA
093E:  MOVLW  53
0940:  SUBWF  FEF,W
0942:  MULLW  05
0944:  MOVF   FF3,W
0946:  CLRF   03
0948:  MOVWF  x93
094A:  MOVLW  02
094C:  MOVWF  FEA
094E:  MOVLW  8E
0950:  MOVWF  FE9
0952:  CLRF   x97
0954:  MOVFF  293,296
0958:  MOVLW  05
095A:  MOVWF  01
095C:  CLRF   FF7
095E:  MOVF   x93,W
0960:  MOVLB  0
0962:  RCALL  01BE
0964:  TBLRD*-
0966:  TBLRD*+
0968:  MOVFF  FF5,FEE
096C:  DECFSZ 01,F
096E:  BRA    0966
0970:  BRA    0980
0972:  MOVLB  2
....................       else
....................          memcpy(pixelData, TEXT[0], 5);   // Default to space
0974:  CLRF   x8E
0976:  CLRF   x8F
0978:  CLRF   x90
097A:  CLRF   x91
097C:  CLRF   x92
097E:  MOVLB  0
.................... 
....................       if(x+5*size >= GLCD_WIDTH)          // Performs character wrapping
0980:  MOVLB  2
0982:  MOVF   x87,W
0984:  MULLW  05
0986:  MOVF   FF3,W
0988:  ADDWF  x83,W
098A:  SUBLW  7F
098C:  BC    099A
....................       {
....................          x = 0;                           // Set x at far left position
098E:  CLRF   x83
....................          y += 7*size + 1;                 // Set y at next position down
0990:  MOVF   x87,W
0992:  MULLW  07
0994:  MOVF   FF3,W
0996:  ADDLW  01
0998:  ADDWF  x84,F
....................       }
....................       for(j=0; j<5; ++j, x+=size)         // Loop through character byte data
099A:  CLRF   x8A
099C:  MOVF   x8A,W
099E:  SUBLW  04
09A0:  BNC   0A18
....................       {
....................          for(k=0; k<7*size; ++k)          // Loop through the vertical pixels
09A2:  CLRF   x8B
09A4:  MOVF   x87,W
09A6:  MULLW  07
09A8:  MOVF   FF3,W
09AA:  SUBWF  x8B,W
09AC:  BC    0A10
....................          {
....................             if(bit_test(pixelData[j], k)) // Check if the pixel should be set
09AE:  CLRF   03
09B0:  MOVF   x8A,W
09B2:  ADDLW  8E
09B4:  MOVWF  FE9
09B6:  MOVLW  02
09B8:  ADDWFC 03,W
09BA:  MOVWF  FEA
09BC:  MOVFF  FEF,00
09C0:  MOVF   x8B,W
09C2:  MOVWF  01
09C4:  BZ    09CE
09C6:  BCF    FD8.0
09C8:  RRCF   00,F
09CA:  DECFSZ 01,F
09CC:  BRA    09C6
09CE:  BTFSS  00.0
09D0:  BRA    0A0C
....................             {
....................                for(l=0; l<size; ++l)      // The next two loops change the
09D2:  CLRF   x8C
09D4:  MOVF   x87,W
09D6:  SUBWF  x8C,W
09D8:  BC    0A0C
....................                {                          // character's size
....................                   for(m=0; m<size; ++m)
09DA:  CLRF   x8D
09DC:  MOVF   x87,W
09DE:  SUBWF  x8D,W
09E0:  BC    0A08
....................                   {
....................                      glcd_pixel(x+m, y+k*size+l, color); // Draws the pixel
09E2:  MOVF   x8D,W
09E4:  ADDWF  x83,W
09E6:  MOVWF  x93
09E8:  MOVF   x8B,W
09EA:  MULWF  x87
09EC:  MOVF   FF3,W
09EE:  ADDWF  x84,W
09F0:  ADDWF  x8C,W
09F2:  MOVWF  x94
09F4:  MOVFF  293,295
09F8:  MOVWF  x96
09FA:  MOVFF  288,297
09FE:  MOVLB  0
0A00:  RCALL  07C8
0A02:  MOVLB  2
0A04:  INCF   x8D,F
0A06:  BRA    09DC
....................                   }
0A08:  INCF   x8C,F
0A0A:  BRA    09D4
....................                }
....................             }
0A0C:  INCF   x8B,F
0A0E:  BRA    09A4
....................          }
0A10:  INCF   x8A,F
0A12:  MOVF   x87,W
0A14:  ADDWF  x83,F
0A16:  BRA    099C
....................       }
0A18:  INCF   x89,F
0A1A:  INCF   x83,F
0A1C:  BRA    08B8
....................    }
0A1E:  MOVLB  0
0A20:  RETURN 0
.................... }
.................... 
.................... void inicio(int sec){
....................    switch(sec){
*
0C10:  MOVLB  2
0C12:  MOVF   x5D,W
0C14:  XORLW  01
0C16:  MOVLB  0
0C18:  BZ    0C22
0C1A:  XORLW  03
0C1C:  BTFSC  FD8.2
0C1E:  BRA    0D4C
0C20:  BRA    0E76
....................       case 1:{
....................          char text_asteroids[] = "ASTEROIDS";
0C22:  MOVLW  41
0C24:  MOVLB  2
0C26:  MOVWF  x5E
0C28:  MOVLW  53
0C2A:  MOVWF  x5F
0C2C:  MOVLW  54
0C2E:  MOVWF  x60
0C30:  MOVLW  45
0C32:  MOVWF  x61
0C34:  MOVLW  52
0C36:  MOVWF  x62
0C38:  MOVLW  4F
0C3A:  MOVWF  x63
0C3C:  MOVLW  49
0C3E:  MOVWF  x64
0C40:  MOVLW  44
0C42:  MOVWF  x65
0C44:  MOVLW  53
0C46:  MOVWF  x66
0C48:  CLRF   x67
....................          glcd_text57(38,4,text_asteroids,1,1);
0C4A:  MOVLW  26
0C4C:  MOVWF  x83
0C4E:  MOVLW  04
0C50:  MOVWF  x84
0C52:  MOVLW  02
0C54:  MOVWF  x86
0C56:  MOVLW  5E
0C58:  MOVWF  x85
0C5A:  MOVLW  01
0C5C:  MOVWF  x87
0C5E:  MOVWF  x88
0C60:  MOVLB  0
0C62:  RCALL  08B4
....................          
....................          for(int i = 0; i < 16; i++){
0C64:  MOVLB  2
0C66:  CLRF   x68
0C68:  MOVF   x68,W
0C6A:  SUBLW  0F
0C6C:  BNC   0D48
....................             for(int j = 0; j < 16; j++){
0C6E:  CLRF   x69
0C70:  MOVF   x69,W
0C72:  SUBLW  0F
0C74:  BNC   0D44
....................                if(personaje[j][i] == 1){
0C76:  MOVF   x69,W
0C78:  MULLW  10
0C7A:  MOVF   FF3,W
0C7C:  CLRF   x84
0C7E:  MOVWF  x83
0C80:  CLRF   03
0C82:  MOVF   x68,W
0C84:  ADDWF  x83,W
0C86:  MOVWF  01
0C88:  MOVF   x84,W
0C8A:  ADDWFC 03,F
0C8C:  MOVF   01,W
0C8E:  ADDLW  1B
0C90:  MOVWF  FE9
0C92:  MOVLW  00
0C94:  ADDWFC 03,W
0C96:  MOVWF  FEA
0C98:  DECFSZ FEF,W
0C9A:  BRA    0CF0
....................                   glcd_pixel(20+i,26+j,0);
0C9C:  MOVLW  14
0C9E:  ADDWF  x68,W
0CA0:  MOVWF  x83
0CA2:  MOVLW  1A
0CA4:  ADDWF  x69,W
0CA6:  MOVWF  x84
0CA8:  MOVFF  283,295
0CAC:  MOVWF  x96
0CAE:  CLRF   x97
0CB0:  MOVLB  0
0CB2:  RCALL  07C8
....................                   
....................                   glcd_pixel(82+i,26+j,1);
0CB4:  MOVLW  52
0CB6:  MOVLB  2
0CB8:  ADDWF  x68,W
0CBA:  MOVWF  x83
0CBC:  MOVLW  1A
0CBE:  ADDWF  x69,W
0CC0:  MOVWF  x84
0CC2:  MOVFF  283,295
0CC6:  MOVWF  x96
0CC8:  MOVLW  01
0CCA:  MOVWF  x97
0CCC:  MOVLB  0
0CCE:  RCALL  07C8
....................                   glcd_pixel(96+i,26+j,1);
0CD0:  MOVLW  60
0CD2:  MOVLB  2
0CD4:  ADDWF  x68,W
0CD6:  MOVWF  x83
0CD8:  MOVLW  1A
0CDA:  ADDWF  x69,W
0CDC:  MOVWF  x84
0CDE:  MOVFF  283,295
0CE2:  MOVWF  x96
0CE4:  MOVLW  01
0CE6:  MOVWF  x97
0CE8:  MOVLB  0
0CEA:  RCALL  07C8
....................                }
0CEC:  BRA    0D3E
0CEE:  MOVLB  2
....................                else{
....................                   glcd_pixel(20+i,26+j,1);
0CF0:  MOVLW  14
0CF2:  ADDWF  x68,W
0CF4:  MOVWF  x83
0CF6:  MOVLW  1A
0CF8:  ADDWF  x69,W
0CFA:  MOVWF  x84
0CFC:  MOVFF  283,295
0D00:  MOVWF  x96
0D02:  MOVLW  01
0D04:  MOVWF  x97
0D06:  MOVLB  0
0D08:  RCALL  07C8
....................                   
....................                   glcd_pixel(82+i,26+j,0);
0D0A:  MOVLW  52
0D0C:  MOVLB  2
0D0E:  ADDWF  x68,W
0D10:  MOVWF  x83
0D12:  MOVLW  1A
0D14:  ADDWF  x69,W
0D16:  MOVWF  x84
0D18:  MOVFF  283,295
0D1C:  MOVWF  x96
0D1E:  CLRF   x97
0D20:  MOVLB  0
0D22:  RCALL  07C8
....................                   glcd_pixel(96+i,26+j,0);
0D24:  MOVLW  60
0D26:  MOVLB  2
0D28:  ADDWF  x68,W
0D2A:  MOVWF  x83
0D2C:  MOVLW  1A
0D2E:  ADDWF  x69,W
0D30:  MOVWF  x84
0D32:  MOVFF  283,295
0D36:  MOVWF  x96
0D38:  CLRF   x97
0D3A:  MOVLB  0
0D3C:  RCALL  07C8
....................                }
0D3E:  MOVLB  2
0D40:  INCF   x69,F
0D42:  BRA    0C70
....................             }
0D44:  INCF   x68,F
0D46:  BRA    0C68
....................          }
....................       break;
0D48:  BRA    0FC4
0D4A:  MOVLB  0
....................       }
....................       case 2:{
....................          char text_asteroids[] = "ASTEROIDS";
0D4C:  MOVLW  41
0D4E:  MOVLB  2
0D50:  MOVWF  x6A
0D52:  MOVLW  53
0D54:  MOVWF  x6B
0D56:  MOVLW  54
0D58:  MOVWF  x6C
0D5A:  MOVLW  45
0D5C:  MOVWF  x6D
0D5E:  MOVLW  52
0D60:  MOVWF  x6E
0D62:  MOVLW  4F
0D64:  MOVWF  x6F
0D66:  MOVLW  49
0D68:  MOVWF  x70
0D6A:  MOVLW  44
0D6C:  MOVWF  x71
0D6E:  MOVLW  53
0D70:  MOVWF  x72
0D72:  CLRF   x73
....................          glcd_text57(38,4,text_asteroids,1,1);
0D74:  MOVLW  26
0D76:  MOVWF  x83
0D78:  MOVLW  04
0D7A:  MOVWF  x84
0D7C:  MOVLW  02
0D7E:  MOVWF  x86
0D80:  MOVLW  6A
0D82:  MOVWF  x85
0D84:  MOVLW  01
0D86:  MOVWF  x87
0D88:  MOVWF  x88
0D8A:  MOVLB  0
0D8C:  RCALL  08B4
....................          
....................          for(int i = 0; i < 16; i++){
0D8E:  MOVLB  2
0D90:  CLRF   x74
0D92:  MOVF   x74,W
0D94:  SUBLW  0F
0D96:  BNC   0E72
....................             for(int j = 0; j < 16; j++){
0D98:  CLRF   x75
0D9A:  MOVF   x75,W
0D9C:  SUBLW  0F
0D9E:  BNC   0E6E
....................                if(personaje[j][i] == 1){
0DA0:  MOVF   x75,W
0DA2:  MULLW  10
0DA4:  MOVF   FF3,W
0DA6:  CLRF   x84
0DA8:  MOVWF  x83
0DAA:  CLRF   03
0DAC:  MOVF   x74,W
0DAE:  ADDWF  x83,W
0DB0:  MOVWF  01
0DB2:  MOVF   x84,W
0DB4:  ADDWFC 03,F
0DB6:  MOVF   01,W
0DB8:  ADDLW  1B
0DBA:  MOVWF  FE9
0DBC:  MOVLW  00
0DBE:  ADDWFC 03,W
0DC0:  MOVWF  FEA
0DC2:  DECFSZ FEF,W
0DC4:  BRA    0E18
....................                   glcd_pixel(20+i,26+j,1);
0DC6:  MOVLW  14
0DC8:  ADDWF  x74,W
0DCA:  MOVWF  x83
0DCC:  MOVLW  1A
0DCE:  ADDWF  x75,W
0DD0:  MOVWF  x84
0DD2:  MOVFF  283,295
0DD6:  MOVWF  x96
0DD8:  MOVLW  01
0DDA:  MOVWF  x97
0DDC:  MOVLB  0
0DDE:  RCALL  07C8
....................                   
....................                   glcd_pixel(82+i,26+j,0);
0DE0:  MOVLW  52
0DE2:  MOVLB  2
0DE4:  ADDWF  x74,W
0DE6:  MOVWF  x83
0DE8:  MOVLW  1A
0DEA:  ADDWF  x75,W
0DEC:  MOVWF  x84
0DEE:  MOVFF  283,295
0DF2:  MOVWF  x96
0DF4:  CLRF   x97
0DF6:  MOVLB  0
0DF8:  RCALL  07C8
....................                   glcd_pixel(96+i,26+j,0);
0DFA:  MOVLW  60
0DFC:  MOVLB  2
0DFE:  ADDWF  x74,W
0E00:  MOVWF  x83
0E02:  MOVLW  1A
0E04:  ADDWF  x75,W
0E06:  MOVWF  x84
0E08:  MOVFF  283,295
0E0C:  MOVWF  x96
0E0E:  CLRF   x97
0E10:  MOVLB  0
0E12:  RCALL  07C8
....................                }
0E14:  BRA    0E68
0E16:  MOVLB  2
....................                else{
....................                   glcd_pixel(20+i,26+j,0);
0E18:  MOVLW  14
0E1A:  ADDWF  x74,W
0E1C:  MOVWF  x83
0E1E:  MOVLW  1A
0E20:  ADDWF  x75,W
0E22:  MOVWF  x84
0E24:  MOVFF  283,295
0E28:  MOVWF  x96
0E2A:  CLRF   x97
0E2C:  MOVLB  0
0E2E:  RCALL  07C8
....................                   
....................                   glcd_pixel(82+i,26+j,1);
0E30:  MOVLW  52
0E32:  MOVLB  2
0E34:  ADDWF  x74,W
0E36:  MOVWF  x83
0E38:  MOVLW  1A
0E3A:  ADDWF  x75,W
0E3C:  MOVWF  x84
0E3E:  MOVFF  283,295
0E42:  MOVWF  x96
0E44:  MOVLW  01
0E46:  MOVWF  x97
0E48:  MOVLB  0
0E4A:  RCALL  07C8
....................                   glcd_pixel(96+i,26+j,1);
0E4C:  MOVLW  60
0E4E:  MOVLB  2
0E50:  ADDWF  x74,W
0E52:  MOVWF  x83
0E54:  MOVLW  1A
0E56:  ADDWF  x75,W
0E58:  MOVWF  x84
0E5A:  MOVFF  283,295
0E5E:  MOVWF  x96
0E60:  MOVLW  01
0E62:  MOVWF  x97
0E64:  MOVLB  0
0E66:  RCALL  07C8
....................                }
0E68:  MOVLB  2
0E6A:  INCF   x75,F
0E6C:  BRA    0D9A
....................             }
0E6E:  INCF   x74,F
0E70:  BRA    0D92
....................          }
....................       break;
0E72:  BRA    0FC4
0E74:  MOVLB  0
....................       }
....................       default:{
....................          for(int i = 2; i < 13; i++){
0E76:  MOVLW  02
0E78:  MOVLB  2
0E7A:  MOVWF  x76
0E7C:  MOVF   x76,W
0E7E:  SUBLW  0C
0E80:  BNC   0EA0
....................             glcd_line(32,i,97,i,1);
0E82:  MOVLW  20
0E84:  MOVWF  x83
0E86:  MOVFF  276,284
0E8A:  MOVLW  61
0E8C:  MOVWF  x85
0E8E:  MOVFF  276,286
0E92:  MOVLW  01
0E94:  MOVWF  x87
0E96:  MOVLB  0
0E98:  RCALL  0A70
0E9A:  MOVLB  2
0E9C:  INCF   x76,F
0E9E:  BRA    0E7C
....................          }
....................          char text_asteroids[] = "ASTEROIDS";
0EA0:  MOVLW  41
0EA2:  MOVWF  x77
0EA4:  MOVLW  53
0EA6:  MOVWF  x78
0EA8:  MOVLW  54
0EAA:  MOVWF  x79
0EAC:  MOVLW  45
0EAE:  MOVWF  x7A
0EB0:  MOVLW  52
0EB2:  MOVWF  x7B
0EB4:  MOVLW  4F
0EB6:  MOVWF  x7C
0EB8:  MOVLW  49
0EBA:  MOVWF  x7D
0EBC:  MOVLW  44
0EBE:  MOVWF  x7E
0EC0:  MOVLW  53
0EC2:  MOVWF  x7F
0EC4:  CLRF   x80
....................          glcd_text57(38,4,text_asteroids,1,0);
0EC6:  MOVLW  26
0EC8:  MOVWF  x83
0ECA:  MOVLW  04
0ECC:  MOVWF  x84
0ECE:  MOVLW  02
0ED0:  MOVWF  x86
0ED2:  MOVLW  77
0ED4:  MOVWF  x85
0ED6:  MOVLW  01
0ED8:  MOVWF  x87
0EDA:  CLRF   x88
0EDC:  MOVLB  0
0EDE:  RCALL  08B4
....................          
....................          for(int i = 0; i < 16; i++){
0EE0:  MOVLB  2
0EE2:  CLRF   x81
0EE4:  MOVF   x81,W
0EE6:  SUBLW  0F
0EE8:  BNC   0FC4
....................             for(int j = 0; j < 16; j++){
0EEA:  CLRF   x82
0EEC:  MOVF   x82,W
0EEE:  SUBLW  0F
0EF0:  BNC   0FC0
....................                if(personaje[j][i] == 1){
0EF2:  MOVF   x82,W
0EF4:  MULLW  10
0EF6:  MOVF   FF3,W
0EF8:  CLRF   x84
0EFA:  MOVWF  x83
0EFC:  CLRF   03
0EFE:  MOVF   x81,W
0F00:  ADDWF  x83,W
0F02:  MOVWF  01
0F04:  MOVF   x84,W
0F06:  ADDWFC 03,F
0F08:  MOVF   01,W
0F0A:  ADDLW  1B
0F0C:  MOVWF  FE9
0F0E:  MOVLW  00
0F10:  ADDWFC 03,W
0F12:  MOVWF  FEA
0F14:  DECFSZ FEF,W
0F16:  BRA    0F6E
....................                   glcd_pixel(20+i,26+j,1);
0F18:  MOVLW  14
0F1A:  ADDWF  x81,W
0F1C:  MOVWF  x83
0F1E:  MOVLW  1A
0F20:  ADDWF  x82,W
0F22:  MOVWF  x84
0F24:  MOVFF  283,295
0F28:  MOVWF  x96
0F2A:  MOVLW  01
0F2C:  MOVWF  x97
0F2E:  MOVLB  0
0F30:  RCALL  07C8
....................                   
....................                   glcd_pixel(82+i,26+j,1);
0F32:  MOVLW  52
0F34:  MOVLB  2
0F36:  ADDWF  x81,W
0F38:  MOVWF  x83
0F3A:  MOVLW  1A
0F3C:  ADDWF  x82,W
0F3E:  MOVWF  x84
0F40:  MOVFF  283,295
0F44:  MOVWF  x96
0F46:  MOVLW  01
0F48:  MOVWF  x97
0F4A:  MOVLB  0
0F4C:  RCALL  07C8
....................                   glcd_pixel(96+i,26+j,1);
0F4E:  MOVLW  60
0F50:  MOVLB  2
0F52:  ADDWF  x81,W
0F54:  MOVWF  x83
0F56:  MOVLW  1A
0F58:  ADDWF  x82,W
0F5A:  MOVWF  x84
0F5C:  MOVFF  283,295
0F60:  MOVWF  x96
0F62:  MOVLW  01
0F64:  MOVWF  x97
0F66:  MOVLB  0
0F68:  RCALL  07C8
....................                }
0F6A:  BRA    0FBA
0F6C:  MOVLB  2
....................                else{
....................                   glcd_pixel(20+i,26+j,0);
0F6E:  MOVLW  14
0F70:  ADDWF  x81,W
0F72:  MOVWF  x83
0F74:  MOVLW  1A
0F76:  ADDWF  x82,W
0F78:  MOVWF  x84
0F7A:  MOVFF  283,295
0F7E:  MOVWF  x96
0F80:  CLRF   x97
0F82:  MOVLB  0
0F84:  RCALL  07C8
....................                   
....................                   glcd_pixel(82+i,26+j,0);
0F86:  MOVLW  52
0F88:  MOVLB  2
0F8A:  ADDWF  x81,W
0F8C:  MOVWF  x83
0F8E:  MOVLW  1A
0F90:  ADDWF  x82,W
0F92:  MOVWF  x84
0F94:  MOVFF  283,295
0F98:  MOVWF  x96
0F9A:  CLRF   x97
0F9C:  MOVLB  0
0F9E:  RCALL  07C8
....................                   glcd_pixel(96+i,26+j,0);
0FA0:  MOVLW  60
0FA2:  MOVLB  2
0FA4:  ADDWF  x81,W
0FA6:  MOVWF  x83
0FA8:  MOVLW  1A
0FAA:  ADDWF  x82,W
0FAC:  MOVWF  x84
0FAE:  MOVFF  283,295
0FB2:  MOVWF  x96
0FB4:  CLRF   x97
0FB6:  MOVLB  0
0FB8:  RCALL  07C8
....................                }
0FBA:  MOVLB  2
0FBC:  INCF   x82,F
0FBE:  BRA    0EEC
....................             }
0FC0:  INCF   x81,F
0FC2:  BRA    0EE4
....................          }
....................       break;
....................       }
....................    }
0FC4:  MOVLB  0
0FC6:  RETURN 0
.................... }
.................... 
.................... void single_menu(int1 play){
....................    char text_ret[] = "RETURN";
0FC8:  MOVLW  52
0FCA:  MOVLB  2
0FCC:  MOVWF  x5E
0FCE:  MOVLW  45
0FD0:  MOVWF  x5F
0FD2:  MOVLW  54
0FD4:  MOVWF  x60
0FD6:  MOVLW  55
0FD8:  MOVWF  x61
0FDA:  MOVLW  52
0FDC:  MOVWF  x62
0FDE:  MOVLW  4E
0FE0:  MOVWF  x63
0FE2:  CLRF   x64
....................    char text_play[] = "PLAY";
0FE4:  MOVLW  50
0FE6:  MOVWF  x65
0FE8:  MOVLW  4C
0FEA:  MOVWF  x66
0FEC:  MOVLW  41
0FEE:  MOVWF  x67
0FF0:  MOVLW  59
0FF2:  MOVWF  x68
0FF4:  CLRF   x69
....................    if(play){
0FF6:  MOVF   x5D,F
0FF8:  BZ    1082
....................       for(int i = 29; i <= 41;i++){
0FFA:  MOVLW  1D
0FFC:  MOVWF  x6A
0FFE:  MOVF   x6A,W
1000:  SUBLW  29
1002:  BNC   1022
....................          glcd_line(20,i,90,i,1);
1004:  MOVLW  14
1006:  MOVWF  x83
1008:  MOVFF  26A,284
100C:  MOVLW  5A
100E:  MOVWF  x85
1010:  MOVFF  26A,286
1014:  MOVLW  01
1016:  MOVWF  x87
1018:  MOVLB  0
101A:  RCALL  0A70
101C:  MOVLB  2
101E:  INCF   x6A,F
1020:  BRA    0FFE
....................       }
....................       glcd_text57(24,30,text_play,1,0);
1022:  MOVLW  18
1024:  MOVWF  x83
1026:  MOVLW  1E
1028:  MOVWF  x84
102A:  MOVLW  02
102C:  MOVWF  x86
102E:  MOVLW  65
1030:  MOVWF  x85
1032:  MOVLW  01
1034:  MOVWF  x87
1036:  CLRF   x88
1038:  MOVLB  0
103A:  RCALL  08B4
....................       
....................       for(int i = 43; i <= 55;i++){
103C:  MOVLW  2B
103E:  MOVLB  2
1040:  MOVWF  x6B
1042:  MOVF   x6B,W
1044:  SUBLW  37
1046:  BNC   1064
....................          glcd_line(20,i,90,i,0);
1048:  MOVLW  14
104A:  MOVWF  x83
104C:  MOVFF  26B,284
1050:  MOVLW  5A
1052:  MOVWF  x85
1054:  MOVFF  26B,286
1058:  CLRF   x87
105A:  MOVLB  0
105C:  RCALL  0A70
105E:  MOVLB  2
1060:  INCF   x6B,F
1062:  BRA    1042
....................       }
....................       glcd_text57(24,44,text_ret,1,1);
1064:  MOVLW  18
1066:  MOVWF  x83
1068:  MOVLW  2C
106A:  MOVWF  x84
106C:  MOVLW  02
106E:  MOVWF  x86
1070:  MOVLW  5E
1072:  MOVWF  x85
1074:  MOVLW  01
1076:  MOVWF  x87
1078:  MOVWF  x88
107A:  MOVLB  0
107C:  RCALL  08B4
....................    }
107E:  BRA    110A
1080:  MOVLB  2
....................    else{
....................       for(int i = 29; i <= 41;i++){
1082:  MOVLW  1D
1084:  MOVWF  x6C
1086:  MOVF   x6C,W
1088:  SUBLW  29
108A:  BNC   10A8
....................          glcd_line(20,i,90,i,0);
108C:  MOVLW  14
108E:  MOVWF  x83
1090:  MOVFF  26C,284
1094:  MOVLW  5A
1096:  MOVWF  x85
1098:  MOVFF  26C,286
109C:  CLRF   x87
109E:  MOVLB  0
10A0:  RCALL  0A70
10A2:  MOVLB  2
10A4:  INCF   x6C,F
10A6:  BRA    1086
....................       }
....................       glcd_text57(24,30,text_play,1,1);
10A8:  MOVLW  18
10AA:  MOVWF  x83
10AC:  MOVLW  1E
10AE:  MOVWF  x84
10B0:  MOVLW  02
10B2:  MOVWF  x86
10B4:  MOVLW  65
10B6:  MOVWF  x85
10B8:  MOVLW  01
10BA:  MOVWF  x87
10BC:  MOVWF  x88
10BE:  MOVLB  0
10C0:  CALL   08B4
....................       
....................       for(int i = 43; i <= 55;i++){
10C4:  MOVLW  2B
10C6:  MOVLB  2
10C8:  MOVWF  x6D
10CA:  MOVF   x6D,W
10CC:  SUBLW  37
10CE:  BNC   10EE
....................          glcd_line(20,i,90,i,1);
10D0:  MOVLW  14
10D2:  MOVWF  x83
10D4:  MOVFF  26D,284
10D8:  MOVLW  5A
10DA:  MOVWF  x85
10DC:  MOVFF  26D,286
10E0:  MOVLW  01
10E2:  MOVWF  x87
10E4:  MOVLB  0
10E6:  RCALL  0A70
10E8:  MOVLB  2
10EA:  INCF   x6D,F
10EC:  BRA    10CA
....................       }
....................       glcd_text57(24,44,text_ret,1,0);
10EE:  MOVLW  18
10F0:  MOVWF  x83
10F2:  MOVLW  2C
10F4:  MOVWF  x84
10F6:  MOVLW  02
10F8:  MOVWF  x86
10FA:  MOVLW  5E
10FC:  MOVWF  x85
10FE:  MOVLW  01
1100:  MOVWF  x87
1102:  CLRF   x88
1104:  MOVLB  0
1106:  CALL   08B4
....................    
....................    }
110A:  RETURN 0
.................... }
.................... 
.................... void scores(unsigned int16 scr, unsigned int lvl, int1 color){
....................    char text_score[6];
....................    sprintf(text_score, "S:%lu", scr);
*
21A2:  MOVLW  02
21A4:  MOVLB  2
21A6:  MOVWF  x17
21A8:  MOVLW  61
21AA:  MOVWF  x16
21AC:  MOVLW  53
21AE:  MOVWF  x74
21B0:  MOVLB  0
21B2:  RCALL  203A
21B4:  MOVLW  3A
21B6:  MOVLB  2
21B8:  MOVWF  x74
21BA:  MOVLB  0
21BC:  RCALL  203A
21BE:  MOVLW  10
21C0:  MOVWF  FE9
21C2:  MOVFF  25E,26C
21C6:  MOVFF  25D,26B
21CA:  BRA    205A
....................    glcd_text57(0, 0, text_score, 1, color);
21CC:  MOVLB  2
21CE:  CLRF   x83
21D0:  CLRF   x84
21D2:  MOVLW  02
21D4:  MOVWF  x86
21D6:  MOVLW  61
21D8:  MOVWF  x85
21DA:  MOVLW  01
21DC:  MOVWF  x87
21DE:  MOVFF  260,288
21E2:  MOVLB  0
21E4:  CALL   08B4
....................    char text_level[4];
....................    sprintf(text_level, "L:%u", lvl);
21E8:  MOVLW  02
21EA:  MOVLB  2
21EC:  MOVWF  x17
21EE:  MOVLW  67
21F0:  MOVWF  x16
21F2:  MOVLW  4C
21F4:  MOVWF  x74
21F6:  MOVLB  0
21F8:  RCALL  203A
21FA:  MOVLW  3A
21FC:  MOVLB  2
21FE:  MOVWF  x74
2200:  MOVLB  0
2202:  RCALL  203A
2204:  MOVFF  25F,26B
2208:  MOVLW  1B
220A:  MOVLB  2
220C:  MOVWF  x6C
220E:  MOVLB  0
2210:  RCALL  2122
....................    glcd_text57(103, 0, text_level, 1, color);
2212:  MOVLW  67
2214:  MOVLB  2
2216:  MOVWF  x83
2218:  CLRF   x84
221A:  MOVLW  02
221C:  MOVWF  x86
221E:  MOVLW  67
2220:  MOVWF  x85
2222:  MOVLW  01
2224:  MOVWF  x87
2226:  MOVFF  260,288
222A:  MOVLB  0
222C:  CALL   08B4
2230:  RETURN 0
.................... }
.................... 
.................... float get_ship_angle(){
....................    if(p1_pot_xx < 80){
*
1622:  MOVLB  2
1624:  MOVF   x0F,W
1626:  SUBLW  4F
1628:  BNC   1666
....................       if(p1_pot_yy < 80){
162A:  MOVF   x10,W
162C:  SUBLW  4F
162E:  BNC   1640
....................          return 225;
1630:  MOVLW  86
1632:  MOVWF  00
1634:  MOVLW  61
1636:  MOVWF  01
1638:  CLRF   02
163A:  CLRF   03
163C:  BRA    16DA
....................       }
163E:  BRA    1664
....................       else if(p1_pot_yy > 170){
1640:  MOVF   x10,W
1642:  SUBLW  AA
1644:  BC    1656
....................          return 135;
1646:  MOVLW  86
1648:  MOVWF  00
164A:  MOVLW  07
164C:  MOVWF  01
164E:  CLRF   02
1650:  CLRF   03
1652:  BRA    16DA
....................       }
1654:  BRA    1664
....................       else{
....................          return 180;
1656:  MOVLW  86
1658:  MOVWF  00
165A:  MOVLW  34
165C:  MOVWF  01
165E:  CLRF   02
1660:  CLRF   03
1662:  BRA    16DA
....................       }
....................    }
1664:  BRA    16DA
....................    else if(p1_pot_xx > 170){
1666:  MOVF   x0F,W
1668:  SUBLW  AA
166A:  BC    16A6
....................       if(p1_pot_yy < 80){
166C:  MOVF   x10,W
166E:  SUBLW  4F
1670:  BNC   1684
....................          return 315;
1672:  MOVLW  87
1674:  MOVWF  00
1676:  MOVLW  1D
1678:  MOVWF  01
167A:  MOVLW  80
167C:  MOVWF  02
167E:  CLRF   03
1680:  BRA    16DA
....................       }
1682:  BRA    16A4
....................       else if(p1_pot_yy > 170){
1684:  MOVF   x10,W
1686:  SUBLW  AA
1688:  BC    169A
....................          return 45;
168A:  MOVLW  84
168C:  MOVWF  00
168E:  MOVLW  34
1690:  MOVWF  01
1692:  CLRF   02
1694:  CLRF   03
1696:  BRA    16DA
....................       }
1698:  BRA    16A4
....................       else{
....................          return 0;
169A:  CLRF   00
169C:  CLRF   01
169E:  CLRF   02
16A0:  CLRF   03
16A2:  BRA    16DA
....................       }
....................    }
16A4:  BRA    16DA
....................    else{
....................       if(p1_pot_yy < 80){
16A6:  MOVF   x10,W
16A8:  SUBLW  4F
16AA:  BNC   16BC
....................          return 270;
16AC:  MOVLW  87
16AE:  MOVWF  00
16B0:  MOVLW  07
16B2:  MOVWF  01
16B4:  CLRF   02
16B6:  CLRF   03
16B8:  BRA    16DA
....................       }
16BA:  BRA    16DA
....................       else if(p1_pot_yy > 170){
16BC:  MOVF   x10,W
16BE:  SUBLW  AA
16C0:  BC    16D2
....................          return 180;
16C2:  MOVLW  86
16C4:  MOVWF  00
16C6:  MOVLW  34
16C8:  MOVWF  01
16CA:  CLRF   02
16CC:  CLRF   03
16CE:  BRA    16DA
....................       }
16D0:  BRA    16DA
....................       else{
....................          return 0;
16D2:  CLRF   00
16D4:  CLRF   01
16D6:  CLRF   02
16D8:  CLRF   03
....................       }
....................    }
16DA:  MOVLB  0
16DC:  GOTO   2B5E (RETURN)
....................    
.................... }
.................... float get_x_vel(){
....................    return (float)((float)p1_pot_x - 127.0f)/30.0f;
*
17D6:  MOVLB  2
17D8:  CLRF   x94
17DA:  MOVFF  20D,293
17DE:  MOVLB  0
17E0:  RCALL  11AE
17E2:  MOVFF  03,260
17E6:  MOVFF  02,25F
17EA:  MOVFF  01,25E
17EE:  MOVFF  00,25D
17F2:  BSF    FD8.1
17F4:  MOVFF  03,296
17F8:  MOVFF  02,295
17FC:  MOVFF  01,294
1800:  MOVFF  00,293
1804:  MOVLB  2
1806:  CLRF   x9A
1808:  CLRF   x99
180A:  MOVLW  7E
180C:  MOVWF  x98
180E:  MOVLW  85
1810:  MOVWF  x97
1812:  MOVLB  0
1814:  RCALL  13AA
1816:  MOVFF  03,260
181A:  MOVFF  02,25F
181E:  MOVFF  01,25E
1822:  MOVFF  00,25D
1826:  MOVFF  03,268
182A:  MOVFF  02,267
182E:  MOVFF  01,266
1832:  MOVFF  00,265
1836:  MOVLB  2
1838:  CLRF   x6C
183A:  CLRF   x6B
183C:  MOVLW  70
183E:  MOVWF  x6A
1840:  MOVLW  83
1842:  MOVWF  x69
1844:  MOVLB  0
1846:  RCALL  11E4
1848:  GOTO   2BDE (RETURN)
.................... }
.................... float get_y_vel(){
....................    return (float)((float)p1_pot_y - 127.0f)/30.0f;
184C:  MOVLB  2
184E:  CLRF   x94
1850:  MOVFF  20E,293
1854:  MOVLB  0
1856:  RCALL  11AE
1858:  MOVFF  03,260
185C:  MOVFF  02,25F
1860:  MOVFF  01,25E
1864:  MOVFF  00,25D
1868:  BSF    FD8.1
186A:  MOVFF  03,296
186E:  MOVFF  02,295
1872:  MOVFF  01,294
1876:  MOVFF  00,293
187A:  MOVLB  2
187C:  CLRF   x9A
187E:  CLRF   x99
1880:  MOVLW  7E
1882:  MOVWF  x98
1884:  MOVLW  85
1886:  MOVWF  x97
1888:  MOVLB  0
188A:  RCALL  13AA
188C:  MOVFF  03,260
1890:  MOVFF  02,25F
1894:  MOVFF  01,25E
1898:  MOVFF  00,25D
189C:  MOVFF  03,268
18A0:  MOVFF  02,267
18A4:  MOVFF  01,266
18A8:  MOVFF  00,265
18AC:  MOVLB  2
18AE:  CLRF   x6C
18B0:  CLRF   x6B
18B2:  MOVLW  70
18B4:  MOVWF  x6A
18B6:  MOVLW  83
18B8:  MOVWF  x69
18BA:  MOVLB  0
18BC:  RCALL  11E4
18BE:  GOTO   2BF2 (RETURN)
.................... }
.................... 
.................... float calc_ang_x(int x, int y){
....................    if(x < 60){
*
22AC:  MOVLB  2
22AE:  MOVF   x5D,W
22B0:  SUBLW  3B
22B2:  BNC   22F8
....................       if(y < 60){
22B4:  MOVF   x5E,W
22B6:  SUBLW  3B
22B8:  BNC   22CE
....................          return -5.6568f;
22BA:  MOVLW  81
22BC:  MOVWF  00
22BE:  MOVLW  B5
22C0:  MOVWF  01
22C2:  MOVLW  04
22C4:  MOVWF  02
22C6:  MOVLW  81
22C8:  MOVWF  03
22CA:  BRA    236E
....................       }
22CC:  BRA    22F6
....................       else if(y > 190){
22CE:  MOVF   x5E,W
22D0:  SUBLW  BE
22D2:  BC    22E8
....................          return -5.6568f;
22D4:  MOVLW  81
22D6:  MOVWF  00
22D8:  MOVLW  B5
22DA:  MOVWF  01
22DC:  MOVLW  04
22DE:  MOVWF  02
22E0:  MOVLW  81
22E2:  MOVWF  03
22E4:  BRA    236E
....................       }
22E6:  BRA    22F6
....................       else{
....................          return -8f;
22E8:  MOVLW  82
22EA:  MOVWF  00
22EC:  MOVLW  80
22EE:  MOVWF  01
22F0:  CLRF   02
22F2:  CLRF   03
22F4:  BRA    236E
....................       }
....................    }
22F6:  BRA    236E
....................    else if(x > 190){
22F8:  MOVF   x5D,W
22FA:  SUBLW  BE
22FC:  BC    2340
....................       if(y < 60){
22FE:  MOVF   x5E,W
2300:  SUBLW  3B
2302:  BNC   2318
....................          return 5.6568f;
2304:  MOVLW  81
2306:  MOVWF  00
2308:  MOVLW  35
230A:  MOVWF  01
230C:  MOVLW  04
230E:  MOVWF  02
2310:  MOVLW  81
2312:  MOVWF  03
2314:  BRA    236E
....................       }
2316:  BRA    233E
....................       else if(y > 190){
2318:  MOVF   x5E,W
231A:  SUBLW  BE
231C:  BC    2332
....................          return 5.6568f;
231E:  MOVLW  81
2320:  MOVWF  00
2322:  MOVLW  35
2324:  MOVWF  01
2326:  MOVLW  04
2328:  MOVWF  02
232A:  MOVLW  81
232C:  MOVWF  03
232E:  BRA    236E
....................       }
2330:  BRA    233E
....................       else{
....................          return 8f;
2332:  MOVLW  82
2334:  MOVWF  00
2336:  CLRF   01
2338:  CLRF   02
233A:  CLRF   03
233C:  BRA    236E
....................       }
....................    }
233E:  BRA    236E
....................    else{
....................       if(y < 60){
2340:  MOVF   x5E,W
2342:  SUBLW  3B
2344:  BNC   2352
....................          return 0;
2346:  CLRF   00
2348:  CLRF   01
234A:  CLRF   02
234C:  CLRF   03
234E:  BRA    236E
....................       }
2350:  BRA    236E
....................       else if(y > 190){
2352:  MOVF   x5E,W
2354:  SUBLW  BE
2356:  BC    2364
....................          return 0;
2358:  CLRF   00
235A:  CLRF   01
235C:  CLRF   02
235E:  CLRF   03
2360:  BRA    236E
....................       }
2362:  BRA    236E
....................       else{
....................          return 8f;
2364:  MOVLW  82
2366:  MOVWF  00
2368:  CLRF   01
236A:  CLRF   02
236C:  CLRF   03
....................       }
....................    }
236E:  MOVLB  0
2370:  GOTO   42B0 (RETURN)
.................... }
.................... 
.................... float calc_ang_y(int x, int y){
....................    if(x < 60){
2374:  MOVLB  2
2376:  MOVF   x5D,W
2378:  SUBLW  3B
237A:  BNC   23BC
....................       if(y < 60){
237C:  MOVF   x5E,W
237E:  SUBLW  3B
2380:  BNC   2396
....................          return -5.6568f;
2382:  MOVLW  81
2384:  MOVWF  00
2386:  MOVLW  B5
2388:  MOVWF  01
238A:  MOVLW  04
238C:  MOVWF  02
238E:  MOVLW  81
2390:  MOVWF  03
2392:  BRA    2434
....................       }
2394:  BRA    23BA
....................       else if(y > 190){
2396:  MOVF   x5E,W
2398:  SUBLW  BE
239A:  BC    23B0
....................          return 5.6568f;
239C:  MOVLW  81
239E:  MOVWF  00
23A0:  MOVLW  35
23A2:  MOVWF  01
23A4:  MOVLW  04
23A6:  MOVWF  02
23A8:  MOVLW  81
23AA:  MOVWF  03
23AC:  BRA    2434
....................       }
23AE:  BRA    23BA
....................       else{
....................          return 0;
23B0:  CLRF   00
23B2:  CLRF   01
23B4:  CLRF   02
23B6:  CLRF   03
23B8:  BRA    2434
....................       }
....................    }
23BA:  BRA    2434
....................    else if(x > 190){
23BC:  MOVF   x5D,W
23BE:  SUBLW  BE
23C0:  BC    2402
....................       if(y < 60){
23C2:  MOVF   x5E,W
23C4:  SUBLW  3B
23C6:  BNC   23DC
....................          return -5.6568f;
23C8:  MOVLW  81
23CA:  MOVWF  00
23CC:  MOVLW  B5
23CE:  MOVWF  01
23D0:  MOVLW  04
23D2:  MOVWF  02
23D4:  MOVLW  81
23D6:  MOVWF  03
23D8:  BRA    2434
....................       }
23DA:  BRA    2400
....................       else if(y > 190){
23DC:  MOVF   x5E,W
23DE:  SUBLW  BE
23E0:  BC    23F6
....................          return 5.6568f;
23E2:  MOVLW  81
23E4:  MOVWF  00
23E6:  MOVLW  35
23E8:  MOVWF  01
23EA:  MOVLW  04
23EC:  MOVWF  02
23EE:  MOVLW  81
23F0:  MOVWF  03
23F2:  BRA    2434
....................       }
23F4:  BRA    2400
....................       else{
....................          return 0;
23F6:  CLRF   00
23F8:  CLRF   01
23FA:  CLRF   02
23FC:  CLRF   03
23FE:  BRA    2434
....................       }
....................    }
2400:  BRA    2434
....................    else{
....................       if(y < 60){
2402:  MOVF   x5E,W
2404:  SUBLW  3B
2406:  BNC   2418
....................          return -8f;
2408:  MOVLW  82
240A:  MOVWF  00
240C:  MOVLW  80
240E:  MOVWF  01
2410:  CLRF   02
2412:  CLRF   03
2414:  BRA    2434
....................       }
2416:  BRA    2434
....................       else if(y > 190){
2418:  MOVF   x5E,W
241A:  SUBLW  BE
241C:  BC    242C
....................          return 8f;
241E:  MOVLW  82
2420:  MOVWF  00
2422:  CLRF   01
2424:  CLRF   02
2426:  CLRF   03
2428:  BRA    2434
....................       }
242A:  BRA    2434
....................       else{
....................          return 0;
242C:  CLRF   00
242E:  CLRF   01
2430:  CLRF   02
2432:  CLRF   03
....................       }
....................    }
2434:  MOVLB  0
2436:  GOTO   42CC (RETURN)
.................... }
.................... 
.................... void draw_cuadrito(int x,int y,int1 col){
....................    glcd_line(x-2,y+2,x+2,y+2,col);
243A:  MOVLW  02
243C:  MOVLB  2
243E:  SUBWF  x5D,W
2440:  MOVWF  x60
2442:  MOVLW  02
2444:  ADDWF  x5E,W
2446:  MOVWF  x61
2448:  MOVLW  02
244A:  ADDWF  x5D,W
244C:  MOVWF  x62
244E:  MOVLW  02
2450:  ADDWF  x5E,W
2452:  MOVWF  x63
2454:  MOVFF  260,283
2458:  MOVFF  261,284
245C:  MOVFF  262,285
2460:  MOVWF  x86
2462:  MOVFF  25F,287
2466:  MOVLB  0
2468:  CALL   0A70
....................    glcd_line(x-2,y-2,x+2,y-2,col);
246C:  MOVLW  02
246E:  MOVLB  2
2470:  SUBWF  x5D,W
2472:  MOVWF  x60
2474:  MOVLW  02
2476:  SUBWF  x5E,W
2478:  MOVWF  x61
247A:  MOVLW  02
247C:  ADDWF  x5D,W
247E:  MOVWF  x62
2480:  MOVLW  02
2482:  SUBWF  x5E,W
2484:  MOVWF  x63
2486:  MOVFF  260,283
248A:  MOVFF  261,284
248E:  MOVFF  262,285
2492:  MOVWF  x86
2494:  MOVFF  25F,287
2498:  MOVLB  0
249A:  CALL   0A70
....................    glcd_line(x-2,y+2,x-2,y-2,col);
249E:  MOVLW  02
24A0:  MOVLB  2
24A2:  SUBWF  x5D,W
24A4:  MOVWF  x60
24A6:  MOVLW  02
24A8:  ADDWF  x5E,W
24AA:  MOVWF  x61
24AC:  MOVLW  02
24AE:  SUBWF  x5D,W
24B0:  MOVWF  x62
24B2:  MOVLW  02
24B4:  SUBWF  x5E,W
24B6:  MOVWF  x63
24B8:  MOVFF  260,283
24BC:  MOVFF  261,284
24C0:  MOVFF  262,285
24C4:  MOVWF  x86
24C6:  MOVFF  25F,287
24CA:  MOVLB  0
24CC:  CALL   0A70
....................    glcd_line(x+2,y+2,x+2,y-2,col);
24D0:  MOVLW  02
24D2:  MOVLB  2
24D4:  ADDWF  x5D,W
24D6:  MOVWF  x60
24D8:  MOVLW  02
24DA:  ADDWF  x5E,W
24DC:  MOVWF  x61
24DE:  MOVLW  02
24E0:  ADDWF  x5D,W
24E2:  MOVWF  x62
24E4:  MOVLW  02
24E6:  SUBWF  x5E,W
24E8:  MOVWF  x63
24EA:  MOVFF  260,283
24EE:  MOVFF  261,284
24F2:  MOVFF  262,285
24F6:  MOVWF  x86
24F8:  MOVFF  25F,287
24FC:  MOVLB  0
24FE:  CALL   0A70
.................... 
....................    glcd_line(x-4,y+4,x+4,y+4,col);
2502:  MOVLW  04
2504:  MOVLB  2
2506:  SUBWF  x5D,W
2508:  MOVWF  x60
250A:  MOVLW  04
250C:  ADDWF  x5E,W
250E:  MOVWF  x61
2510:  MOVLW  04
2512:  ADDWF  x5D,W
2514:  MOVWF  x62
2516:  MOVLW  04
2518:  ADDWF  x5E,W
251A:  MOVWF  x63
251C:  MOVFF  260,283
2520:  MOVFF  261,284
2524:  MOVFF  262,285
2528:  MOVWF  x86
252A:  MOVFF  25F,287
252E:  MOVLB  0
2530:  CALL   0A70
....................    glcd_line(x-4,y-4,x+4,y-4,col);
2534:  MOVLW  04
2536:  MOVLB  2
2538:  SUBWF  x5D,W
253A:  MOVWF  x60
253C:  MOVLW  04
253E:  SUBWF  x5E,W
2540:  MOVWF  x61
2542:  MOVLW  04
2544:  ADDWF  x5D,W
2546:  MOVWF  x62
2548:  MOVLW  04
254A:  SUBWF  x5E,W
254C:  MOVWF  x63
254E:  MOVFF  260,283
2552:  MOVFF  261,284
2556:  MOVFF  262,285
255A:  MOVWF  x86
255C:  MOVFF  25F,287
2560:  MOVLB  0
2562:  CALL   0A70
....................    glcd_line(x-4,y+4,x-4,y-4,col);
2566:  MOVLW  04
2568:  MOVLB  2
256A:  SUBWF  x5D,W
256C:  MOVWF  x60
256E:  MOVLW  04
2570:  ADDWF  x5E,W
2572:  MOVWF  x61
2574:  MOVLW  04
2576:  SUBWF  x5D,W
2578:  MOVWF  x62
257A:  MOVLW  04
257C:  SUBWF  x5E,W
257E:  MOVWF  x63
2580:  MOVFF  260,283
2584:  MOVFF  261,284
2588:  MOVFF  262,285
258C:  MOVWF  x86
258E:  MOVFF  25F,287
2592:  MOVLB  0
2594:  CALL   0A70
....................    glcd_line(x+4,y+4,x+4,y-4,col);
2598:  MOVLW  04
259A:  MOVLB  2
259C:  ADDWF  x5D,W
259E:  MOVWF  x60
25A0:  MOVLW  04
25A2:  ADDWF  x5E,W
25A4:  MOVWF  x61
25A6:  MOVLW  04
25A8:  ADDWF  x5D,W
25AA:  MOVWF  x62
25AC:  MOVLW  04
25AE:  SUBWF  x5E,W
25B0:  MOVWF  x63
25B2:  MOVFF  260,283
25B6:  MOVFF  261,284
25BA:  MOVFF  262,285
25BE:  MOVWF  x86
25C0:  MOVFF  25F,287
25C4:  MOVLB  0
25C6:  CALL   0A70
25CA:  RETURN 0
.................... }

Configuration Fuses:
   Word  1: CC04   PLL5 CPUDIV1 NOUSBDIV HS FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 0700   CCP2C1 PBADEN LPT1OSC NOMCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
