CCS PCH C Compiler, Version 5.112, 5967               22-nov.-24 12:12

               Filename:   C:\Users\Kevin\Desktop\UAQ Auto\Tareas y Trabajos\S4_Microsistemas\videoujuego online\displaymain.lst

               ROM used:   17518 bytes (53%)
                           Largest free fragment is 15246
               RAM used:   599 (29%) at main() level
                           661 (32%) worst case
               Stack used: 5 locations (4 in main + 1 for interrupts)
               Stack size: 31

*
0000:  GOTO   2578
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.5
0056:  GOTO   0060
005A:  BTFSC  F9E.5
005C:  GOTO   0510
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVFF  15,FF5
009A:  MOVFF  16,FF6
009E:  MOVFF  17,FF7
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... #include <18F4550.h>
.................... //////////// Standard Header file for the PIC18F4550 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F4550
00AE:  CLRF   FF7
00B0:  ADDLW  BE
00B2:  MOVWF  FF6
00B4:  MOVLW  00
00B6:  ADDWFC FF7,F
00B8:  TBLRD*+
00BA:  MOVF   FF5,W
00BC:  RETURN 0
00BE:  DATA 00,00
00C0:  DATA 00,00
00C2:  DATA 00,00
00C4:  DATA 00,5F
00C6:  DATA 00,00
00C8:  DATA 00,03
00CA:  DATA 00,03
00CC:  DATA 00,14
00CE:  DATA 3E,14
00D0:  DATA 3E,14
00D2:  DATA 24,2A
00D4:  DATA 7F,2A
00D6:  DATA 12,43
00D8:  DATA 33,08
00DA:  DATA 66,61
00DC:  DATA 36,49
00DE:  DATA 55,22
00E0:  DATA 50,00
00E2:  DATA 05,03
00E4:  DATA 00,00
00E6:  DATA 00,1C
00E8:  DATA 22,41
00EA:  DATA 00,00
00EC:  DATA 41,22
00EE:  DATA 1C,00
00F0:  DATA 14,08
00F2:  DATA 3E,08
00F4:  DATA 14,08
00F6:  DATA 08,3E
00F8:  DATA 08,08
00FA:  DATA 00,50
00FC:  DATA 30,00
00FE:  DATA 00,08
0100:  DATA 08,08
0102:  DATA 08,08
0104:  DATA 00,60
0106:  DATA 60,00
0108:  DATA 00,20
010A:  DATA 10,08
010C:  DATA 04,02
010E:  DATA 3E,51
0110:  DATA 49,45
0112:  DATA 3E,04
0114:  DATA 02,7F
0116:  DATA 00,00
0118:  DATA 42,61
011A:  DATA 51,49
011C:  DATA 46,22
011E:  DATA 41,49
0120:  DATA 49,36
0122:  DATA 18,14
0124:  DATA 12,7F
0126:  DATA 10,27
0128:  DATA 45,45
012A:  DATA 45,39
012C:  DATA 3E,49
012E:  DATA 49,49
0130:  DATA 32,01
0132:  DATA 01,71
0134:  DATA 09,07
0136:  DATA 36,49
0138:  DATA 49,49
013A:  DATA 36,26
013C:  DATA 49,49
013E:  DATA 49,3E
0140:  DATA 00,36
0142:  DATA 36,00
0144:  DATA 00,00
0146:  DATA 56,36
0148:  DATA 00,00
014A:  DATA 08,14
014C:  DATA 22,41
014E:  DATA 00,14
0150:  DATA 14,14
0152:  DATA 14,14
0154:  DATA 00,41
0156:  DATA 22,14
0158:  DATA 08,02
015A:  DATA 01,51
015C:  DATA 09,06
015E:  DATA 3E,41
0160:  DATA 59,55
0162:  DATA 5E,7E
0164:  DATA 09,09
0166:  DATA 09,7E
0168:  DATA 7F,49
016A:  DATA 49,49
016C:  DATA 36,3E
016E:  DATA 41,41
0170:  DATA 41,22
0172:  DATA 7F,41
0174:  DATA 41,41
0176:  DATA 3E,7F
0178:  DATA 49,49
017A:  DATA 49,41
017C:  DATA 7F,09
017E:  DATA 09,09
0180:  DATA 01,3E
0182:  DATA 41,41
0184:  DATA 49,3A
0186:  DATA 7F,08
0188:  DATA 08,08
018A:  DATA 7F,00
018C:  DATA 41,7F
018E:  DATA 41,00
0190:  DATA 30,40
0192:  DATA 40,40
0194:  DATA 3F,7F
0196:  DATA 08,14
0198:  DATA 22,41
019A:  DATA 7F,40
019C:  DATA 40,40
019E:  DATA 40,7F
01A0:  DATA 02,0C
01A2:  DATA 02,7F
01A4:  DATA 7F,02
01A6:  DATA 04,08
01A8:  DATA 7F,3E
01AA:  DATA 41,41
01AC:  DATA 41,3E
01AE:  DATA 7F,09
01B0:  DATA 09,09
01B2:  DATA 06,1E
01B4:  DATA 21,21
01B6:  DATA 21,5E
01B8:  DATA 7F,09
01BA:  DATA 09,09
01BC:  DATA 76,00
01BE:  CLRF   FF7
01C0:  ADDLW  CE
01C2:  MOVWF  FF6
01C4:  MOVLW  01
01C6:  ADDWFC FF7,F
01C8:  TBLRD*+
01CA:  MOVF   FF5,W
01CC:  RETURN 0
01CE:  DATA 26,49
01D0:  DATA 49,49
01D2:  DATA 32,01
01D4:  DATA 01,7F
01D6:  DATA 01,01
01D8:  DATA 3F,40
01DA:  DATA 40,40
01DC:  DATA 3F,1F
01DE:  DATA 20,40
01E0:  DATA 20,1F
01E2:  DATA 7F,20
01E4:  DATA 10,20
01E6:  DATA 7F,41
01E8:  DATA 22,1C
01EA:  DATA 22,41
01EC:  DATA 07,08
01EE:  DATA 70,08
01F0:  DATA 07,61
01F2:  DATA 51,49
01F4:  DATA 45,43
01F6:  DATA 00,7F
01F8:  DATA 41,00
01FA:  DATA 00,02
01FC:  DATA 04,08
01FE:  DATA 10,20
0200:  DATA 00,00
0202:  DATA 41,7F
0204:  DATA 00,04
0206:  DATA 02,01
0208:  DATA 02,04
020A:  DATA 40,40
020C:  DATA 40,40
020E:  DATA 40,00
0210:  DATA 01,02
0212:  DATA 04,00
0214:  DATA 20,54
0216:  DATA 54,54
0218:  DATA 78,7F
021A:  DATA 44,44
021C:  DATA 44,38
021E:  DATA 38,44
0220:  DATA 44,44
0222:  DATA 44,38
0224:  DATA 44,44
0226:  DATA 44,7F
0228:  DATA 38,54
022A:  DATA 54,54
022C:  DATA 18,04
022E:  DATA 04,7E
0230:  DATA 05,05
0232:  DATA 08,54
0234:  DATA 54,54
0236:  DATA 3C,7F
0238:  DATA 08,04
023A:  DATA 04,78
023C:  DATA 00,44
023E:  DATA 7D,40
0240:  DATA 00,20
0242:  DATA 40,44
0244:  DATA 3D,00
0246:  DATA 7F,10
0248:  DATA 28,44
024A:  DATA 00,00
024C:  DATA 41,7F
024E:  DATA 40,00
0250:  DATA 7C,04
0252:  DATA 78,04
0254:  DATA 78,7C
0256:  DATA 08,04
0258:  DATA 04,78
025A:  DATA 38,44
025C:  DATA 44,44
025E:  DATA 38,7C
0260:  DATA 14,14
0262:  DATA 14,08
0264:  DATA 08,14
0266:  DATA 14,14
0268:  DATA 7C,00
026A:  DATA 7C,08
026C:  DATA 04,04
026E:  DATA 48,54
0270:  DATA 54,54
0272:  DATA 20,04
0274:  DATA 04,3F
0276:  DATA 44,44
0278:  DATA 3C,40
027A:  DATA 40,20
027C:  DATA 7C,1C
027E:  DATA 20,40
0280:  DATA 20,1C
0282:  DATA 3C,40
0284:  DATA 30,40
0286:  DATA 3C,44
0288:  DATA 28,10
028A:  DATA 28,44
028C:  DATA 0C,50
028E:  DATA 50,50
0290:  DATA 3C,44
0292:  DATA 64,54
0294:  DATA 4C,44
0296:  DATA 00,08
0298:  DATA 36,41
029A:  DATA 41,00
029C:  DATA 00,7F
029E:  DATA 00,00
02A0:  DATA 41,41
02A2:  DATA 36,08
02A4:  DATA 00,02
02A6:  DATA 01,02
02A8:  DATA 04,02
02AA:  ADDLW  B8
02AC:  MOVWF  FF6
02AE:  MOVLW  02
02B0:  ADDWFC FF7,F
02B2:  TBLRD*+
02B4:  MOVF   FF5,W
02B6:  RETURN 0
02B8:  DATA 00,00
02BA:  DATA 00,00
02BC:  DATA 00,00
02BE:  DATA 01,00
02C0:  DATA 00,00
02C2:  DATA 00,00
02C4:  DATA 00,00
02C6:  DATA 00,00
02C8:  DATA 00,00
02CA:  DATA 00,00
02CC:  DATA 00,00
02CE:  DATA 00,00
02D0:  DATA 01,00
02D2:  DATA 00,00
02D4:  DATA 00,00
02D6:  DATA 00,00
02D8:  DATA 00,01
02DA:  DATA 00,00
02DC:  DATA 00,00
02DE:  DATA 00,00
02E0:  DATA 00,00
02E2:  DATA 00,00
02E4:  DATA 00,00
02E6:  DATA 00,00
02E8:  DATA 02,00
02EA:  DATA 00,00
02EC:  DATA 00,00
02EE:  DATA 00,00
02F0:  DATA 00,00
02F2:  DATA 00,00
02F4:  DATA 00,00
02F6:  DATA 00,02
02F8:  DATA 00,00
02FA:  DATA 00,00
02FC:  DATA 00,00
02FE:  DATA 00,00
0300:  DATA 00,00
0302:  DATA 00,00
0304:  DATA 02,00
0306:  DATA 00,00
0308:  DATA 00,00
030A:  DATA 00,00
030C:  DATA 00,00
030E:  DATA 00,00
0310:  DATA 00,00
0312:  DATA 00,00
0314:  DATA 00,00
0316:  DATA 00,00
0318:  DATA 00,00
031A:  DATA 00,03
031C:  DATA 03,00
031E:  DATA 00,00
0320:  DATA 00,03
0322:  DATA 00,00
0324:  DATA 00,00
0326:  DATA 00,00
0328:  DATA 00,00
032A:  DATA 00,00
032C:  DATA 00,00
032E:  DATA 00,00
0330:  DATA 00,02
0332:  DATA 03,01
0334:  DATA 00,00
0336:  DATA 00,00
0338:  DATA 00,00
033A:  DATA 00,00
033C:  DATA 00,00
033E:  DATA 00,00
0340:  DATA 00,00
0342:  DATA 00,00
0344:  DATA 00,00
0346:  DATA 00,02
0348:  DATA 00,00
034A:  DATA 01,00
034C:  DATA 01,00
034E:  DATA 00,00
0350:  DATA 00,00
0352:  DATA 00,01
0354:  DATA 00,01
0356:  DATA 00,00
0358:  DATA 00,00
035A:  DATA 00,00
035C:  DATA 00,00
035E:  DATA 00,03
0360:  DATA 00,00
0362:  DATA 03,00
0364:  DATA 03,00
0366:  DATA 00,00
0368:  DATA 00,00
036A:  DATA 00,00
036C:  DATA 00,00
036E:  DATA 00,00
0370:  DATA 00,00
0372:  DATA 00,00
0374:  DATA 00,00
0376:  DATA 00,00
0378:  DATA 00,00
037A:  DATA 00,00
037C:  DATA 00,00
037E:  DATA 00,00
0380:  DATA 00,00
0382:  DATA 00,00
0384:  DATA 00,00
0386:  DATA 00,00
0388:  DATA 00,00
038A:  DATA 00,00
038C:  DATA 00,00
038E:  DATA 00,00
0390:  DATA 00,00
0392:  DATA 00,00
0394:  DATA 00,00
0396:  DATA 00,00
0398:  DATA 00,00
039A:  DATA 00,00
039C:  DATA 00,00
039E:  DATA 00,00
03A0:  DATA 00,00
03A2:  DATA 00,00
03A4:  DATA 00,00
03A6:  DATA 00,00
03A8:  DATA 00,00
03AA:  DATA 00,00
03AC:  DATA 00,00
03AE:  DATA 00,00
03B0:  DATA 00,00
03B2:  DATA 00,00
03B4:  DATA 00,00
03B6:  DATA 00,00
03B8:  DATA 00,00
03BA:  DATA 00,00
03BC:  DATA 00,00
03BE:  DATA 00,00
03C0:  DATA 00,00
03C2:  DATA 00,00
03C4:  DATA 00,00
03C6:  DATA 00,00
03C8:  DATA 00,00
03CA:  DATA 00,00
03CC:  DATA 00,00
03CE:  DATA 00,00
03D0:  DATA 00,00
03D2:  DATA 00,00
03D4:  DATA 00,00
03D6:  DATA 00,00
03D8:  DATA 00,00
03DA:  DATA 00,00
03DC:  DATA 00,00
03DE:  DATA 00,00
03E0:  DATA 00,00
03E2:  DATA 00,00
03E4:  DATA 00,00
03E6:  DATA 00,00
03E8:  DATA 00,00
03EA:  DATA 00,00
03EC:  DATA 00,00
03EE:  DATA 00,00
03F0:  DATA 00,00
03F2:  DATA 00,00
03F4:  DATA 00,00
03F6:  DATA 00,00
03F8:  DATA 00,00
03FA:  DATA 00,00
03FC:  DATA 00,00
03FE:  DATA 00,00
0400:  DATA 00,00
0402:  DATA 00,00
0404:  DATA 00,00
0406:  DATA 00,00
0408:  DATA 00,00
040A:  DATA 00,00
040C:  DATA 00,00
040E:  DATA 00,00
0410:  DATA 00,00
0412:  DATA 00,00
0414:  DATA 00,00
0416:  DATA 00,00
0418:  DATA 00,00
041A:  DATA 00,00
041C:  DATA 00,00
041E:  DATA 00,00
0420:  DATA 00,00
0422:  DATA 00,00
0424:  DATA 00,00
0426:  DATA 00,00
0428:  DATA 00,00
042A:  DATA 00,00
042C:  DATA 00,00
042E:  DATA 00,00
0430:  DATA 00,00
0432:  DATA 00,00
0434:  DATA 00,00
0436:  DATA 00,00
0438:  DATA 00,00
043A:  DATA 00,00
043C:  DATA 00,00
043E:  DATA 00,00
0440:  DATA 00,00
0442:  DATA 00,00
0444:  DATA 00,00
0446:  DATA 00,00
0448:  DATA 00,00
044A:  DATA 00,00
044C:  DATA 00,00
044E:  DATA 00,00
0450:  DATA 00,00
0452:  DATA 00,00
0454:  DATA 00,00
0456:  DATA 00,00
0458:  DATA 00,00
045A:  DATA 00,00
045C:  DATA 00,00
045E:  DATA 00,00
0460:  DATA 00,00
0462:  DATA 00,00
0464:  DATA 00,00
0466:  DATA 00,00
0468:  DATA 00,00
046A:  DATA 00,00
046C:  DATA 00,00
046E:  DATA 00,00
0470:  DATA 00,00
0472:  DATA 00,00
0474:  DATA 00,00
0476:  DATA 00,00
0478:  DATA 00,00
047A:  DATA 00,00
047C:  DATA 00,00
047E:  DATA 00,00
0480:  DATA 00,00
0482:  DATA 00,00
0484:  DATA 00,00
0486:  DATA 00,00
0488:  DATA 00,00
048A:  DATA 00,00
048C:  DATA 00,00
048E:  DATA 00,00
0490:  DATA 00,00
0492:  DATA 00,00
0494:  DATA 00,00
0496:  DATA 00,00
0498:  DATA 00,00
049A:  DATA 00,00
049C:  DATA 00,00
049E:  DATA 00,00
04A0:  DATA 00,00
04A2:  DATA 00,00
04A4:  DATA 00,00
04A6:  DATA 00,00
04A8:  DATA 00,00
04AA:  DATA 00,00
04AC:  DATA 00,00
04AE:  DATA 00,00
04B0:  DATA 00,00
04B2:  DATA 00,00
04B4:  DATA 00,00
04B6:  DATA 00,00
04B8:  DATA 00,00
04BA:  DATA 00,00
04BC:  DATA 00,00
04BE:  DATA 00,00
04C0:  DATA 00,00
04C2:  DATA 00,00
04C4:  DATA 00,00
04C6:  DATA 00,00
04C8:  DATA 00,00
04CA:  DATA 00,00
04CC:  DATA 00,00
04CE:  DATA 00,00
04D0:  DATA 00,00
04D2:  DATA 00,00
04D4:  DATA 00,00
04D6:  DATA 00,00
04D8:  DATA 00,00
04DA:  DATA 00,00
04DC:  DATA 00,00
04DE:  DATA 00,00
04E0:  DATA 00,00
04E2:  DATA 00,00
04E4:  DATA 00,00
04E6:  DATA 00,00
04E8:  DATA 00,00
04EA:  DATA 00,00
04EC:  DATA 00,00
04EE:  DATA 00,00
04F0:  DATA 00,00
04F2:  DATA 00,00
04F4:  DATA 00,00
04F6:  DATA 00,00
04F8:  DATA 00,00
04FA:  DATA 00,00
04FC:  DATA 00,00
04FE:  DATA 00,00
0500:  DATA 00,00
0502:  DATA 00,00
0504:  DATA 00,00
0506:  DATA 00,00
0508:  DATA 00,00
050A:  DATA 00,00
050C:  DATA 00,00
050E:  DATA 00,00
*
05C0:  ADDWF  FE8,W
05C2:  CLRF   FF7
05C4:  RLCF   FF7,F
05C6:  ADDLW  DB
05C8:  MOVWF  FF6
05CA:  MOVLW  05
05CC:  ADDWFC FF7,F
05CE:  TBLRD*-
05D0:  MOVF   FF5,W
05D2:  MOVWF  FFA
05D4:  TBLRD*
05D6:  MOVF   FF5,W
05D8:  MOVWF  FF9
05DA:  DATA 28,05
05DC:  DATA 30,05
05DE:  DATA 38,05
05E0:  DATA 40,05
05E2:  DATA 48,05
05E4:  DATA 50,05
05E6:  DATA 58,05
05E8:  DATA 60,05
05EA:  DATA 68,05
*
0A22:  CLRF   00
0A24:  CLRF   01
0A26:  MOVLB  2
0A28:  MOVF   x84,W
0A2A:  BCF    FD8.0
0A2C:  BTFSC  x85.0
0A2E:  ADDWF  00,F
0A30:  RRCF   00,F
0A32:  RRCF   01,F
0A34:  BTFSC  x85.1
0A36:  ADDWF  00,F
0A38:  RRCF   00,F
0A3A:  RRCF   01,F
0A3C:  BTFSC  x85.2
0A3E:  ADDWF  00,F
0A40:  RRCF   00,F
0A42:  RRCF   01,F
0A44:  BTFSC  x85.3
0A46:  ADDWF  00,F
0A48:  RRCF   00,F
0A4A:  RRCF   01,F
0A4C:  BTFSC  x85.4
0A4E:  ADDWF  00,F
0A50:  RRCF   00,F
0A52:  RRCF   01,F
0A54:  BTFSC  x85.5
0A56:  ADDWF  00,F
0A58:  RRCF   00,F
0A5A:  RRCF   01,F
0A5C:  BTFSC  x85.6
0A5E:  ADDWF  00,F
0A60:  RRCF   00,F
0A62:  RRCF   01,F
0A64:  BTFSC  x85.7
0A66:  ADDWF  00,F
0A68:  RRCF   00,F
0A6A:  RRCF   01,F
0A6C:  MOVLB  0
0A6E:  RETURN 0
*
110C:  MOVLB  2
110E:  MOVF   x51,W
1110:  MULWF  x53
1112:  MOVFF  FF3,01
1116:  MOVFF  FF4,00
111A:  MULWF  x54
111C:  MOVF   FF3,W
111E:  ADDWF  00,F
1120:  MOVF   x52,W
1122:  MULWF  x53
1124:  MOVF   FF3,W
1126:  ADDWFC 00,W
1128:  MOVWF  02
112A:  MOVLB  0
112C:  GOTO   298E (RETURN)
*
11AE:  MOVLW  8E
11B0:  MOVWF  00
11B2:  MOVFF  286,01
11B6:  MOVFF  285,02
11BA:  CLRF   03
11BC:  MOVF   01,F
11BE:  BNZ   11D2
11C0:  MOVFF  02,01
11C4:  CLRF   02
11C6:  MOVLW  08
11C8:  SUBWF  00,F
11CA:  MOVF   01,F
11CC:  BNZ   11D2
11CE:  CLRF   00
11D0:  BRA    11E2
11D2:  BCF    FD8.0
11D4:  BTFSC  01.7
11D6:  BRA    11E0
11D8:  RLCF   02,F
11DA:  RLCF   01,F
11DC:  DECF   00,F
11DE:  BRA    11D2
11E0:  BCF    01.7
11E2:  RETURN 0
11E4:  MOVLB  2
11E6:  MOVF   x57,W
11E8:  BTFSC  FD8.2
11EA:  BRA    1336
11EC:  MOVWF  x63
11EE:  MOVF   x5B,W
11F0:  BTFSC  FD8.2
11F2:  BRA    1336
11F4:  SUBWF  x63,F
11F6:  BNC   1202
11F8:  MOVLW  7F
11FA:  ADDWF  x63,F
11FC:  BTFSC  FD8.0
11FE:  BRA    1336
1200:  BRA    120E
1202:  MOVLW  81
1204:  SUBWF  x63,F
1206:  BTFSS  FD8.0
1208:  BRA    1336
120A:  BTFSC  FD8.2
120C:  BRA    1336
120E:  MOVFF  263,00
1212:  CLRF   01
1214:  CLRF   02
1216:  CLRF   03
1218:  CLRF   x62
121A:  MOVFF  258,261
121E:  BSF    x61.7
1220:  MOVFF  259,260
1224:  MOVFF  25A,25F
1228:  MOVLW  19
122A:  MOVWF  x63
122C:  MOVF   x5E,W
122E:  SUBWF  x5F,F
1230:  BC    124C
1232:  MOVLW  01
1234:  SUBWF  x60,F
1236:  BC    124C
1238:  SUBWF  x61,F
123A:  BC    124C
123C:  SUBWF  x62,F
123E:  BC    124C
1240:  INCF   x62,F
1242:  INCF   x61,F
1244:  INCF   x60,F
1246:  MOVF   x5E,W
1248:  ADDWF  x5F,F
124A:  BRA    129C
124C:  MOVF   x5D,W
124E:  SUBWF  x60,F
1250:  BC    1276
1252:  MOVLW  01
1254:  SUBWF  x61,F
1256:  BC    1276
1258:  SUBWF  x62,F
125A:  BC    1276
125C:  INCF   x62,F
125E:  INCF   x61,F
1260:  MOVF   x5D,W
1262:  ADDWF  x60,F
1264:  MOVF   x5E,W
1266:  ADDWF  x5F,F
1268:  BNC   129C
126A:  INCF   x60,F
126C:  BNZ   129C
126E:  INCF   x61,F
1270:  BNZ   129C
1272:  INCF   x62,F
1274:  BRA    129C
1276:  MOVF   x5C,W
1278:  IORLW  80
127A:  SUBWF  x61,F
127C:  BC    129A
127E:  MOVLW  01
1280:  SUBWF  x62,F
1282:  BC    129A
1284:  INCF   x62,F
1286:  MOVF   x5C,W
1288:  IORLW  80
128A:  ADDWF  x61,F
128C:  MOVF   x5D,W
128E:  ADDWF  x60,F
1290:  BNC   1264
1292:  INCF   x61,F
1294:  BNZ   1264
1296:  INCF   x62,F
1298:  BRA    1264
129A:  BSF    03.0
129C:  DECFSZ x63,F
129E:  BRA    12A2
12A0:  BRA    12B8
12A2:  BCF    FD8.0
12A4:  RLCF   x5F,F
12A6:  RLCF   x60,F
12A8:  RLCF   x61,F
12AA:  RLCF   x62,F
12AC:  BCF    FD8.0
12AE:  RLCF   03,F
12B0:  RLCF   02,F
12B2:  RLCF   01,F
12B4:  RLCF   x64,F
12B6:  BRA    122C
12B8:  BTFSS  x64.0
12BA:  BRA    12C8
12BC:  BCF    FD8.0
12BE:  RRCF   01,F
12C0:  RRCF   02,F
12C2:  RRCF   03,F
12C4:  RRCF   x64,F
12C6:  BRA    12CC
12C8:  DECF   00,F
12CA:  BZ    1336
12CC:  BTFSC  x64.7
12CE:  BRA    130C
12D0:  BCF    FD8.0
12D2:  RLCF   x5F,F
12D4:  RLCF   x60,F
12D6:  RLCF   x61,F
12D8:  RLCF   x62,F
12DA:  MOVF   x5E,W
12DC:  SUBWF  x5F,F
12DE:  BC    12EE
12E0:  MOVLW  01
12E2:  SUBWF  x60,F
12E4:  BC    12EE
12E6:  SUBWF  x61,F
12E8:  BC    12EE
12EA:  SUBWF  x62,F
12EC:  BNC   1322
12EE:  MOVF   x5D,W
12F0:  SUBWF  x60,F
12F2:  BC    12FE
12F4:  MOVLW  01
12F6:  SUBWF  x61,F
12F8:  BC    12FE
12FA:  SUBWF  x62,F
12FC:  BNC   1322
12FE:  MOVF   x5C,W
1300:  IORLW  80
1302:  SUBWF  x61,F
1304:  BC    130C
1306:  MOVLW  01
1308:  SUBWF  x62,F
130A:  BNC   1322
130C:  INCF   03,F
130E:  BNZ   1322
1310:  INCF   02,F
1312:  BNZ   1322
1314:  INCF   01,F
1316:  BNZ   1322
1318:  INCF   00,F
131A:  BZ    1336
131C:  RRCF   01,F
131E:  RRCF   02,F
1320:  RRCF   03,F
1322:  MOVFF  258,263
1326:  MOVF   x5C,W
1328:  XORWF  x63,F
132A:  BTFSS  x63.7
132C:  BRA    1332
132E:  BSF    01.7
1330:  BRA    133E
1332:  BCF    01.7
1334:  BRA    133E
1336:  CLRF   00
1338:  CLRF   01
133A:  CLRF   02
133C:  CLRF   03
133E:  MOVLB  0
1340:  RETURN 0
1342:  MOVLW  8E
1344:  MOVWF  00
1346:  MOVLB  2
1348:  MOVF   x81,W
134A:  SUBWF  00,F
134C:  MOVFF  282,02
1350:  MOVFF  283,01
1354:  BSF    02.7
1356:  MOVF   00,F
1358:  BZ    136C
135A:  BCF    FD8.0
135C:  MOVF   02,F
135E:  BNZ   1364
1360:  MOVF   01,F
1362:  BZ    136C
1364:  RRCF   02,F
1366:  RRCF   01,F
1368:  DECFSZ 00,F
136A:  BRA    135A
136C:  BTFSS  x82.7
136E:  BRA    137A
1370:  COMF   01,F
1372:  COMF   02,F
1374:  INCF   01,F
1376:  BTFSC  FD8.2
1378:  INCF   02,F
137A:  MOVLB  0
137C:  RETURN 0
137E:  MOVLB  2
1380:  MOVF   x60,W
1382:  CLRF   01
1384:  SUBWF  x5F,W
1386:  BC    138E
1388:  MOVFF  25F,00
138C:  BRA    13A6
138E:  CLRF   00
1390:  MOVLW  08
1392:  MOVWF  x61
1394:  RLCF   x5F,F
1396:  RLCF   00,F
1398:  MOVF   x60,W
139A:  SUBWF  00,W
139C:  BTFSC  FD8.0
139E:  MOVWF  00
13A0:  RLCF   01,F
13A2:  DECFSZ x61,F
13A4:  BRA    1394
13A6:  MOVLB  0
13A8:  RETURN 0
13AA:  MOVLW  80
13AC:  BTFSS  FD8.1
13AE:  BRA    13B4
13B0:  MOVLB  2
13B2:  XORWF  x8A,F
13B4:  MOVLB  2
13B6:  CLRF   x8F
13B8:  CLRF   x90
13BA:  MOVFF  286,28E
13BE:  MOVF   x8A,W
13C0:  XORWF  x8E,F
13C2:  MOVF   x85,W
13C4:  BTFSC  FD8.2
13C6:  BRA    1586
13C8:  MOVWF  x8D
13CA:  MOVWF  00
13CC:  MOVF   x89,W
13CE:  BTFSC  FD8.2
13D0:  BRA    1598
13D2:  SUBWF  x8D,F
13D4:  BTFSC  FD8.2
13D6:  BRA    14DE
13D8:  BNC   1456
13DA:  MOVFF  28A,293
13DE:  BSF    x93.7
13E0:  MOVFF  28B,292
13E4:  MOVFF  28C,291
13E8:  CLRF   x90
13EA:  BCF    FD8.0
13EC:  RRCF   x93,F
13EE:  RRCF   x92,F
13F0:  RRCF   x91,F
13F2:  RRCF   x90,F
13F4:  DECFSZ x8D,F
13F6:  BRA    13E8
13F8:  BTFSS  x8E.7
13FA:  BRA    1402
13FC:  BSF    x8F.0
13FE:  BRA    15C0
1400:  BCF    x8F.0
1402:  BCF    x8D.0
1404:  BSF    x8F.4
1406:  MOVLW  02
1408:  MOVWF  FEA
140A:  MOVLW  88
140C:  MOVWF  FE9
140E:  BRA    15E6
1410:  BCF    x8F.4
1412:  BTFSC  x8E.7
1414:  BRA    142A
1416:  BTFSS  x8D.0
1418:  BRA    1440
141A:  RRCF   x93,F
141C:  RRCF   x92,F
141E:  RRCF   x91,F
1420:  RRCF   x90,F
1422:  INCF   00,F
1424:  BTFSC  FD8.2
1426:  BRA    15B6
1428:  BRA    1440
142A:  BTFSC  x93.7
142C:  BRA    1446
142E:  BCF    FD8.0
1430:  RLCF   x90,F
1432:  RLCF   x91,F
1434:  RLCF   x92,F
1436:  RLCF   x93,F
1438:  DECF   00,F
143A:  BTFSC  FD8.2
143C:  BRA    15B6
143E:  BRA    142A
1440:  BSF    x8F.6
1442:  BRA    151E
1444:  BCF    x8F.6
1446:  MOVFF  286,28E
144A:  BTFSS  x86.7
144C:  BRA    1452
144E:  BSF    x93.7
1450:  BRA    15A8
1452:  BCF    x93.7
1454:  BRA    15A8
1456:  MOVFF  289,28D
145A:  MOVFF  289,00
145E:  MOVF   x85,W
1460:  SUBWF  x8D,F
1462:  MOVFF  286,293
1466:  BSF    x93.7
1468:  MOVFF  287,292
146C:  MOVFF  288,291
1470:  CLRF   x90
1472:  BCF    FD8.0
1474:  RRCF   x93,F
1476:  RRCF   x92,F
1478:  RRCF   x91,F
147A:  RRCF   x90,F
147C:  DECFSZ x8D,F
147E:  BRA    1470
1480:  BTFSS  x8E.7
1482:  BRA    148A
1484:  BSF    x8F.1
1486:  BRA    15C0
1488:  BCF    x8F.1
148A:  BCF    x8D.0
148C:  BSF    x8F.5
148E:  MOVLW  02
1490:  MOVWF  FEA
1492:  MOVLW  8C
1494:  MOVWF  FE9
1496:  BRA    15E6
1498:  BCF    x8F.5
149A:  BTFSC  x8E.7
149C:  BRA    14B2
149E:  BTFSS  x8D.0
14A0:  BRA    14C8
14A2:  RRCF   x93,F
14A4:  RRCF   x92,F
14A6:  RRCF   x91,F
14A8:  RRCF   x90,F
14AA:  INCF   00,F
14AC:  BTFSC  FD8.2
14AE:  BRA    15B6
14B0:  BRA    14C8
14B2:  BTFSC  x93.7
14B4:  BRA    14CE
14B6:  BCF    FD8.0
14B8:  RLCF   x90,F
14BA:  RLCF   x91,F
14BC:  RLCF   x92,F
14BE:  RLCF   x93,F
14C0:  DECF   00,F
14C2:  BTFSC  FD8.2
14C4:  BRA    15B6
14C6:  BRA    14B2
14C8:  BSF    x8F.7
14CA:  BRA    151E
14CC:  BCF    x8F.7
14CE:  MOVFF  28A,28E
14D2:  BTFSS  x8A.7
14D4:  BRA    14DA
14D6:  BSF    x93.7
14D8:  BRA    15A8
14DA:  BCF    x93.7
14DC:  BRA    15A8
14DE:  MOVFF  28A,293
14E2:  BSF    x93.7
14E4:  MOVFF  28B,292
14E8:  MOVFF  28C,291
14EC:  BTFSS  x8E.7
14EE:  BRA    14F8
14F0:  BCF    x93.7
14F2:  BSF    x8F.2
14F4:  BRA    15C0
14F6:  BCF    x8F.2
14F8:  CLRF   x90
14FA:  BCF    x8D.0
14FC:  MOVLW  02
14FE:  MOVWF  FEA
1500:  MOVLW  88
1502:  MOVWF  FE9
1504:  BRA    15E6
1506:  BTFSC  x8E.7
1508:  BRA    1542
150A:  MOVFF  286,28E
150E:  BTFSS  x8D.0
1510:  BRA    151E
1512:  RRCF   x93,F
1514:  RRCF   x92,F
1516:  RRCF   x91,F
1518:  RRCF   x90,F
151A:  INCF   00,F
151C:  BZ    15B6
151E:  BTFSS  x90.7
1520:  BRA    1538
1522:  INCF   x91,F
1524:  BNZ   1538
1526:  INCF   x92,F
1528:  BNZ   1538
152A:  INCF   x93,F
152C:  BNZ   1538
152E:  RRCF   x93,F
1530:  RRCF   x92,F
1532:  RRCF   x91,F
1534:  INCF   00,F
1536:  BZ    15B6
1538:  BTFSC  x8F.6
153A:  BRA    1444
153C:  BTFSC  x8F.7
153E:  BRA    14CC
1540:  BRA    157A
1542:  MOVLW  80
1544:  XORWF  x93,F
1546:  BTFSS  x93.7
1548:  BRA    1552
154A:  BRA    15C0
154C:  MOVFF  28A,28E
1550:  BRA    1566
1552:  MOVFF  286,28E
1556:  MOVF   x93,F
1558:  BNZ   1566
155A:  MOVF   x92,F
155C:  BNZ   1566
155E:  MOVF   x91,F
1560:  BNZ   1566
1562:  CLRF   00
1564:  BRA    15A8
1566:  BTFSC  x93.7
1568:  BRA    157A
156A:  BCF    FD8.0
156C:  RLCF   x90,F
156E:  RLCF   x91,F
1570:  RLCF   x92,F
1572:  RLCF   x93,F
1574:  DECFSZ 00,F
1576:  BRA    1566
1578:  BRA    15B6
157A:  BTFSS  x8E.7
157C:  BRA    1582
157E:  BSF    x93.7
1580:  BRA    15A8
1582:  BCF    x93.7
1584:  BRA    15A8
1586:  MOVFF  289,00
158A:  MOVFF  28A,293
158E:  MOVFF  28B,292
1592:  MOVFF  28C,291
1596:  BRA    15A8
1598:  MOVFF  285,00
159C:  MOVFF  286,293
15A0:  MOVFF  287,292
15A4:  MOVFF  288,291
15A8:  MOVFF  293,01
15AC:  MOVFF  292,02
15B0:  MOVFF  291,03
15B4:  BRA    161E
15B6:  CLRF   00
15B8:  CLRF   01
15BA:  CLRF   02
15BC:  CLRF   03
15BE:  BRA    161E
15C0:  CLRF   x90
15C2:  COMF   x91,F
15C4:  COMF   x92,F
15C6:  COMF   x93,F
15C8:  COMF   x90,F
15CA:  INCF   x90,F
15CC:  BNZ   15D8
15CE:  INCF   x91,F
15D0:  BNZ   15D8
15D2:  INCF   x92,F
15D4:  BNZ   15D8
15D6:  INCF   x93,F
15D8:  BTFSC  x8F.0
15DA:  BRA    1400
15DC:  BTFSC  x8F.1
15DE:  BRA    1488
15E0:  BTFSC  x8F.2
15E2:  BRA    14F6
15E4:  BRA    154C
15E6:  MOVF   FEF,W
15E8:  ADDWF  x91,F
15EA:  BNC   15F6
15EC:  INCF   x92,F
15EE:  BNZ   15F6
15F0:  INCF   x93,F
15F2:  BTFSC  FD8.2
15F4:  BSF    x8D.0
15F6:  MOVF   FED,F
15F8:  MOVF   FEF,W
15FA:  ADDWF  x92,F
15FC:  BNC   1604
15FE:  INCF   x93,F
1600:  BTFSC  FD8.2
1602:  BSF    x8D.0
1604:  MOVF   FED,F
1606:  MOVF   FEF,W
1608:  BTFSC  FEF.7
160A:  BRA    160E
160C:  XORLW  80
160E:  ADDWF  x93,F
1610:  BTFSC  FD8.0
1612:  BSF    x8D.0
1614:  BTFSC  x8F.4
1616:  BRA    1410
1618:  BTFSC  x8F.5
161A:  BRA    1498
161C:  BRA    1506
161E:  MOVLB  0
1620:  RETURN 0
*
16E0:  MOVLB  2
16E2:  MOVF   x85,W
16E4:  BTFSC  FD8.2
16E6:  BRA    17CA
16E8:  MOVWF  00
16EA:  MOVF   x89,W
16EC:  BTFSC  FD8.2
16EE:  BRA    17CA
16F0:  ADDWF  00,F
16F2:  BNC   16FC
16F4:  MOVLW  81
16F6:  ADDWF  00,F
16F8:  BC    17CA
16FA:  BRA    1704
16FC:  MOVLW  7F
16FE:  SUBWF  00,F
1700:  BNC   17CA
1702:  BZ    17CA
1704:  MOVFF  286,28D
1708:  MOVF   x8A,W
170A:  XORWF  x8D,F
170C:  BSF    x86.7
170E:  BSF    x8A.7
1710:  MOVF   x88,W
1712:  MULWF  x8C
1714:  MOVFF  FF4,28F
1718:  MOVF   x87,W
171A:  MULWF  x8B
171C:  MOVFF  FF4,03
1720:  MOVFF  FF3,28E
1724:  MULWF  x8C
1726:  MOVF   FF3,W
1728:  ADDWF  x8F,F
172A:  MOVF   FF4,W
172C:  ADDWFC x8E,F
172E:  MOVLW  00
1730:  ADDWFC 03,F
1732:  MOVF   x88,W
1734:  MULWF  x8B
1736:  MOVF   FF3,W
1738:  ADDWF  x8F,F
173A:  MOVF   FF4,W
173C:  ADDWFC x8E,F
173E:  MOVLW  00
1740:  CLRF   02
1742:  ADDWFC 03,F
1744:  ADDWFC 02,F
1746:  MOVF   x86,W
1748:  MULWF  x8C
174A:  MOVF   FF3,W
174C:  ADDWF  x8E,F
174E:  MOVF   FF4,W
1750:  ADDWFC 03,F
1752:  MOVLW  00
1754:  ADDWFC 02,F
1756:  MOVF   x86,W
1758:  MULWF  x8B
175A:  MOVF   FF3,W
175C:  ADDWF  03,F
175E:  MOVF   FF4,W
1760:  ADDWFC 02,F
1762:  MOVLW  00
1764:  CLRF   01
1766:  ADDWFC 01,F
1768:  MOVF   x88,W
176A:  MULWF  x8A
176C:  MOVF   FF3,W
176E:  ADDWF  x8E,F
1770:  MOVF   FF4,W
1772:  ADDWFC 03,F
1774:  MOVLW  00
1776:  ADDWFC 02,F
1778:  ADDWFC 01,F
177A:  MOVF   x87,W
177C:  MULWF  x8A
177E:  MOVF   FF3,W
1780:  ADDWF  03,F
1782:  MOVF   FF4,W
1784:  ADDWFC 02,F
1786:  MOVLW  00
1788:  ADDWFC 01,F
178A:  MOVF   x86,W
178C:  MULWF  x8A
178E:  MOVF   FF3,W
1790:  ADDWF  02,F
1792:  MOVF   FF4,W
1794:  ADDWFC 01,F
1796:  INCF   00,F
1798:  BTFSC  01.7
179A:  BRA    17A6
179C:  RLCF   x8E,F
179E:  RLCF   03,F
17A0:  RLCF   02,F
17A2:  RLCF   01,F
17A4:  DECF   00,F
17A6:  MOVLW  00
17A8:  BTFSS  x8E.7
17AA:  BRA    17C0
17AC:  INCF   03,F
17AE:  ADDWFC 02,F
17B0:  ADDWFC 01,F
17B2:  MOVF   01,W
17B4:  BNZ   17C0
17B6:  MOVF   02,W
17B8:  BNZ   17C0
17BA:  MOVF   03,W
17BC:  BNZ   17C0
17BE:  INCF   00,F
17C0:  BTFSC  x8D.7
17C2:  BSF    01.7
17C4:  BTFSS  x8D.7
17C6:  BCF    01.7
17C8:  BRA    17D2
17CA:  CLRF   00
17CC:  CLRF   01
17CE:  CLRF   02
17D0:  CLRF   03
17D2:  MOVLB  0
17D4:  RETURN 0
*
18C2:  MOVFF  282,289
18C6:  MOVLB  2
18C8:  MOVF   x86,W
18CA:  XORWF  x89,F
18CC:  BTFSS  x89.7
18CE:  BRA    18DA
18D0:  BCF    FD8.2
18D2:  BCF    FD8.0
18D4:  BTFSC  x82.7
18D6:  BSF    FD8.0
18D8:  BRA    1938
18DA:  MOVFF  282,289
18DE:  MOVFF  285,28A
18E2:  MOVF   x81,W
18E4:  SUBWF  x8A,F
18E6:  BZ    18F4
18E8:  BTFSS  x89.7
18EA:  BRA    1938
18EC:  MOVF   FD8,W
18EE:  XORLW  01
18F0:  MOVWF  FD8
18F2:  BRA    1938
18F4:  MOVFF  286,28A
18F8:  MOVF   x82,W
18FA:  SUBWF  x8A,F
18FC:  BZ    190A
18FE:  BTFSS  x89.7
1900:  BRA    1938
1902:  MOVF   FD8,W
1904:  XORLW  01
1906:  MOVWF  FD8
1908:  BRA    1938
190A:  MOVFF  287,28A
190E:  MOVF   x83,W
1910:  SUBWF  x8A,F
1912:  BZ    1920
1914:  BTFSS  x89.7
1916:  BRA    1938
1918:  MOVF   FD8,W
191A:  XORLW  01
191C:  MOVWF  FD8
191E:  BRA    1938
1920:  MOVFF  288,28A
1924:  MOVF   x84,W
1926:  SUBWF  x8A,F
1928:  BZ    1936
192A:  BTFSS  x89.7
192C:  BRA    1938
192E:  MOVF   FD8,W
1930:  XORLW  01
1932:  MOVWF  FD8
1934:  BRA    1938
1936:  BCF    FD8.0
1938:  MOVLB  0
193A:  RETURN 0
193C:  MOVLB  2
193E:  MOVF   x4F,W
1940:  ANDLW  07
1942:  MOVWF  00
1944:  RRCF   x4F,W
1946:  MOVWF  01
1948:  RRCF   01,F
194A:  RRCF   01,F
194C:  MOVLW  1F
194E:  ANDWF  01,F
1950:  MOVF   01,W
1952:  ADDWF  x51,W
1954:  MOVWF  FE9
1956:  MOVLW  00
1958:  ADDWFC x52,W
195A:  MOVWF  FEA
195C:  CLRF   01
195E:  INCF   01,F
1960:  INCF   00,F
1962:  BRA    1966
1964:  RLCF   01,F
1966:  DECFSZ 00,F
1968:  BRA    1964
196A:  MOVF   x50,F
196C:  BZ    1974
196E:  MOVF   01,W
1970:  IORWF  FEF,F
1972:  BRA    197A
1974:  COMF   01,F
1976:  MOVF   01,W
1978:  ANDWF  FEF,F
197A:  MOVLB  0
197C:  RETURN 0
*
1D44:  MOVLB  2
1D46:  MOVF   x4F,W
1D48:  ANDLW  07
1D4A:  MOVWF  00
1D4C:  RRCF   x4F,W
1D4E:  MOVWF  01
1D50:  RRCF   01,F
1D52:  RRCF   01,F
1D54:  MOVLW  1F
1D56:  ANDWF  01,F
1D58:  MOVF   01,W
1D5A:  ADDWF  x50,W
1D5C:  MOVWF  FE9
1D5E:  MOVLW  00
1D60:  ADDWFC x51,W
1D62:  MOVWF  FEA
1D64:  MOVFF  FEF,01
1D68:  INCF   00,F
1D6A:  BRA    1D6E
1D6C:  RRCF   01,F
1D6E:  DECFSZ 00,F
1D70:  BRA    1D6C
1D72:  MOVLW  01
1D74:  ANDWF  01,F
1D76:  MOVLB  0
1D78:  RETURN 0
*
203A:  MOVFF  21B,FEA
203E:  MOVFF  21A,FE9
2042:  MOVLB  2
2044:  MOVFF  266,FEF
2048:  INCF   FE9,F
204A:  BTFSC  FD8.2
204C:  INCF   FEA,F
204E:  CLRF   FEF
2050:  INCF   x1A,F
2052:  BTFSC  FD8.2
2054:  INCF   x1B,F
2056:  MOVLB  0
2058:  RETURN 0
205A:  MOVFF  FEA,265
205E:  MOVFF  FE9,264
2062:  MOVLB  2
2064:  SWAPF  x5E,W
2066:  IORLW  F0
2068:  MOVWF  x60
206A:  ADDWF  x60,F
206C:  ADDLW  E2
206E:  MOVWF  x61
2070:  ADDLW  32
2072:  MOVWF  x63
2074:  MOVF   x5E,W
2076:  ANDLW  0F
2078:  ADDWF  x61,F
207A:  ADDWF  x61,F
207C:  ADDWF  x63,F
207E:  ADDLW  E9
2080:  MOVWF  x62
2082:  ADDWF  x62,F
2084:  ADDWF  x62,F
2086:  SWAPF  x5D,W
2088:  ANDLW  0F
208A:  ADDWF  x62,F
208C:  ADDWF  x63,F
208E:  RLCF   x62,F
2090:  RLCF   x63,F
2092:  COMF   x63,F
2094:  RLCF   x63,F
2096:  MOVF   x5D,W
2098:  ANDLW  0F
209A:  ADDWF  x63,F
209C:  RLCF   x60,F
209E:  MOVLW  07
20A0:  MOVWF  x5F
20A2:  MOVLW  0A
20A4:  DECF   x62,F
20A6:  ADDWF  x63,F
20A8:  BNC   20A4
20AA:  DECF   x61,F
20AC:  ADDWF  x62,F
20AE:  BNC   20AA
20B0:  DECF   x60,F
20B2:  ADDWF  x61,F
20B4:  BNC   20B0
20B6:  DECF   x5F,F
20B8:  ADDWF  x60,F
20BA:  BNC   20B6
20BC:  MOVLW  02
20BE:  MOVWF  FEA
20C0:  MOVLW  5F
20C2:  MOVWF  FE9
20C4:  MOVLW  07
20C6:  ANDWF  x64,W
20C8:  BCF    x64.6
20CA:  ADDWF  FE9,F
20CC:  MOVLW  00
20CE:  ADDWFC FEA,F
20D0:  MOVF   FE9,W
20D2:  SUBLW  63
20D4:  BNZ   20DE
20D6:  MOVF   FEA,W
20D8:  SUBLW  02
20DA:  BNZ   20DE
20DC:  BSF    x64.6
20DE:  MOVF   FEF,W
20E0:  MOVWF  00
20E2:  BNZ   20F4
20E4:  BTFSC  x64.6
20E6:  BRA    20F4
20E8:  BTFSC  x64.4
20EA:  BRA    2116
20EC:  BTFSC  x64.3
20EE:  BRA    20F4
20F0:  MOVLW  20
20F2:  BRA    20FA
20F4:  BSF    x64.3
20F6:  BCF    x64.4
20F8:  MOVLW  30
20FA:  ADDWF  00,F
20FC:  MOVFF  FEA,25E
2100:  MOVFF  FE9,25D
2104:  MOVFF  00,266
2108:  MOVLB  0
210A:  RCALL  203A
210C:  MOVFF  25E,FEA
2110:  MOVFF  25D,FE9
2114:  MOVLB  2
2116:  MOVF   FEE,W
2118:  BTFSS  x64.6
211A:  BRA    20D0
211C:  MOVLB  0
211E:  GOTO   21CC (RETURN)
2122:  MOVF   01,W
2124:  MOVFF  25D,25F
2128:  MOVLW  64
212A:  MOVLB  2
212C:  MOVWF  x60
212E:  MOVLB  0
2130:  CALL   137E
2134:  MOVFF  00,25D
2138:  MOVF   01,W
213A:  MOVLW  30
213C:  BNZ   214E
213E:  MOVLB  2
2140:  BTFSS  x5E.1
2142:  BRA    2162
2144:  BTFSC  x5E.3
2146:  BRA    2162
2148:  BTFSC  x5E.4
214A:  MOVLW  20
214C:  BRA    2156
214E:  MOVLB  2
2150:  BCF    x5E.3
2152:  BCF    x5E.4
2154:  BSF    x5E.0
2156:  ADDWF  01,F
2158:  MOVFF  01,266
215C:  MOVLB  0
215E:  RCALL  203A
2160:  MOVLB  2
2162:  MOVFF  25D,25F
2166:  MOVLW  0A
2168:  MOVWF  x60
216A:  MOVLB  0
216C:  CALL   137E
2170:  MOVFF  00,25D
2174:  MOVF   01,W
2176:  MOVLW  30
2178:  BNZ   218A
217A:  MOVLB  2
217C:  BTFSC  x5E.3
217E:  BRA    2194
2180:  BTFSS  x5E.0
2182:  BRA    2194
2184:  BTFSC  x5E.4
2186:  MOVLW  20
2188:  MOVLB  0
218A:  ADDWF  01,F
218C:  MOVFF  01,266
2190:  RCALL  203A
2192:  MOVLB  2
2194:  MOVLW  30
2196:  ADDWF  x5D,F
2198:  MOVFF  25D,266
219C:  MOVLB  0
219E:  RCALL  203A
21A0:  GOTO   2212 (RETURN)
*
43E2:  ADDWF  FE8,W
43E4:  CLRF   FF7
43E6:  RLCF   FF7,F
43E8:  ADDLW  FD
43EA:  MOVWF  FF6
43EC:  MOVLW  43
43EE:  ADDWFC FF7,F
43F0:  TBLRD*-
43F2:  MOVF   FF5,W
43F4:  MOVWF  FFA
43F6:  TBLRD*
43F8:  MOVF   FF5,W
43FA:  MOVWF  FF9
43FC:  DATA B0,3E
43FE:  DATA B0,3E
4400:  DATA D0,3E
4402:  DATA EE,3E
4404:  DATA 0C,3F
4406:  ADDWF  FE8,W
4408:  CLRF   FF7
440A:  RLCF   FF7,F
440C:  ADDLW  21
440E:  MOVWF  FF6
4410:  MOVLW  44
4412:  ADDWFC FF7,F
4414:  TBLRD*-
4416:  MOVF   FF5,W
4418:  MOVWF  FFA
441A:  TBLRD*
441C:  MOVF   FF5,W
441E:  MOVWF  FF9
4420:  DATA 62,3F
4422:  DATA 62,3F
4424:  DATA B0,3F
4426:  DATA FC,3F
4428:  DATA 48,40
442A:  ADDWF  FE8,W
442C:  CLRF   FF7
442E:  RLCF   FF7,F
4430:  ADDLW  45
4432:  MOVWF  FF6
4434:  MOVLW  44
4436:  ADDWFC FF7,F
4438:  TBLRD*-
443A:  MOVF   FF5,W
443C:  MOVWF  FFA
443E:  TBLRD*
4440:  MOVF   FF5,W
4442:  MOVWF  FF9
4444:  DATA CE,40
4446:  DATA CE,40
4448:  DATA EE,40
444A:  DATA 0C,41
444C:  DATA 2A,41
444E:  ADDWF  FE8,W
4450:  CLRF   FF7
4452:  RLCF   FF7,F
4454:  ADDLW  69
4456:  MOVWF  FF6
4458:  MOVLW  44
445A:  ADDWFC FF7,F
445C:  TBLRD*-
445E:  MOVF   FF5,W
4460:  MOVWF  FFA
4462:  TBLRD*
4464:  MOVF   FF5,W
4466:  MOVWF  FF9
4468:  DATA 80,41
446A:  DATA 80,41
446C:  DATA CC,41
446E:  DATA 16,42
4470:  DATA 60,42
.................... 
.................... #list
.................... 
.................... 
.................... #fuses NOLVP, NOPROTECT, NOMCLR, NOWDT
.................... #use delay(clock = 20M, crystal = 20M)
*
05EC:  MOVLW  02
05EE:  MOVWF  FEA
05F0:  MOVLW  6F
05F2:  MOVWF  FE9
05F4:  MOVF   FEF,W
05F6:  BZ    0612
05F8:  MOVLW  06
05FA:  MOVWF  01
05FC:  CLRF   00
05FE:  DECFSZ 00,F
0600:  BRA    05FE
0602:  DECFSZ 01,F
0604:  BRA    05FC
0606:  MOVLW  7B
0608:  MOVWF  00
060A:  DECFSZ 00,F
060C:  BRA    060A
060E:  DECFSZ FEF,F
0610:  BRA    05F8
0612:  RETURN 0
.................... 
.................... #include <HDM64GS12.c>
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                           HDM64GS12.c                           ////
.................... ////                                                                 ////
.................... //// This file contains drivers for using a Hantronix HDM64GS12 with ////
.................... //// a KS0108 display controller. The HDM64GS12 is 128 by 64 pixels. ////
.................... //// The driver treats the upper left pixel as (0,0).                ////
.................... ////                                                                 ////
.................... //// Use #define FAST_GLCD if the target chip has at least 1k of RAM ////
.................... //// to decrease the time it takes to update the display.            ////
.................... //// glcd_update() must then be called to update the display after   ////
.................... //// changing the pixel information.                                 ////
.................... //// See ex_glcd.c for suggested usage.                              ////
.................... //// See KS0108.c for controlling a single 64 by 64 display          ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                                                                 ////
.................... //// LCD Pin connections:                                            ////
.................... //// (These can be changed as needed in the following defines).      ////
.................... ////  * 1: VSS is connected to GND                                   ////
.................... ////  * 2: VDD is connected to +5V                                   ////
.................... ////  * 3: V0  - LCD operating voltage (Contrast adjustment)         ////
.................... ////  * 4: D/I - Data or Instruction is connected to B2              ////
.................... ////  * 5: R/W - Read or Write is connected to B4                    ////
.................... ////  * 6: Enable is connected to B5                                 ////
.................... ////  *7-14: Data Bus 0 to 7 is connected to port d                  ////
.................... ////  *15: Chip Select 1 is connected to B0                          ////
.................... ////  *16: Chip Select 2 is connected to B1                          ////
.................... ////  *17: Reset is connected to C0                                  ////
.................... ////  *18: Negative voltage is also connected to the 20k Ohm POT     ////
.................... ////  *19: Positive voltage for LED backlight is connected to +5V    ////
.................... ////  *20: Negative voltage for LED backlight is connected to GND    ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                                                                 ////
.................... ////  glcd_init(mode)                                                ////
.................... ////     * Must be called before any other function.                 ////
.................... ////       - mode can be ON or OFF to turn the LCD on or off         ////
.................... ////                                                                 ////
.................... ////  glcd_pixel(x,y,color)                                          ////
.................... ////     * Sets the pixel to the given color.                        ////
.................... ////       - color can be ON or OFF                                  ////
.................... ////                                                                 ////
.................... ////  glcd_fillScreen(color)                                         ////
.................... ////     * Fills the entire LCD with the given color.                ////
.................... ////       - color can be ON or OFF                                  ////
.................... ////                                                                 ////
.................... ////  glcd_update()                                                  ////
.................... ////     * Write the display data stored in RAM to the LCD           ////
.................... ////     * Only available if FAST_GLCD is defined                    ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////  Version History                                                ////
.................... ////                                                                 ////
.................... ////  05/01/20 - Added defines to selecting the data bus port or     ////
.................... ////             pins used with this driver.                         ////
.................... ////                                                                 ////
.................... ////             GLCD_PORT - to assign the port to use for the GLCD  ////
.................... ////                 data bus pins, for example:                     ////
.................... ////                    #define GLCD_PORT    c                       ////
.................... ////                                                                 ////
.................... ////                 The above assigns it to use PORTC for the data  ////
.................... ////                 bus pins.  Driver defaults to PORTD if          ////
.................... ////                 GLCD_PORT and GLCD_DATA0 are not defined before ////
.................... ////                 this driver is included in project.             ////
.................... ////                                                                 ////
.................... ////             GLCD_DATA0 - to assign the data bus 0 pin.          ////
.................... ////                                                                 ////
.................... ////             GLCD_DATA1 - to assign the data bus 1 pin.          ////
.................... ////                                                                 ////
.................... ////             GLCD_DATA2 - to assign the data bus 2 pin.          ////
.................... ////                                                                 ////
.................... ////             GLCD_DATA3 - to assign the data bus 3 pin.          ////
.................... ////                                                                 ////
.................... ////             GLCD_DATA4 - to assign the data bus 4 pin.          ////
.................... ////                                                                 ////
.................... ////             GLCD_DATA5 - to assign the data bus 5 pin.          ////
.................... ////                                                                 ////
.................... ////             GLCD_DATA6 - to assign the data bus 6 pin.          ////
.................... ////                                                                 ////
.................... ////             GLCD_DATA7 - to assign the data bus 7 pin.          ////
.................... ////                                                                 ////
.................... ////     The defines GLCD_DATA0 to GLCD_DATA7 can only be used to    ////
.................... ////     assign the pins if GLCD_PORT is not defined.  All eight     ////
.................... ////     defines must be defined before this driver is included in   ////
.................... ////     project to make assignments.  No default defines are made   ////
.................... ////     for GLCD_DATA0 to GLCD_DATA7.                               ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services        ////
.................... //// This source code may only be used by licensed users of the CCS  ////
.................... //// C compiler.  This source code may only be distributed to other  ////
.................... //// licensed users of the CCS C compiler.  No other use,            ////
.................... //// reproduction or distribution is permitted without written       ////
.................... //// permission.  Derivative programs created using this software    ////
.................... //// in object code form are not restricted in any way.              ////
.................... /////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef HDM64GS12
.................... #define HDM64GS12
.................... 
.................... #ifndef concat
....................  #define concat(x,y)    x####y
.................... #endif
.................... 
.................... #ifndef GLCD_WIDTH
....................  #define GLCD_WIDTH     128
.................... #endif
.................... 
.................... #ifndef GLCD_CS1
....................  #define GLCD_CS1       PIN_B0   // Chip Selection 1
.................... #endif
.................... 
.................... #ifndef GLCD_CS2
....................  #define GLCD_CS2       PIN_B1   // Chip Selection 2
.................... #endif
.................... 
.................... #ifndef GLCD_DI
....................  #define GLCD_DI        PIN_B2   // Data or Instruction input
.................... #endif
.................... 
.................... #ifndef GLCD_RW
....................  #define GLCD_RW        PIN_B4   // Read/Write
.................... #endif
.................... 
.................... #ifndef GLCD_E
....................  #define GLCD_E         PIN_B5   // Enable
.................... #endif
.................... 
.................... #ifndef GLCD_RST
....................  #define GLCD_RST       PIN_C0   // Reset
.................... #endif
.................... 
.................... #if !defined(GLCD_PORT) && !defined(GLCD_DATA0)
....................  #define GLCD_PORT      d
.................... #elif !defined(GLCD_PORT) && defined(GLCD_DATA0)
....................  #if !defined(GLCD_DATA1) || !defined(GLCD_DATA2) || !defined(GLCD_DATA3) || !defined(GLCD_DATA4) || \
....................      !defined(GLCD_DATA5) || !defined(GLCD_DATA6) || !defined(GLCD_DATA7)
....................   #error not all GLCD Data pins defined.
....................  #endif
.................... #endif
.................... 
.................... #define GLCD_LEFT       0
.................... #define GLCD_RIGHT      1
.................... 
.................... #ifndef ON
....................  #define ON             1
.................... #endif
.................... 
.................... #ifndef OFF
....................  #define OFF            0
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////
.................... // Function Prototypes
.................... /////////////////////////////////////////////////////////////////////////
.................... void glcd_init(int1 mode);
.................... void glcd_pixel(unsigned int8 x, unsigned int8 y, int1 color);
.................... void glcd_fillScreen(int1 color);
.................... void glcd_writeByte(int1 side, BYTE data);
.................... BYTE glcd_readByte(int1 side);
.................... void glcd_update();
.................... /////////////////////////////////////////////////////////////////////////
.................... 
.................... #if defined(GLCD_PORT)
....................  #define WritePort(v)   concat(output_, GLCD_PORT(v))
....................  #define ReadPort()     concat(input_, GLCD_PORT())
....................  #define TrisPort(v)    concat(set_tris_, GLCD_PORT(v))
.................... #else
....................  #define TrisPort(v)
.................... 
....................  void WritePort(unsigned int8 value)
....................  {
....................    output_bit(GLCD_DATA0, bit_test(value, 0));
....................    output_bit(GLCD_DATA1, bit_test(value, 1));
....................    output_bit(GLCD_DATA2, bit_test(value, 2));
....................    output_bit(GLCD_DATA3, bit_test(value, 3));
....................    output_bit(GLCD_DATA4, bit_test(value, 4));
....................    output_bit(GLCD_DATA5, bit_test(value, 5));
....................    output_bit(GLCD_DATA6, bit_test(value, 6));
....................    output_bit(GLCD_DATA7, bit_test(value, 7));
....................  }
....................  
....................  unsigned int8 ReadPort(void)
....................  {
....................    union
....................    {
....................       unsigned int8 b;
....................       int1 bit[8];
....................    } Result;
....................    
....................    Result.bit[0] = input(GLCD_DATA0);
....................    Result.bit[1] = input(GLCD_DATA1);
....................    Result.bit[2] = input(GLCD_DATA2);
....................    Result.bit[3] = input(GLCD_DATA3);
....................    Result.bit[4] = input(GLCD_DATA4);
....................    Result.bit[5] = input(GLCD_DATA5);
....................    Result.bit[6] = input(GLCD_DATA6);
....................    Result.bit[7] = input(GLCD_DATA7);
....................    
....................    return(Result.b);
....................  } 
.................... #endif
.................... 
.................... #ifdef FAST_GLCD
.................... struct
.................... {
....................    unsigned int8 left[512];
....................    unsigned int8 right[512];
.................... } displayData;
.................... #endif
.................... 
.................... 
.................... // Purpose:       Initialize the LCD.
.................... //                Call before using any other LCD function.
.................... // Inputs:        OFF - Turns the LCD off
.................... //                ON  - Turns the LCD on
.................... void glcd_init(int1 mode)
.................... {
....................    // Initialize some pins
....................    output_high(GLCD_RST);
*
06DE:  BCF    F94.0
06E0:  BSF    F8B.0
....................    output_low(GLCD_E);
06E2:  BCF    F93.5
06E4:  BCF    F8A.5
....................    output_low(GLCD_CS1);
06E6:  BCF    F93.0
06E8:  BCF    F8A.0
....................    output_low(GLCD_CS2);
06EA:  BCF    F93.1
06EC:  BCF    F8A.1
.................... 
....................    output_low(GLCD_DI);                 // Set for instruction
06EE:  BCF    F93.2
06F0:  BCF    F8A.2
....................    glcd_writeByte(GLCD_LEFT,  0xC0);    // Specify first RAM line at the top
06F2:  MOVLB  2
06F4:  CLRF   x8E
06F6:  MOVLW  C0
06F8:  MOVWF  x8F
06FA:  MOVLB  0
06FC:  RCALL  0614
....................    glcd_writeByte(GLCD_RIGHT, 0xC0);    //   of the screen
06FE:  MOVLW  01
0700:  MOVLB  2
0702:  MOVWF  x8E
0704:  MOVLW  C0
0706:  MOVWF  x8F
0708:  MOVLB  0
070A:  RCALL  0614
....................    glcd_writeByte(GLCD_LEFT,  0x40);    // Set the column address to 0
070C:  MOVLB  2
070E:  CLRF   x8E
0710:  MOVLW  40
0712:  MOVWF  x8F
0714:  MOVLB  0
0716:  RCALL  0614
....................    glcd_writeByte(GLCD_RIGHT, 0x40);
0718:  MOVLW  01
071A:  MOVLB  2
071C:  MOVWF  x8E
071E:  MOVLW  40
0720:  MOVWF  x8F
0722:  MOVLB  0
0724:  RCALL  0614
....................    glcd_writeByte(GLCD_LEFT,  0xB8);    // Set the page address to 0
0726:  MOVLB  2
0728:  CLRF   x8E
072A:  MOVLW  B8
072C:  MOVWF  x8F
072E:  MOVLB  0
0730:  RCALL  0614
....................    glcd_writeByte(GLCD_RIGHT, 0xB8);
0732:  MOVLW  01
0734:  MOVLB  2
0736:  MOVWF  x8E
0738:  MOVLW  B8
073A:  MOVWF  x8F
073C:  MOVLB  0
073E:  RCALL  0614
.................... 
....................    if(mode == ON)
0740:  MOVLB  2
0742:  DECFSZ x4F,W
0744:  BRA    0762
....................    {
....................       glcd_writeByte(GLCD_LEFT,  0x3F); // Turn the display on
0746:  CLRF   x8E
0748:  MOVLW  3F
074A:  MOVWF  x8F
074C:  MOVLB  0
074E:  RCALL  0614
....................       glcd_writeByte(GLCD_RIGHT, 0x3F);
0750:  MOVLW  01
0752:  MOVLB  2
0754:  MOVWF  x8E
0756:  MOVLW  3F
0758:  MOVWF  x8F
075A:  MOVLB  0
075C:  RCALL  0614
....................    }
075E:  BRA    077A
0760:  MOVLB  2
....................    else
....................    {
....................       glcd_writeByte(GLCD_LEFT,  0x3E); // Turn the display off
0762:  CLRF   x8E
0764:  MOVLW  3E
0766:  MOVWF  x8F
0768:  MOVLB  0
076A:  RCALL  0614
....................       glcd_writeByte(GLCD_RIGHT, 0x3E);
076C:  MOVLW  01
076E:  MOVLB  2
0770:  MOVWF  x8E
0772:  MOVLW  3E
0774:  MOVWF  x8F
0776:  MOVLB  0
0778:  RCALL  0614
....................    }
.................... 
....................    glcd_fillScreen(OFF);                // Clear the display
077A:  MOVLB  2
077C:  CLRF   x6E
077E:  MOVLB  0
0780:  RCALL  0658
.................... 
....................    #ifdef FAST_GLCD
0782:  GOTO   27AA (RETURN)
....................    glcd_update();
....................    #endif
.................... }
.................... 
.................... 
.................... // Purpose:    Update the LCD with data from the display arrays
.................... #ifdef FAST_GLCD
.................... void glcd_update()
.................... {
....................    unsigned int8 i, j;
....................    unsigned int8 *p1, *p2;
.................... 
....................    p1 = displayData.left;
....................    p2 = displayData.right;
.................... 
....................    // Loop through the vertical pages
....................    for(i = 0; i < 8; ++i)
....................    {
....................       output_low(GLCD_DI);                      // Set for instruction
....................       glcd_writeByte(GLCD_LEFT, 0x40);          // Set horizontal address to 0
....................       glcd_writeByte(GLCD_RIGHT, 0x40);
....................       glcd_writeByte(GLCD_LEFT, i | 0xB8);      // Set page address
....................       glcd_writeByte(GLCD_RIGHT, i | 0xB8);
....................       output_high(GLCD_DI);                     // Set for data
.................... 
....................       // Loop through the horizontal sections
....................       for(j = 0; j < 64; ++j)
....................       {
....................          glcd_writeByte(GLCD_LEFT, *p1++);      // Turn pixels on or off
....................          glcd_writeByte(GLCD_RIGHT, *p2++);     // Turn pixels on or off
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... 
.................... // Purpose:    Turn a pixel on a graphic LCD on or off
.................... // Inputs:     1) x - the x coordinate of the pixel
.................... //             2) y - the y coordinate of the pixel
.................... //             3) color - ON or OFF
.................... void glcd_pixel(unsigned int8 x, unsigned int8 y, int1 color)
.................... #ifdef FAST_GLCD
*
07C8:  MOVLB  2
07CA:  BCF    x8B.0
.................... {
....................    unsigned int8* p;
....................    unsigned int16 temp;
....................    temp =  y/8;
....................    temp *= 64;
....................    temp += x;
.................... 
....................    if(x > 63)
....................    {
....................       p = displayData.right + temp - 64;
....................    }
....................    else
....................    {
....................       p = displayData.left + temp;
....................    }
.................... 
....................    if(color)
....................    {
....................       bit_set(*p, y%8);
....................    }
....................    else
....................    {
....................       bit_clear(*p, y%8);
....................    }
.................... }
.................... #else
.................... {
....................    BYTE data;
....................    int1 side = GLCD_LEFT;  // Stores which chip to use on the LCD
.................... 
....................    if(x > 63)              // Check for first or second display area
07CC:  MOVF   x87,W
07CE:  SUBLW  3F
07D0:  BC    07D8
....................    {
....................       x -= 64;
07D2:  MOVLW  40
07D4:  SUBWF  x87,F
....................       side = GLCD_RIGHT;
07D6:  BSF    x8B.0
....................    }
.................... 
....................    output_low(GLCD_DI);                         // Set for instruction
07D8:  BCF    F93.2
07DA:  BCF    F8A.2
....................    bit_clear(x,7);                              // Clear the MSB. Part of an instruction code
07DC:  BCF    x87.7
....................    bit_set(x,6);                                // Set bit 6. Also part of an instruction code
07DE:  BSF    x87.6
....................    glcd_writeByte(side, x);                     // Set the horizontal address
07E0:  MOVLW  00
07E2:  BTFSC  x8B.0
07E4:  MOVLW  01
07E6:  MOVWF  x8C
07E8:  MOVWF  x8E
07EA:  MOVFF  287,28F
07EE:  MOVLB  0
07F0:  RCALL  0614
....................    glcd_writeByte(side, (y/8 & 0xBF) | 0xB8);   // Set the vertical page address
07F2:  MOVLW  00
07F4:  MOVLB  2
07F6:  BTFSC  x8B.0
07F8:  MOVLW  01
07FA:  MOVWF  x8C
07FC:  RRCF   x88,W
07FE:  MOVWF  00
0800:  RRCF   00,F
0802:  RRCF   00,F
0804:  MOVLW  1F
0806:  ANDWF  00,F
0808:  MOVF   00,W
080A:  ANDLW  BF
080C:  IORLW  B8
080E:  MOVWF  x8D
0810:  MOVFF  28C,28E
0814:  MOVWF  x8F
0816:  MOVLB  0
0818:  RCALL  0614
....................    output_high(GLCD_DI);                        // Set for data
081A:  BCF    F93.2
081C:  BSF    F8A.2
....................    glcd_readByte(side);                         // Need two reads to get data
081E:  MOVLW  00
0820:  MOVLB  2
0822:  BTFSC  x8B.0
0824:  MOVLW  01
0826:  MOVWF  x8C
0828:  MOVWF  x8D
082A:  MOVLB  0
082C:  RCALL  0786
....................    data = glcd_readByte(side);                  //  at new address
082E:  MOVLW  00
0830:  MOVLB  2
0832:  BTFSC  x8B.0
0834:  MOVLW  01
0836:  MOVWF  x8C
0838:  MOVWF  x8D
083A:  MOVLB  0
083C:  RCALL  0786
083E:  MOVFF  01,28A
.................... 
....................    if(color == ON)
0842:  MOVLB  2
0844:  DECFSZ x89,W
0846:  BRA    0866
....................       bit_set(data, y%8);        // Turn the pixel on
0848:  MOVF   x88,W
084A:  ANDLW  07
084C:  MOVWF  x8C
084E:  MOVLW  01
0850:  MOVWF  00
0852:  MOVF   x8C,W
0854:  MOVWF  01
0856:  BZ    0860
0858:  BCF    FD8.0
085A:  RLCF   00,F
085C:  DECFSZ 01,F
085E:  BRA    0858
0860:  MOVF   00,W
0862:  IORWF  x8A,F
0864:  BRA    0884
....................    else                          // or
....................       bit_clear(data, y%8);      // turn the pixel off
0866:  MOVF   x88,W
0868:  ANDLW  07
086A:  MOVWF  x8C
086C:  MOVLW  01
086E:  MOVWF  00
0870:  MOVF   x8C,W
0872:  MOVWF  01
0874:  BZ    087E
0876:  BCF    FD8.0
0878:  RLCF   00,F
087A:  DECFSZ 01,F
087C:  BRA    0876
087E:  MOVF   00,W
0880:  XORLW  FF
0882:  ANDWF  x8A,F
.................... 
....................    output_low(GLCD_DI);          // Set for instruction
0884:  BCF    F93.2
0886:  BCF    F8A.2
....................    glcd_writeByte(side, x);      // Set the horizontal address
0888:  MOVLW  00
088A:  BTFSC  x8B.0
088C:  MOVLW  01
088E:  MOVWF  x8C
0890:  MOVWF  x8E
0892:  MOVFF  287,28F
0896:  MOVLB  0
0898:  RCALL  0614
....................    output_high(GLCD_DI);         // Set for data
089A:  BCF    F93.2
089C:  BSF    F8A.2
....................    glcd_writeByte(side, data);   // Write the pixel data
089E:  MOVLW  00
08A0:  MOVLB  2
08A2:  BTFSC  x8B.0
08A4:  MOVLW  01
08A6:  MOVWF  x8C
08A8:  MOVWF  x8E
08AA:  MOVFF  28A,28F
08AE:  MOVLB  0
08B0:  RCALL  0614
08B2:  RETURN 0
.................... }
.................... #endif
.................... 
.................... 
.................... // Purpose:    Fill the LCD screen with the passed in color
.................... // Inputs:     ON  - turn all the pixels on
.................... //             OFF - turn all the pixels off
.................... void glcd_fillScreen(int1 color)
.................... #ifdef FAST_GLCD
.................... {
....................    unsigned int8  data;
....................    unsigned int8  *p1, *p2;
....................    unsigned int16 i;
.................... 
....................    p1 = displayData.left;
....................    p2 = displayData.right;
....................    data = 0xFF * color;
.................... 
....................    for(i=0; i<512; ++i)
....................    {
....................       *p1++ = data;
....................       *p2++ = data;
....................    }
.................... }
.................... #else
.................... {
....................    unsigned int8 i, j;
.................... 
....................    // Loop through the vertical pages
....................    for(i = 0; i < 8; ++i)
*
0658:  MOVLB  2
065A:  CLRF   x6F
065C:  MOVF   x6F,W
065E:  SUBLW  07
0660:  BNC   06DA
....................    {
....................       output_low(GLCD_DI);                      // Set for instruction
0662:  BCF    F93.2
0664:  BCF    F8A.2
....................       glcd_writeByte(GLCD_LEFT, 0b01000000);    // Set horizontal address to 0
0666:  CLRF   x8E
0668:  MOVLW  40
066A:  MOVWF  x8F
066C:  MOVLB  0
066E:  RCALL  0614
....................       glcd_writeByte(GLCD_RIGHT, 0b01000000);
0670:  MOVLW  01
0672:  MOVLB  2
0674:  MOVWF  x8E
0676:  MOVLW  40
0678:  MOVWF  x8F
067A:  MOVLB  0
067C:  RCALL  0614
....................       glcd_writeByte(GLCD_LEFT, i | 0b10111000);// Set page address
067E:  MOVLB  2
0680:  MOVF   x6F,W
0682:  IORLW  B8
0684:  MOVWF  x71
0686:  CLRF   x8E
0688:  MOVWF  x8F
068A:  MOVLB  0
068C:  RCALL  0614
....................       glcd_writeByte(GLCD_RIGHT, i | 0b10111000);
068E:  MOVLB  2
0690:  MOVF   x6F,W
0692:  IORLW  B8
0694:  MOVWF  x71
0696:  MOVLW  01
0698:  MOVWF  x8E
069A:  MOVFF  271,28F
069E:  MOVLB  0
06A0:  RCALL  0614
....................       output_high(GLCD_DI);                     // Set for data
06A2:  BCF    F93.2
06A4:  BSF    F8A.2
.................... 
....................       // Loop through the horizontal sections
....................       for(j = 0; j < 64; ++j)
06A6:  MOVLB  2
06A8:  CLRF   x70
06AA:  MOVF   x70,W
06AC:  SUBLW  3F
06AE:  BNC   06D6
....................       {
....................          glcd_writeByte(GLCD_LEFT, 0xFF*color);  // Turn pixels on or off
06B0:  MOVF   x6E,W
06B2:  MULLW  FF
06B4:  MOVFF  FF3,28F
06B8:  CLRF   x8E
06BA:  MOVLB  0
06BC:  RCALL  0614
....................          glcd_writeByte(GLCD_RIGHT, 0xFF*color); // Turn pixels on or off
06BE:  MOVLB  2
06C0:  MOVF   x6E,W
06C2:  MULLW  FF
06C4:  MOVFF  FF3,28F
06C8:  MOVLW  01
06CA:  MOVWF  x8E
06CC:  MOVLB  0
06CE:  RCALL  0614
06D0:  MOVLB  2
06D2:  INCF   x70,F
06D4:  BRA    06AA
....................       }
06D6:  INCF   x6F,F
06D8:  BRA    065C
....................    }
06DA:  MOVLB  0
06DC:  RETURN 0
.................... }
.................... #endif
.................... 
.................... 
.................... // Purpose:    Write a byte of data to the specified chip
.................... // Inputs:     1) chipSelect - which chip to write the data to
.................... //             2) data - the byte of data to write
.................... void glcd_writeByte(int1 side, BYTE data)
.................... {
....................    TrisPort(0x00);
*
0614:  MOVLW  00
0616:  MOVWF  F95
....................    
....................    output_low(GLCD_RW);       // Set for writing
0618:  BCF    F93.4
061A:  BCF    F8A.4
.................... 
....................     if(side)                   // Choose which side to write to
061C:  MOVLB  2
061E:  MOVF   x8E,F
0620:  BZ    0628
....................       output_high(GLCD_CS2);
0622:  BCF    F93.1
0624:  BSF    F8A.1
0626:  BRA    062C
....................    else
....................       output_high(GLCD_CS1);
0628:  BCF    F93.0
062A:  BSF    F8A.0
.................... 
....................     delay_us(1);
062C:  BRA    062E
062E:  BRA    0630
0630:  NOP   
.................... 
....................    WritePort(data);           // Put the data on the port
0632:  CLRF   F95
0634:  MOVFF  28F,F8C
....................    delay_us(1);
0638:  BRA    063A
063A:  BRA    063C
063C:  NOP   
....................    output_high(GLCD_E);       // Pulse the enable pin
063E:  BCF    F93.5
0640:  BSF    F8A.5
....................    delay_us(1);
0642:  BRA    0644
0644:  BRA    0646
0646:  NOP   
....................    output_low(GLCD_E);
0648:  BCF    F93.5
064A:  BCF    F8A.5
.................... 
....................    output_low(GLCD_CS1);      // Reset the chip select lines
064C:  BCF    F93.0
064E:  BCF    F8A.0
....................    output_low(GLCD_CS2);
0650:  BCF    F93.1
0652:  BCF    F8A.1
0654:  MOVLB  0
0656:  RETURN 0
.................... }
.................... 
.................... 
.................... // Purpose:    Reads a byte of data from the specified chip
.................... // Outputs:     A byte of data read from the chip
.................... BYTE glcd_readByte(int1 side)
.................... {
....................    BYTE data;                 // Stores the data read from the LCD
.................... 
....................    TrisPort(0xFF);            // Set port to input
*
0786:  MOVLW  FF
0788:  MOVWF  F95
....................    output_high(GLCD_RW);      // Set for reading
078A:  BCF    F93.4
078C:  BSF    F8A.4
.................... 
....................    if(side)                   // Choose which side to write to
078E:  MOVLB  2
0790:  MOVF   x8D,F
0792:  BZ    079A
....................       output_high(GLCD_CS2);
0794:  BCF    F93.1
0796:  BSF    F8A.1
0798:  BRA    079E
....................    else
....................       output_high(GLCD_CS1);
079A:  BCF    F93.0
079C:  BSF    F8A.0
.................... 
....................    delay_us(1);
079E:  BRA    07A0
07A0:  BRA    07A2
07A2:  NOP   
....................    output_high(GLCD_E);       // Pulse the enable pin
07A4:  BCF    F93.5
07A6:  BSF    F8A.5
....................    delay_us(1);
07A8:  BRA    07AA
07AA:  BRA    07AC
07AC:  NOP   
....................    data = ReadPort();        // Get the data from the display's output register
07AE:  SETF   F95
07B0:  MOVFF  F83,28E
....................    output_low(GLCD_E);
07B4:  BCF    F93.5
07B6:  BCF    F8A.5
.................... 
....................    output_low(GLCD_CS1);      // Reset the chip select lines
07B8:  BCF    F93.0
07BA:  BCF    F8A.0
....................    output_low(GLCD_CS2);
07BC:  BCF    F93.1
07BE:  BCF    F8A.1
....................    return data;               // Return the read data
07C0:  MOVFF  28E,01
07C4:  MOVLB  0
07C6:  RETURN 0
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
*
197E:  MOVLB  2
1980:  CLRF   x66
1982:  CLRF   x65
1984:  CLRF   x64
1986:  MOVLW  7F
1988:  MOVWF  x63
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
198A:  MOVLW  7E
198C:  MOVWF  x6D
198E:  MOVLW  80
1990:  MOVWF  x6E
1992:  CLRF   x6F
1994:  CLRF   x70
1996:  MOVLW  7A
1998:  MOVWF  x71
199A:  MOVLW  2A
199C:  MOVWF  x72
199E:  MOVLW  AA
19A0:  MOVWF  x73
19A2:  MOVLW  A3
19A4:  MOVWF  x74
19A6:  MOVLW  75
19A8:  MOVWF  x75
19AA:  MOVLW  B6
19AC:  MOVWF  x76
19AE:  MOVLW  09
19B0:  MOVWF  x77
19B2:  MOVLW  B4
19B4:  MOVWF  x78
19B6:  MOVLW  6F
19B8:  MOVWF  x79
19BA:  MOVLW  4F
19BC:  MOVWF  x7A
19BE:  MOVLW  B6
19C0:  MOVWF  x7B
19C2:  MOVLW  AA
19C4:  MOVWF  x7C
19C6:  MOVLW  69
19C8:  MOVWF  x7D
19CA:  MOVLW  8B
19CC:  MOVWF  x7E
19CE:  MOVLW  F6
19D0:  MOVWF  x7F
19D2:  MOVLW  E8
19D4:  MOVWF  x80
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
19D6:  MOVFF  25A,284
19DA:  MOVFF  259,283
19DE:  MOVFF  258,282
19E2:  MOVFF  257,281
19E6:  CLRF   x88
19E8:  CLRF   x87
19EA:  CLRF   x86
19EC:  CLRF   x85
19EE:  MOVLB  0
19F0:  RCALL  18C2
19F2:  BNC   19FE
19F4:  MOVLB  2
19F6:  MOVF   x58,W
19F8:  XORLW  80
19FA:  MOVWF  x58
19FC:  MOVLB  0
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
19FE:  MOVFF  25A,288
1A02:  MOVFF  259,287
1A06:  MOVFF  258,286
1A0A:  MOVFF  257,285
1A0E:  MOVLW  83
1A10:  MOVLB  2
1A12:  MOVWF  x8C
1A14:  MOVLW  F9
1A16:  MOVWF  x8B
1A18:  MOVLW  22
1A1A:  MOVWF  x8A
1A1C:  MOVLW  7E
1A1E:  MOVWF  x89
1A20:  MOVLB  0
1A22:  RCALL  16E0
1A24:  MOVFF  03,284
1A28:  MOVFF  02,283
1A2C:  MOVFF  01,282
1A30:  MOVFF  00,281
1A34:  RCALL  1342
1A36:  MOVFF  01,267
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
1A3A:  MOVFF  25A,288
1A3E:  MOVFF  259,287
1A42:  MOVFF  258,286
1A46:  MOVFF  257,285
1A4A:  MOVLW  83
1A4C:  MOVLB  2
1A4E:  MOVWF  x8C
1A50:  MOVLW  F9
1A52:  MOVWF  x8B
1A54:  MOVLW  22
1A56:  MOVWF  x8A
1A58:  MOVLW  7E
1A5A:  MOVWF  x89
1A5C:  MOVLB  0
1A5E:  RCALL  16E0
1A60:  MOVFF  03,284
1A64:  MOVFF  02,283
1A68:  MOVFF  01,282
1A6C:  MOVFF  00,281
1A70:  MOVLB  2
1A72:  CLRF   x86
1A74:  MOVFF  267,285
1A78:  MOVLB  0
1A7A:  CALL   11AE
1A7E:  BSF    FD8.1
1A80:  MOVFF  284,288
1A84:  MOVFF  283,287
1A88:  MOVFF  282,286
1A8C:  MOVFF  281,285
1A90:  MOVFF  03,28C
1A94:  MOVFF  02,28B
1A98:  MOVFF  01,28A
1A9C:  MOVFF  00,289
1AA0:  RCALL  13AA
1AA2:  MOVFF  03,26C
1AA6:  MOVFF  02,26B
1AAA:  MOVFF  01,26A
1AAE:  MOVFF  00,269
....................    quad = quad % 4;                    // quadrant (0 to 3)
1AB2:  MOVLW  03
1AB4:  MOVLB  2
1AB6:  ANDWF  x67,F
.................... 
....................    if (quad == 0 || quad == 2)
1AB8:  MOVF   x67,F
1ABA:  BZ    1AC2
1ABC:  MOVF   x67,W
1ABE:  SUBLW  02
1AC0:  BNZ   1AFA
....................       t = frac * PI_DIV_BY_TWO;
1AC2:  MOVFF  26C,288
1AC6:  MOVFF  26B,287
1ACA:  MOVFF  26A,286
1ACE:  MOVFF  269,285
1AD2:  MOVLW  DB
1AD4:  MOVWF  x8C
1AD6:  MOVLW  0F
1AD8:  MOVWF  x8B
1ADA:  MOVLW  49
1ADC:  MOVWF  x8A
1ADE:  MOVLW  7F
1AE0:  MOVWF  x89
1AE2:  MOVLB  0
1AE4:  RCALL  16E0
1AE6:  MOVFF  03,262
1AEA:  MOVFF  02,261
1AEE:  MOVFF  01,260
1AF2:  MOVFF  00,25F
1AF6:  BRA    1BCE
1AF8:  MOVLB  2
....................    else if (quad == 1)
1AFA:  DECFSZ x67,W
1AFC:  BRA    1B68
....................       t = (1-frac) * PI_DIV_BY_TWO;
1AFE:  BSF    FD8.1
1B00:  CLRF   x88
1B02:  CLRF   x87
1B04:  CLRF   x86
1B06:  MOVLW  7F
1B08:  MOVWF  x85
1B0A:  MOVFF  26C,28C
1B0E:  MOVFF  26B,28B
1B12:  MOVFF  26A,28A
1B16:  MOVFF  269,289
1B1A:  MOVLB  0
1B1C:  RCALL  13AA
1B1E:  MOVFF  03,284
1B22:  MOVFF  02,283
1B26:  MOVFF  01,282
1B2A:  MOVFF  00,281
1B2E:  MOVFF  03,288
1B32:  MOVFF  02,287
1B36:  MOVFF  01,286
1B3A:  MOVFF  00,285
1B3E:  MOVLW  DB
1B40:  MOVLB  2
1B42:  MOVWF  x8C
1B44:  MOVLW  0F
1B46:  MOVWF  x8B
1B48:  MOVLW  49
1B4A:  MOVWF  x8A
1B4C:  MOVLW  7F
1B4E:  MOVWF  x89
1B50:  MOVLB  0
1B52:  RCALL  16E0
1B54:  MOVFF  03,262
1B58:  MOVFF  02,261
1B5C:  MOVFF  01,260
1B60:  MOVFF  00,25F
1B64:  BRA    1BCE
1B66:  MOVLB  2
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
1B68:  BSF    FD8.1
1B6A:  MOVFF  26C,288
1B6E:  MOVFF  26B,287
1B72:  MOVFF  26A,286
1B76:  MOVFF  269,285
1B7A:  CLRF   x8C
1B7C:  CLRF   x8B
1B7E:  CLRF   x8A
1B80:  MOVLW  7F
1B82:  MOVWF  x89
1B84:  MOVLB  0
1B86:  RCALL  13AA
1B88:  MOVFF  03,284
1B8C:  MOVFF  02,283
1B90:  MOVFF  01,282
1B94:  MOVFF  00,281
1B98:  MOVFF  03,288
1B9C:  MOVFF  02,287
1BA0:  MOVFF  01,286
1BA4:  MOVFF  00,285
1BA8:  MOVLW  DB
1BAA:  MOVLB  2
1BAC:  MOVWF  x8C
1BAE:  MOVLW  0F
1BB0:  MOVWF  x8B
1BB2:  MOVLW  49
1BB4:  MOVWF  x8A
1BB6:  MOVLW  7F
1BB8:  MOVWF  x89
1BBA:  MOVLB  0
1BBC:  RCALL  16E0
1BBE:  MOVFF  03,262
1BC2:  MOVFF  02,261
1BC6:  MOVFF  01,260
1BCA:  MOVFF  00,25F
.................... 
....................    y = 1.0;
1BCE:  MOVLB  2
1BD0:  CLRF   x5E
1BD2:  CLRF   x5D
1BD4:  CLRF   x5C
1BD6:  MOVLW  7F
1BD8:  MOVWF  x5B
....................    t = t * t;
1BDA:  MOVFF  262,288
1BDE:  MOVFF  261,287
1BE2:  MOVFF  260,286
1BE6:  MOVFF  25F,285
1BEA:  MOVFF  262,28C
1BEE:  MOVFF  261,28B
1BF2:  MOVFF  260,28A
1BF6:  MOVFF  25F,289
1BFA:  MOVLB  0
1BFC:  RCALL  16E0
1BFE:  MOVFF  03,262
1C02:  MOVFF  02,261
1C06:  MOVFF  01,260
1C0A:  MOVFF  00,25F
....................    for (i = 0; i <= 4; i++)
1C0E:  MOVLB  2
1C10:  CLRF   x68
1C12:  MOVF   x68,W
1C14:  SUBLW  04
1C16:  BNC   1CD0
....................    {
....................       t2 = t2 * t;
1C18:  MOVFF  266,288
1C1C:  MOVFF  265,287
1C20:  MOVFF  264,286
1C24:  MOVFF  263,285
1C28:  MOVFF  262,28C
1C2C:  MOVFF  261,28B
1C30:  MOVFF  260,28A
1C34:  MOVFF  25F,289
1C38:  MOVLB  0
1C3A:  RCALL  16E0
1C3C:  MOVFF  03,266
1C40:  MOVFF  02,265
1C44:  MOVFF  01,264
1C48:  MOVFF  00,263
....................       y = y + p[i] * t2;
1C4C:  MOVLB  2
1C4E:  MOVF   x68,W
1C50:  MULLW  04
1C52:  MOVF   FF3,W
1C54:  CLRF   03
1C56:  ADDLW  6D
1C58:  MOVWF  FE9
1C5A:  MOVLW  02
1C5C:  ADDWFC 03,W
1C5E:  MOVWF  FEA
1C60:  MOVFF  FEF,285
1C64:  MOVFF  FEC,286
1C68:  MOVFF  FEC,287
1C6C:  MOVFF  FEC,288
1C70:  MOVFF  266,28C
1C74:  MOVFF  265,28B
1C78:  MOVFF  264,28A
1C7C:  MOVFF  263,289
1C80:  MOVLB  0
1C82:  RCALL  16E0
1C84:  MOVFF  FEA,282
1C88:  MOVFF  FE9,281
1C8C:  BCF    FD8.1
1C8E:  MOVFF  25E,288
1C92:  MOVFF  25D,287
1C96:  MOVFF  25C,286
1C9A:  MOVFF  25B,285
1C9E:  MOVFF  03,28C
1CA2:  MOVFF  02,28B
1CA6:  MOVFF  01,28A
1CAA:  MOVFF  00,289
1CAE:  CALL   13AA
1CB2:  MOVFF  282,FEA
1CB6:  MOVFF  281,FE9
1CBA:  MOVFF  03,25E
1CBE:  MOVFF  02,25D
1CC2:  MOVFF  01,25C
1CC6:  MOVFF  00,25B
1CCA:  MOVLB  2
1CCC:  INCF   x68,F
1CCE:  BRA    1C12
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
1CD0:  MOVF   x67,W
1CD2:  SUBLW  02
1CD4:  BZ    1CDA
1CD6:  DECFSZ x67,W
1CD8:  BRA    1CE0
....................       y = -y;  // correct sign
1CDA:  MOVF   x5C,W
1CDC:  XORLW  80
1CDE:  MOVWF  x5C
.................... 
....................    return (y);
1CE0:  MOVFF  25B,00
1CE4:  MOVFF  25C,01
1CE8:  MOVFF  25D,02
1CEC:  MOVFF  25E,03
1CF0:  MOVLB  0
1CF2:  RETURN 0
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
1CF4:  BSF    FD8.1
1CF6:  MOVFF  252,288
1CFA:  MOVFF  251,287
1CFE:  MOVFF  250,286
1D02:  MOVFF  24F,285
1D06:  MOVLW  DB
1D08:  MOVLB  2
1D0A:  MOVWF  x8C
1D0C:  MOVLW  0F
1D0E:  MOVWF  x8B
1D10:  MOVLW  49
1D12:  MOVWF  x8A
1D14:  MOVLW  7F
1D16:  MOVWF  x89
1D18:  MOVLB  0
1D1A:  CALL   13AA
1D1E:  MOVFF  03,256
1D22:  MOVFF  02,255
1D26:  MOVFF  01,254
1D2A:  MOVFF  00,253
1D2E:  MOVFF  03,25A
1D32:  MOVFF  02,259
1D36:  MOVFF  01,258
1D3A:  MOVFF  00,257
1D3E:  RCALL  197E
1D40:  GOTO   3442 (RETURN)
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... #include <stdlibm.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... /*********************************************************************/
.................... #ifndef _STDLIBM
.................... #define _STDLIBM
.................... 
.................... /* Memory Management Functions*/
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #if defined(__PCB__)
.................... typedef struct nodet {
....................    unsigned int8 size;
....................    unsigned int8 next; }node_t;
.................... #elif defined(__PCM__)
.................... typedef struct nodet {
....................    unsigned int8 size;
....................    unsigned int16 next; }node_t;
.................... #elif defined(__PCH__)
.................... typedef struct nodet {
....................    unsigned int16 size;
....................    unsigned int16 next; }node_t;
.................... #elif defined(__PCD__)
.................... typedef struct nodet {
....................    unsigned int16 size;
....................    unsigned int16 next; }node_t;
.................... #endif
.................... 
.................... #if !defined(STDLIBM_MANUAL_DYNAMIC_MEMORY)
....................    #USE DYNAMIC_MEMORY
.................... #endif
.................... 
.................... #ifndef debug_stdlibm
....................    #define debug_stdlibm(s)
.................... #else
....................    #define __DO_DEBUG_STDLIBM
....................    
....................    char g_DebugStdlibmStr[50];
....................    
....................    #if defined(__PCD__)
....................       #if (defined(__PIC24E__)||defined(__dsPIC33E__))
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x800)) || bit_test(x, 0))
....................       #else
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x1000)) || bit_test(x, 0))
....................       #endif
....................    #else
....................       #define INVALID_MEMORY_LOCATION(x) (x >= getenv("RAM"))
....................    #endif
.................... #endif
.................... 
.................... #if defined(STDLIBM_TRACK_WORST_CASE)
....................    static size_t _g_StdlibmCurrentBytesUsed = 0;
....................    static size_t _g_StdlibmWorstCaseBytesUsed = 0;
....................    
....................    #define _STDLIBM_TRACK_WORST_INC(_x) \
....................       _g_StdlibmCurrentBytesUsed += _x;   \
....................       if (_g_StdlibmCurrentBytesUsed > _g_StdlibmWorstCaseBytesUsed) \
....................          _g_StdlibmWorstCaseBytesUsed = _g_StdlibmCurrentBytesUsed
....................    
....................    #define _STDLIBM_TRACK_WORST_DEC(_x) _g_StdlibmCurrentBytesUsed-=_x
.................... #else
....................    #define _STDLIBM_TRACK_WORST_INC(_x)
....................    #define _STDLIBM_TRACK_WORST_DEC(_x)
.................... #endif
.................... 
.................... #include <memmgmt.c>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #if defined(__PCH__)
....................  #define _MEMMGMT_CSIZE 32768
....................  #define _MEMMGMT_POS 15
.................... #elif defined(__PCD__)
....................    #define _MEMMGMT_CSIZE 32768
....................    #define _MEMMGMT_POS 15
.................... #else
....................    #define _MEMMGMT_CSIZE 127
....................    #define _MEMMGMT_POS 7
.................... #endif
.................... 
.................... node_t * create_node(unsigned int16 size, node_t *ptr) // create node at given location
.................... {
....................    node_t *result;
....................    result =ptr;
....................    result->size=size;
....................    result->next = NULL;
....................    return result;
.................... }
.................... void update_node(node_t *node, unsigned int16 size) // update the size of given node
.................... {
....................    node->size=size;
.................... }
.................... 
.................... /* Insert node immediately after place */ //old,new
.................... void insert_node_after(node_t *place, node_t *node)// place the node after another given node
.................... {
....................     if (place->next==NULL)
....................        node->next= NULL;
....................     else
....................        node->next=place->next;
....................     place->next=node;
.................... }
.................... 
.................... /////////////////////////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... void remove_node(node_t *node) {// remove the given node from the memlist
....................    node_t *ptr;
....................    for(ptr=__DYNAMIC_HEAD;ptr->next!=node;ptr=ptr->next);
....................    ptr->next=node->next;
....................    node=NULL;
.................... }
.................... 
.................... /////////////////////////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... #if defined(__DO_DEBUG_STDLIBM)
.................... void print_list() { // print the current memlist
....................     node_t *node;
....................     debug_stdlibm("\r\nThe list is \n\r");
....................     for(node = __DYNAMIC_HEAD; node != NULL; node = node->next)
....................     {
....................         sprintf(g_DebugStdlibmStr, "H:0x%lx S:0x%lx N:0x%lx\n\r", node, node->size, node->next);
....................         debug_stdlibm(g_DebugStdlibmStr);
....................         if (INVALID_MEMORY_LOCATION(node->next))
....................         {
....................            debug_stdlibm("Breaking because of invalid next node\r\n");
....................            break;
....................         }   
....................     }
....................     sprintf(g_DebugStdlibmStr, "size of node_t %u\r\n",sizeof(node_t));
....................     debug_stdlibm(g_DebugStdlibmStr);
.................... }
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... void traverse()
.................... {
....................    node_t *node,*temp;
....................    unsigned int16 nsize,nextsize;
....................    node=__DYNAMIC_HEAD;
....................    while(node!=NULL)
....................    {
....................      #if defined(__DO_DEBUG_STDLIBM)
....................       if (INVALID_MEMORY_LOCATION(node))
....................       {
....................          sprintf(g_DebugStdlibmStr, "traverse() invalid node (0x%LX)\r\n", node);
....................          debug_stdlibm(g_DebugStdlibmStr);
....................          break;
....................       }   
....................      #endif
....................      if(!bit_test(node->size,_MEMMGMT_POS))// node free
....................       {
....................          nsize=node->size;
....................          temp=(unsigned int16)node->next;
....................         #if defined(__DO_DEBUG_STDLIBM)
....................          if (INVALID_MEMORY_LOCATION(temp))
....................          {
....................             sprintf(g_DebugStdlibmStr, "traverse() invalid temp (0x%LX)\r\n", node);
....................             debug_stdlibm(g_DebugStdlibmStr);
....................             break;
....................          }
....................         #endif
....................          if(!bit_test(temp->size,_MEMMGMT_POS)&& (temp==((unsigned int16)node+nsize+sizeof(node_t))))//next node free and consecutive, so combine
....................          {
....................             nextsize=temp->size;
....................             nsize+=nextsize+sizeof(node_t);
....................             remove_node(temp);
....................             update_node(node,nsize);
....................          }
....................          else
....................          node=node->next;
....................       }
....................       else
....................       node=node->next;
....................    }
.................... }
.................... 
.................... char *malloc(size_t size)
.................... {
....................    node_t *node,*new;
....................    unsigned int16 nsize;
....................    #if defined(__PCD__)
....................    if (size % 2)
....................       size++;
....................    #endif
....................    node=__DYNAMIC_HEAD;
....................    
....................   #if defined(__DO_DEBUG_STDLIBM)
....................    sprintf(g_DebugStdlibmStr, "malloc() size=%lu ", size);
....................    debug_stdlibm(g_DebugStdlibmStr);
....................   #endif
....................         
....................    while(node!=NULL) // chk until end of memlist
....................    {
....................      #if defined(__DO_DEBUG_STDLIBM)
....................       if (INVALID_MEMORY_LOCATION(node))
....................       {
....................          sprintf(g_DebugStdlibmStr, " invalid node (0x%LX)\r\n", node);
....................          debug_stdlibm(g_DebugStdlibmStr);
....................          print_list();
....................          return(0);
....................       }
....................      #endif
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=size) // node is free and > = req size
....................       {
....................          nsize=node->size;    //nsize = size of the node that "node" being pointed at
....................          if(nsize>size +sizeof(node_t)) //node > req size, so split and add new node to memlist
....................          {
....................             new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size);
....................             insert_node_after(node,new);
....................             update_node(node,size+_MEMMGMT_CSIZE);
....................          }
....................          else//not enough space for new node so use original size
....................          update_node(node,nsize+_MEMMGMT_CSIZE);
....................          //end if
....................          break;
....................       }//end if
....................       node=node->next;
....................    }//end while
....................    if(node==NULL)// reached end without finding an appropriate node
....................    {
....................       debug_stdlibm("Not enough memory for mallocation\r\n");
....................       return NULL;
....................    }
....................    else
....................    {
....................      #if defined(__DO_DEBUG_STDLIBM)
....................       sprintf(g_DebugStdlibmStr, "%LX\r\n", (char *)node+sizeof(node_t));
....................       debug_stdlibm(g_DebugStdlibmStr);
....................      #endif
....................       _STDLIBM_TRACK_WORST_INC(size);
....................       return (char *)node+sizeof(node_t); // return pounsigned int8er to allocated space
....................    }
.................... }
.................... 
.................... char *calloc(size_t nmemb,size_t size)
.................... {
....................    node_t *node,*new;
....................    unsigned int16 nsize,resize;
....................    node=__DYNAMIC_HEAD;
....................    resize=nmemb*size;
....................    #if defined(__PCD__)
....................    if(resize%2)
....................       resize++;
....................    #endif
....................    while(node!=NULL) // chk until end of memlist
....................    {
....................      #if defined(__DO_DEBUG_STDLIBM)
....................       if (INVALID_MEMORY_LOCATION(node))
....................       {
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node);
....................          debug_stdlibm(g_DebugStdlibmStr);
....................          print_list();
....................          return(0);
....................       }
....................      #endif
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=resize)// node is free and > = req size
....................       {
....................          nsize=node->size;
....................          if(nsize>resize+sizeof(node_t))//node > req size, so split and add new node to memlist
....................          {
....................             new=create_node(nsize-resize-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+resize);
....................             insert_node_after(node,new);
....................             update_node(node,resize+_MEMMGMT_CSIZE);
....................          }
....................          else//not enough space for new node so use original size
....................          update_node(node,nsize+_MEMMGMT_CSIZE);
....................          //end if
....................          break;
....................       }//end if
....................       node=node->next;
....................    }//end while
....................    if(node==NULL)// reached end without finding an appropriate node
....................    {
....................       debug_stdlibm("Not enough memory for callocation\r\n");
....................       return NULL;
....................    }
....................    else
....................    {
....................       memset((unsigned int16)node+sizeof(node_t),0,resize);// initialize to 0
....................       _STDLIBM_TRACK_WORST_INC(resize);
....................       return (char *)(unsigned int16)node+sizeof(node_t);// return pounsigned int8er to allocated space
....................    }
.................... }
.................... void free( void * ptr)
.................... {
....................    node_t *node;
....................    unsigned int16 nsize;
.................... 
....................   #if defined(__DO_DEBUG_STDLIBM)
....................    sprintf(g_DebugStdlibmStr, "free() 0x%LX\r\n", ptr);
....................    debug_stdlibm(g_DebugStdlibmStr);
....................   #endif
.................... 
....................    if(ptr==NULL) // not a valid pounsigned int8er
....................       return;
....................    else
....................    {
....................       node=ptr-sizeof(node_t);
....................       if(bit_test(node->size,_MEMMGMT_POS))// node occupied
....................       {
....................          nsize=node->size-_MEMMGMT_CSIZE;
....................          update_node(node,nsize);
....................          ptr=NULL;
....................          _STDLIBM_TRACK_WORST_DEC(nsize);
....................       }
....................       else // wrong input, return
....................       {
....................          ptr=NULL;
....................          return;
....................       }
....................    }
....................    traverse();
.................... }
.................... 
.................... char *realloc(void *ptr,size_t size)
.................... {
....................    node_t *node,*new,*temp;
....................    unsigned int16 nsize,nextsize;
....................    char *newptr;
....................    #if defined(__PCD__)
....................    if(size %2)
....................       size++;
....................    #endif
....................    if(ptr==NULL)// null pounsigned int8er, so malloc the req memory
....................       return(malloc(size));
....................    else if(size==0)
....................    {
....................       free(ptr);
....................       return(NULL);
....................    }
....................    else
....................    {
....................       node=ptr-sizeof(node_t);
....................       if(bit_test(node->size,_MEMMGMT_POS))// chk if valid pounsigned int8er
....................       {
....................          nsize=node->size-_MEMMGMT_CSIZE;
....................          temp=(unsigned int16)node->next;
....................          if(nsize>size)// block > req size
....................          {
....................        
....................                if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive
....................                {
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block
....................                   nextsize=temp->size;
....................                   remove_node(temp);
....................                   new=create_node(nextsize+(nsize-size),(unsigned int16)node+size+sizeof(node_t));
....................                   insert_node_after(node,new);
....................                   _STDLIBM_TRACK_WORST_DEC(nsize);
....................                   _STDLIBM_TRACK_WORST_INC(size);
....................                }
....................                else if (nsize>size +sizeof(node_t))//node > req size, so split and add new node to memlist
....................                {
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block
....................                   new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size);
....................                   insert_node_after(node,new);
....................                   _STDLIBM_TRACK_WORST_DEC(nsize);
....................                   _STDLIBM_TRACK_WORST_INC(size);
....................                }
....................                else//not enough space for new node so use original size
....................                update_node(node,nsize+_MEMMGMT_CSIZE); // update block
.................... 
....................          }
....................          else // block < req size
....................          {
....................             if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive
....................             {
....................                nextsize=temp->size;
....................                if(nextsize>=size-nsize) // next block >=difference
....................                {
....................                   if(nextsize>size-nsize+sizeof(node_t))//next node > req size, so split and add new node to memlist
....................                   {
....................                       update_node(node,size+_MEMMGMT_CSIZE);// update block
....................                       remove_node(temp);
....................                       new=create_node(nextsize-(size-nsize),(unsigned int16)node+size+sizeof(node_t));
....................                       insert_node_after(node,new);
....................                      _STDLIBM_TRACK_WORST_DEC(nsize);
....................                      _STDLIBM_TRACK_WORST_INC(size);
....................                   }
....................                   else//not enough space for new node in next node, so use original size
....................                   {
....................                       update_node(node,nsize+nextsize+_MEMMGMT_CSIZE);// update block
....................                       remove_node(temp);
....................                   }
....................                }
....................                else  //next block free but too small for new size
....................                {
....................                   newptr = malloc(size);  //use malloc to find new block
....................                   if(newptr == NULL)
....................                      return(NULL);        //return NULL if malloc was unable to find new block
....................                    
....................                   memcpy(newptr, ptr, nsize);   //copy original data to new block
....................                   free(ptr);                    //free original block
....................                   return(newptr);               //return new pointer
....................                }
....................             }
....................             else  //next block not free
....................             {
....................                newptr = malloc(size);  //use malloc to find new block
....................                if(newptr == NULL)      
....................                   return(NULL);        //return NULL if malloc was unable to find new block
....................                
....................                memcpy(newptr, ptr, nsize);   //copy original data to new block
....................                free(ptr);                    //free original block
....................                return(newptr);               //return new pointer
....................             }
....................          }
....................          return (char *)node+sizeof(node_t); // return pounsigned int8er to the reallocated block
....................       }
....................       else // not allocated use malloc
....................       {
....................          return(malloc(size));
....................       }
....................    }
....................  }
....................  
.................... typedef struct
.................... {
....................    size_t bytesUsed;
....................    size_t largestUsedSeg;
....................    int segmentsUsed;
....................    size_t bytesFree;
....................    size_t largestFreeSeg;
....................    int segmentsFree;
....................   #if defined(STDLIBM_TRACK_WORST_CASE)
....................    size_t worstCaseBytesUsed;
....................   #endif
.................... } heap_status_t;
.................... 
.................... void GetHeapStatus(heap_status_t *pHeapStatus)
.................... {
....................    heap_status_t status;
....................    node_t *node;
....................    unsigned int16 nsize;
....................    
....................    node=__DYNAMIC_HEAD;
....................    
....................    memset(&status, 0, sizeof(status));
.................... 
....................    while(node!=NULL)
....................    {
....................       nsize = node->size;
....................       node = node->next;
....................       
....................       if(!bit_test(nsize, _MEMMGMT_POS)) // node free
....................       {
....................          status.bytesFree += nsize;
....................          
....................          status.segmentsFree++;
....................          
....................          if (nsize > status.largestFreeSeg)
....................          {
....................             status.largestFreeSeg = nsize;
....................          }
....................       }
....................       else
....................       {
....................          bit_clear(nsize, _MEMMGMT_POS);
....................          
....................          status.bytesUsed += nsize;
....................          
....................          status.segmentsUsed++;
....................          
....................          if (nsize > status.largestUsedSeg)
....................          {
....................             status.largestUsedSeg = nsize;
....................          }
....................       }
....................    }
.................... 
....................   #if defined(STDLIBM_TRACK_WORST_CASE)
....................    status.worstCaseBytesUsed = _g_StdlibmWorstCaseBytesUsed;
....................   #endif
.................... 
....................    memcpy(pHeapStatus, &status, sizeof(heap_status_t));
.................... }
.................... #ENDIF
.................... 
.................... 
.................... #include "setup_disp.h"
.................... 
.................... const BYTE TEXT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // !
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // "
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // #
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // %
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // &
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // '
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // (
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // )
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // *
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // +
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // ,
....................                          0x08, 0x08, 0x08, 0x08, 0x08, // -
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // .
....................                          0x20, 0x10, 0x08, 0x04, 0x02, // /
....................                          0x3E, 0x51, 0x49, 0x45, 0x3E, // 0
....................                          0x04, 0x02, 0x7F, 0x00, 0x00, // 1
....................                          0x42, 0x61, 0x51, 0x49, 0x46, // 2
....................                          0x22, 0x41, 0x49, 0x49, 0x36, // 3
....................                          0x18, 0x14, 0x12, 0x7F, 0x10, // 4
....................                          0x27, 0x45, 0x45, 0x45, 0x39, // 5
....................                          0x3E, 0x49, 0x49, 0x49, 0x32, // 6
....................                          0x01, 0x01, 0x71, 0x09, 0x07, // 7
....................                          0x36, 0x49, 0x49, 0x49, 0x36, // 8
....................                          0x26, 0x49, 0x49, 0x49, 0x3E, // 9
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // :
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ;
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // <
....................                          0x14, 0x14, 0x14, 0x14, 0x14, // =
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // >
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ?
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @
....................                          0x7E, 0x09, 0x09, 0x09, 0x7E, // A
....................                          0x7F, 0x49, 0x49, 0x49, 0x36, // B
....................                          0x3E, 0x41, 0x41, 0x41, 0x22, // C
....................                          0x7F, 0x41, 0x41, 0x41, 0x3E, // D
....................                          0x7F, 0x49, 0x49, 0x49, 0x41, // E
....................                          0x7F, 0x09, 0x09, 0x09, 0x01, // F
....................                          0x3E, 0x41, 0x41, 0x49, 0x3A, // G
....................                          0x7F, 0x08, 0x08, 0x08, 0x7F, // H
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I
....................                          0x30, 0x40, 0x40, 0x40, 0x3F, // J
....................                          0x7F, 0x08, 0x14, 0x22, 0x41, // K
....................                          0x7F, 0x40, 0x40, 0x40, 0x40, // L
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N
....................                          0x3E, 0x41, 0x41, 0x41, 0x3E, // O
....................                          0x7F, 0x09, 0x09, 0x09, 0x06, // P
....................                          0x1E, 0x21, 0x21, 0x21, 0x5E, // Q
....................                          0x7F, 0x09, 0x09, 0x09, 0x76};// R
.................... 
.................... const BYTE TEXT2[44][5]={0x26, 0x49, 0x49, 0x49, 0x32, // S
....................                          0x01, 0x01, 0x7F, 0x01, 0x01, // T
....................                          0x3F, 0x40, 0x40, 0x40, 0x3F, // U
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y
....................                          0x61, 0x51, 0x49, 0x45, 0x43, // Z
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ]
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^
....................                          0x40, 0x40, 0x40, 0x40, 0x40, // _
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // `
....................                          0x20, 0x54, 0x54, 0x54, 0x78, // a
....................                          0x7F, 0x44, 0x44, 0x44, 0x38, // b
....................                          0x38, 0x44, 0x44, 0x44, 0x44, // c
....................                          0x38, 0x44, 0x44, 0x44, 0x7F, // d
....................                          0x38, 0x54, 0x54, 0x54, 0x18, // e
....................                          0x04, 0x04, 0x7E, 0x05, 0x05, // f
....................                          0x08, 0x54, 0x54, 0x54, 0x3C, // g
....................                          0x7F, 0x08, 0x04, 0x04, 0x78, // h
....................                          0x00, 0x44, 0x7D, 0x40, 0x00, // i
....................                          0x20, 0x40, 0x44, 0x3D, 0x00, // j
....................                          0x7F, 0x10, 0x28, 0x44, 0x00, // k
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m
....................                          0x7C, 0x08, 0x04, 0x04, 0x78, // n
....................                          0x38, 0x44, 0x44, 0x44, 0x38, // o
....................                          0x7C, 0x14, 0x14, 0x14, 0x08, // p
....................                          0x08, 0x14, 0x14, 0x14, 0x7C, // q
....................                          0x00, 0x7C, 0x08, 0x04, 0x04, // r
....................                          0x48, 0x54, 0x54, 0x54, 0x20, // s
....................                          0x04, 0x04, 0x3F, 0x44, 0x44, // t
....................                          0x3C, 0x40, 0x40, 0x20, 0x7C, // u
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x
....................                          0x0C, 0x50, 0x50, 0x50, 0x3C, // y
....................                          0x44, 0x64, 0x54, 0x4C, 0x44, // z
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // {
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // |
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // }
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~
.................... 
.................... int personaje[16][16] = {
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0},
....................     {0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0},
....................     {0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0},
....................     {0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0},
....................     {0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0},
....................     {0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0},
....................     {0,0,0,1,1,1,1,0,0,1,1,1,1,0,0,0},
....................     {0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0},
....................     {0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0},
....................     {0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0},
....................     {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},
....................     {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... const int levels[30][20] = {
....................     {0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
....................     {3,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,2,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,2,0,0,1,0,1,0,0,0,0,0,0,1,0,1,0,0},
....................     {0,0,0,0,0,0,0,3,0,0,3,0,3,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
....................     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... 
.................... 
.................... #use rs232(rcv = pin_c7, xmit = pin_c6, baud = 9600, bits = 8, parity = n)
.................... 
.................... // nave
.................... float last_ship_angle_1 = 0;
.................... float ship_angle_1 = 0;
.................... int last_x_pos_1;
.................... int last_y_pos_1;
.................... int x_pos_1 = 64;
.................... int y_pos_1 = 32;
.................... float dx_1 = 0;
.................... float dy_1 = 0;
.................... 
.................... float last_ship_angle_2 = 0;
.................... float ship_angle_2 = 0;
.................... int last_x_pos_2;
.................... int last_y_pos_2;
.................... int x_pos_2 = 64;
.................... int y_pos_2 = 32;
.................... float dx_2 = 0;
.................... float dy_2 = 0;
.................... 
.................... int1 shoot_1 = 1;
.................... int cooldown_1 = 20;
.................... int aiming_1 = 0;
.................... 
.................... int1 shoot_2 = 1;
.................... int cooldown_2 = 20;
.................... int aiming_2 = 0;
.................... 
.................... float last_ship_angle = 0;
.................... float ship_angle = 0;
.................... int last_x_pos;
.................... int last_y_pos;
.................... int x_pos = 64;
.................... int y_pos = 32;
.................... float dx = 0;
.................... float dy = 0;
.................... // bala
.................... int1 bullet = 0;
.................... signed int last_last_bullet_x_pos;
.................... signed int last_last_bullet_y_pos;
.................... signed int last_bullet_x_pos;
.................... signed int last_bullet_y_pos;
.................... signed int16 bullet_x_pos;
.................... signed int16 bullet_y_pos;
.................... float bullet_dx = 0;
.................... float bullet_dy = 0;
.................... const float bullet_speed = 6;
.................... 
.................... int1 bullet_1 = 0;
.................... signed int last_last_bullet_x_pos_1;
.................... signed int last_last_bullet_y_pos_1;
.................... signed int last_bullet_x_pos_1;
.................... signed int last_bullet_y_pos_1;
.................... signed int16 bullet_x_pos_1;
.................... signed int16 bullet_y_pos_1;
.................... float bullet_dx_1 = 0;
.................... float bullet_dy_1 = 0;
.................... int1 bullet_collision_1 = 0;
.................... 
.................... int1 bullet_2 = 0;
.................... signed int last_last_bullet_x_pos_2;
.................... signed int last_last_bullet_y_pos_2;
.................... signed int last_bullet_x_pos_2;
.................... signed int last_bullet_y_pos_2;
.................... signed int16 bullet_x_pos_2;
.................... signed int16 bullet_y_pos_2;
.................... float bullet_dx_2 = 0;
.................... float bullet_dy_2 = 0;
.................... int1 bullet_collision_2 = 0;
.................... // asteroides
.................... 
.................... int last_asteroids_x_pos[20];
.................... int last_asteroids_y_pos[20];
.................... unsigned int asteroids_x_pos[20];
.................... unsigned int asteroids_y_pos[20];
.................... signed int asteroids_dx[20] = {-2, 1, -3, 3, -2, 3, -1, 2, -3, 3, -2, 2, -1, 2, -1, 2, -2, 3, -2, -1};
.................... signed int asteroids_dy[20] = {2, -1, -2, 3, -2, 2, -1, 1, -2, 3, -1, 3, -2, -1, 2, -3, -3, 3, -2, 1};
.................... 
.................... unsigned int level = 0;
.................... unsigned int best_level = 0;
.................... int1 new_level = 1;
.................... unsigned int16 score = 0;
.................... unsigned int16 best_score = 0;
.................... unsigned int16 last_score = 10;
.................... unsigned int last_level = 10;
.................... 
.................... const float internal_angle = (2 * (float)PI) / 3.0f;
.................... // dibujar
.................... void glcd_line(int x1, int y1, int x2, int y2, int1 color);
.................... void draw_triangle(int x, int y, float starting_angle, int1 color);
.................... void glcd_lineTracing(int *xx, int *yy, int n_points, int1 color);
.................... void draw_asteroid(int x, int y, int life, int1 color);
.................... void glcd_text57(int x, int y, char *textptr, int size, int1 color);
.................... void inicio(int sec);
.................... void scores(unsigned int16 scr, unsigned int lvl, int1 color);
.................... void single_menu(int1 play);
.................... int laser_waza(int x, int y);
.................... 
.................... float get_ship_angle();
.................... float get_x_vel();
.................... float get_y_vel();
.................... 
.................... char dataRS232;
.................... 
.................... char mode = 'i';
.................... char mode_inic = 't';
.................... 
.................... int1 flagg = 1;
.................... int1 flag_rec = 0;
.................... 
.................... int current_data = 0;
.................... 
.................... unsigned int p1_pot_x = 125;
.................... unsigned int p1_pot_y = 125;
.................... unsigned int p1_pot_xx = 125;
.................... unsigned int p1_pot_yy = 125;
.................... int1 p1_L = 0;
.................... int1 p1_R = 0;
.................... 
.................... float calc_ang_x(int x, int y);
.................... float calc_ang_y(int x, int y);
.................... 
.................... float get_d(unsigned int pp)
.................... {
....................    return (float)((float)pp - 127.0f) / 30.0f;
*
2232:  MOVLB  2
2234:  CLRF   x86
2236:  MOVFF  24F,285
223A:  MOVLB  0
223C:  CALL   11AE
2240:  MOVFF  03,253
2244:  MOVFF  02,252
2248:  MOVFF  01,251
224C:  MOVFF  00,250
2250:  BSF    FD8.1
2252:  MOVFF  03,288
2256:  MOVFF  02,287
225A:  MOVFF  01,286
225E:  MOVFF  00,285
2262:  MOVLB  2
2264:  CLRF   x8C
2266:  CLRF   x8B
2268:  MOVLW  7E
226A:  MOVWF  x8A
226C:  MOVLW  85
226E:  MOVWF  x89
2270:  MOVLB  0
2272:  CALL   13AA
2276:  MOVFF  03,253
227A:  MOVFF  02,252
227E:  MOVFF  01,251
2282:  MOVFF  00,250
2286:  MOVFF  03,25A
228A:  MOVFF  02,259
228E:  MOVFF  01,258
2292:  MOVFF  00,257
2296:  MOVLB  2
2298:  CLRF   x5E
229A:  CLRF   x5D
229C:  MOVLW  70
229E:  MOVWF  x5C
22A0:  MOVLW  83
22A2:  MOVWF  x5B
22A4:  MOVLB  0
22A6:  CALL   11E4
22AA:  RETURN 0
.................... }
.................... 
.................... unsigned int p2_pot_x = 125;
.................... unsigned int p2_pot_y = 125;
.................... unsigned int p2_pot_xx = 125;
.................... unsigned int p2_pot_yy = 125;
.................... int1 p2_L = 0;
.................... int1 p2_R = 0;
.................... 
.................... #int_rda
.................... void rcv_data()
.................... {
.................... 
....................    dataRS232 = getch();
*
0510:  BTFSS  F9E.5
0512:  BRA    0510
0514:  MOVFF  FAE,20D
0518:  MOVLB  2
.................... 
....................    switch (current_data)
051A:  MOVF   x11,W
051C:  ADDLW  F7
051E:  BC    05AE
0520:  ADDLW  09
0522:  MOVLB  0
0524:  GOTO   05C0
....................    {
....................    case 0:
....................       p1_pot_y = dataRS232; // x
0528:  MOVFF  20D,213
....................       break;
052C:  MOVLB  2
052E:  BRA    05AE
....................    case 1:
....................       p1_pot_x = dataRS232; // y
0530:  MOVFF  20D,212
....................       break;
0534:  MOVLB  2
0536:  BRA    05AE
....................    case 2:
....................       p1_pot_xx = dataRS232;
0538:  MOVFF  20D,214
....................       break;
053C:  MOVLB  2
053E:  BRA    05AE
....................    case 3:
....................       p1_pot_yy = dataRS232;
0540:  MOVFF  20D,215
....................       break;
0544:  MOVLB  2
0546:  BRA    05AE
....................    case 4:
....................       p2_pot_y = dataRS232;
0548:  MOVFF  20D,217
....................       break;
054C:  MOVLB  2
054E:  BRA    05AE
....................    case 5:
....................       p2_pot_x = dataRS232;
0550:  MOVFF  20D,216
....................       break;
0554:  MOVLB  2
0556:  BRA    05AE
....................    case 6:
....................       p2_pot_xx = dataRS232;
0558:  MOVFF  20D,218
....................       break;
055C:  MOVLB  2
055E:  BRA    05AE
....................    case 7:
....................       p2_pot_yy = dataRS232;
0560:  MOVFF  20D,219
....................       break;
0564:  MOVLB  2
0566:  BRA    05AE
....................    case 8:
....................       p1_L = (dataRS232 & 0x01) ? 1 : 0;
0568:  MOVLB  2
056A:  BTFSS  x0D.0
056C:  BRA    0572
056E:  MOVLW  01
0570:  BRA    0574
0572:  MOVLW  00
0574:  BCF    x10.2
0576:  BTFSC  FE8.0
0578:  BSF    x10.2
....................       p1_R = (dataRS232 & 0x02) ? 1 : 0;
057A:  BTFSS  x0D.1
057C:  BRA    0582
057E:  MOVLW  01
0580:  BRA    0584
0582:  MOVLW  00
0584:  BCF    x10.3
0586:  BTFSC  FE8.0
0588:  BSF    x10.3
....................       p2_L = (dataRS232 & 0x04) ? 1 : 0;
058A:  BTFSS  x0D.2
058C:  BRA    0592
058E:  MOVLW  01
0590:  BRA    0594
0592:  MOVLW  00
0594:  BCF    x10.4
0596:  BTFSC  FE8.0
0598:  BSF    x10.4
....................       p2_R = (dataRS232 & 0x08) ? 1 : 0;
059A:  BTFSS  x0D.3
059C:  BRA    05A2
059E:  MOVLW  01
05A0:  BRA    05A4
05A2:  MOVLW  00
05A4:  BCF    x10.5
05A6:  BTFSC  FE8.0
05A8:  BSF    x10.5
....................       break;
05AA:  BRA    05AE
05AC:  MOVLB  2
....................    }
.................... 
....................    current_data++;
05AE:  INCF   x11,F
....................    if (current_data == 9)
05B0:  MOVF   x11,W
05B2:  SUBLW  09
05B4:  BNZ   05B8
....................       current_data = 0;
05B6:  CLRF   x11
05B8:  BCF    F9E.5
05BA:  MOVLB  0
05BC:  GOTO   0060
.................... }
.................... 
.................... void draw_cuadrito(int x, int y, int1 col);
.................... 
.................... void draw_win(int1 w){
....................    if(w){
*
22EA:  MOVLB  2
22EC:  MOVF   x4F,F
22EE:  BZ    236A
....................       glcd_fillScreen(1);
22F0:  MOVLW  01
22F2:  MOVWF  x6E
22F4:  MOVLB  0
22F6:  CALL   0658
....................       char text_asteroids[] = "PLAYER 1 WINS!";
22FA:  MOVLW  50
22FC:  MOVLB  2
22FE:  MOVWF  x50
2300:  MOVLW  4C
2302:  MOVWF  x51
2304:  MOVLW  41
2306:  MOVWF  x52
2308:  MOVLW  59
230A:  MOVWF  x53
230C:  MOVLW  45
230E:  MOVWF  x54
2310:  MOVLW  52
2312:  MOVWF  x55
2314:  MOVLW  20
2316:  MOVWF  x56
2318:  MOVLW  31
231A:  MOVWF  x57
231C:  MOVLW  20
231E:  MOVWF  x58
2320:  MOVLW  57
2322:  MOVWF  x59
2324:  MOVLW  49
2326:  MOVWF  x5A
2328:  MOVLW  4E
232A:  MOVWF  x5B
232C:  MOVLW  53
232E:  MOVWF  x5C
2330:  MOVLW  21
2332:  MOVWF  x5D
2334:  CLRF   x5E
....................       glcd_text57(29, 22, text_asteroids, 1, 0);
2336:  MOVLW  1D
2338:  MOVWF  x75
233A:  MOVLW  16
233C:  MOVWF  x76
233E:  MOVLW  02
2340:  MOVWF  x78
2342:  MOVLW  50
2344:  MOVWF  x77
2346:  MOVLW  01
2348:  MOVWF  x79
234A:  CLRF   x7A
234C:  MOVLB  0
234E:  CALL   08B4
....................       delay_ms(500);
2352:  MOVLW  02
2354:  MOVLB  2
2356:  MOVWF  x6E
2358:  MOVLW  FA
235A:  MOVWF  x6F
235C:  MOVLB  0
235E:  CALL   05EC
2362:  MOVLB  2
2364:  DECFSZ x6E,F
2366:  BRA    2358
....................    }
2368:  BRA    23E2
....................    else{
....................       glcd_fillScreen(1);
236A:  MOVLW  01
236C:  MOVWF  x6E
236E:  MOVLB  0
2370:  CALL   0658
....................       char text_asteroids[] = "PLAYER 2 WINS!";
2374:  MOVLW  50
2376:  MOVLB  2
2378:  MOVWF  x5F
237A:  MOVLW  4C
237C:  MOVWF  x60
237E:  MOVLW  41
2380:  MOVWF  x61
2382:  MOVLW  59
2384:  MOVWF  x62
2386:  MOVLW  45
2388:  MOVWF  x63
238A:  MOVLW  52
238C:  MOVWF  x64
238E:  MOVLW  20
2390:  MOVWF  x65
2392:  MOVLW  32
2394:  MOVWF  x66
2396:  MOVLW  20
2398:  MOVWF  x67
239A:  MOVLW  57
239C:  MOVWF  x68
239E:  MOVLW  49
23A0:  MOVWF  x69
23A2:  MOVLW  4E
23A4:  MOVWF  x6A
23A6:  MOVLW  53
23A8:  MOVWF  x6B
23AA:  MOVLW  21
23AC:  MOVWF  x6C
23AE:  CLRF   x6D
....................       glcd_text57(29, 22, text_asteroids, 1, 0);
23B0:  MOVLW  1D
23B2:  MOVWF  x75
23B4:  MOVLW  16
23B6:  MOVWF  x76
23B8:  MOVLW  02
23BA:  MOVWF  x78
23BC:  MOVLW  5F
23BE:  MOVWF  x77
23C0:  MOVLW  01
23C2:  MOVWF  x79
23C4:  CLRF   x7A
23C6:  MOVLB  0
23C8:  CALL   08B4
....................       delay_ms(500);
23CC:  MOVLW  02
23CE:  MOVLB  2
23D0:  MOVWF  x6E
23D2:  MOVLW  FA
23D4:  MOVWF  x6F
23D6:  MOVLB  0
23D8:  CALL   05EC
23DC:  MOVLB  2
23DE:  DECFSZ x6E,F
23E0:  BRA    23D2
....................    }
23E2:  MOVLB  0
23E4:  RETURN 0
.................... }
.................... 
.................... void restart_screen()
.................... {
....................    glcd_fillScreen(0);
*
1130:  MOVLB  2
1132:  CLRF   x6E
1134:  MOVLB  0
1136:  CALL   0658
....................    char text_asteroids[] = "Presiona para restart";
113A:  MOVLW  50
113C:  MOVLB  2
113E:  MOVWF  x4F
1140:  MOVLW  72
1142:  MOVWF  x50
1144:  MOVLW  65
1146:  MOVWF  x51
1148:  MOVLW  73
114A:  MOVWF  x52
114C:  MOVLW  69
114E:  MOVWF  x53
1150:  MOVLW  6F
1152:  MOVWF  x54
1154:  MOVLW  6E
1156:  MOVWF  x55
1158:  MOVLW  61
115A:  MOVWF  x56
115C:  MOVLW  20
115E:  MOVWF  x57
1160:  MOVLW  70
1162:  MOVWF  x58
1164:  MOVLW  61
1166:  MOVWF  x59
1168:  MOVLW  72
116A:  MOVWF  x5A
116C:  MOVLW  61
116E:  MOVWF  x5B
1170:  MOVLW  20
1172:  MOVWF  x5C
1174:  MOVLW  72
1176:  MOVWF  x5D
1178:  MOVLW  65
117A:  MOVWF  x5E
117C:  MOVLW  73
117E:  MOVWF  x5F
1180:  MOVLW  74
1182:  MOVWF  x60
1184:  MOVLW  61
1186:  MOVWF  x61
1188:  MOVLW  72
118A:  MOVWF  x62
118C:  MOVLW  74
118E:  MOVWF  x63
1190:  CLRF   x64
....................    glcd_text57(0, 0, text_asteroids, 1, 1);
1192:  CLRF   x75
1194:  CLRF   x76
1196:  MOVLW  02
1198:  MOVWF  x78
119A:  MOVLW  4F
119C:  MOVWF  x77
119E:  MOVLW  01
11A0:  MOVWF  x79
11A2:  MOVWF  x7A
11A4:  MOVLB  0
11A6:  CALL   08B4
11AA:  GOTO   29C2 (RETURN)
.................... }
.................... 
.................... void main()
*
2578:  CLRF   FF8
257A:  BCF    FD0.7
257C:  BSF    07.7
257E:  BSF    FB8.3
2580:  MOVLW  08
2582:  MOVWF  FAF
2584:  MOVLW  02
2586:  MOVWF  FB0
2588:  MOVLW  A6
258A:  MOVWF  FAC
258C:  MOVLW  90
258E:  MOVWF  FAB
2590:  MOVLB  1
2592:  CLRF   x1E
2594:  CLRF   x1D
2596:  CLRF   x1C
2598:  CLRF   x1B
259A:  CLRF   x22
259C:  CLRF   x21
259E:  CLRF   x20
25A0:  CLRF   x1F
25A2:  MOVLW  40
25A4:  MOVWF  x25
25A6:  MOVLW  20
25A8:  MOVWF  x26
25AA:  CLRF   x2A
25AC:  CLRF   x29
25AE:  CLRF   x28
25B0:  CLRF   x27
25B2:  CLRF   x2E
25B4:  CLRF   x2D
25B6:  CLRF   x2C
25B8:  CLRF   x2B
25BA:  CLRF   x32
25BC:  CLRF   x31
25BE:  CLRF   x30
25C0:  CLRF   x2F
25C2:  CLRF   x36
25C4:  CLRF   x35
25C6:  CLRF   x34
25C8:  CLRF   x33
25CA:  MOVLW  40
25CC:  MOVWF  x39
25CE:  MOVLW  20
25D0:  MOVWF  x3A
25D2:  CLRF   x3E
25D4:  CLRF   x3D
25D6:  CLRF   x3C
25D8:  CLRF   x3B
25DA:  CLRF   x42
25DC:  CLRF   x41
25DE:  CLRF   x40
25E0:  CLRF   x3F
25E2:  BSF    x43.0
25E4:  MOVLW  14
25E6:  MOVWF  x44
25E8:  CLRF   x45
25EA:  BSF    x43.1
25EC:  MOVWF  x46
25EE:  CLRF   x47
25F0:  CLRF   x4B
25F2:  CLRF   x4A
25F4:  CLRF   x49
25F6:  CLRF   x48
25F8:  CLRF   x4F
25FA:  CLRF   x4E
25FC:  CLRF   x4D
25FE:  CLRF   x4C
2600:  MOVLW  40
2602:  MOVWF  x52
2604:  MOVLW  20
2606:  MOVWF  x53
2608:  CLRF   x57
260A:  CLRF   x56
260C:  CLRF   x55
260E:  CLRF   x54
2610:  CLRF   x5B
2612:  CLRF   x5A
2614:  CLRF   x59
2616:  CLRF   x58
2618:  BCF    x43.2
261A:  CLRF   x67
261C:  CLRF   x66
261E:  CLRF   x65
2620:  CLRF   x64
2622:  CLRF   x6B
2624:  CLRF   x6A
2626:  CLRF   x69
2628:  CLRF   x68
262A:  BCF    x43.3
262C:  CLRF   x77
262E:  CLRF   x76
2630:  CLRF   x75
2632:  CLRF   x74
2634:  CLRF   x7B
2636:  CLRF   x7A
2638:  CLRF   x79
263A:  CLRF   x78
263C:  BCF    x43.4
263E:  BCF    x43.5
2640:  CLRF   x87
2642:  CLRF   x86
2644:  CLRF   x85
2646:  CLRF   x84
2648:  CLRF   x8B
264A:  CLRF   x8A
264C:  CLRF   x89
264E:  CLRF   x88
2650:  BCF    x43.6
2652:  MOVLB  2
2654:  CLRF   x04
2656:  CLRF   x05
2658:  MOVLB  1
265A:  BSF    x43.7
265C:  MOVLB  2
265E:  CLRF   x07
2660:  CLRF   x06
2662:  CLRF   x09
2664:  CLRF   x08
2666:  CLRF   x0B
2668:  MOVLW  0A
266A:  MOVWF  x0A
266C:  MOVWF  x0C
266E:  MOVLW  69
2670:  MOVWF  x0E
2672:  MOVLW  74
2674:  MOVWF  x0F
2676:  BSF    x10.0
2678:  BCF    x10.1
267A:  CLRF   x11
267C:  MOVLW  7D
267E:  MOVWF  x12
2680:  MOVWF  x13
2682:  MOVWF  x14
2684:  MOVWF  x15
2686:  BCF    x10.2
2688:  BCF    x10.3
268A:  MOVWF  x16
268C:  MOVWF  x17
268E:  MOVWF  x18
2690:  MOVWF  x19
2692:  BCF    x10.4
2694:  BCF    x10.5
2696:  CLRF   x1B
2698:  CLRF   x1A
269A:  MOVF   FC1,W
269C:  ANDLW  C0
269E:  IORLW  0F
26A0:  MOVWF  FC1
26A2:  MOVLW  07
26A4:  MOVWF  FB4
26A6:  MOVLW  02
26A8:  MOVWF  1A
26AA:  MOVLW  95
26AC:  MOVWF  19
26AE:  MOVLW  05
26B0:  MOVWF  x96
26B2:  MOVLW  67
26B4:  MOVWF  x95
26B6:  CLRF   x98
26B8:  CLRF   x97
26BA:  MOVLB  0
26BC:  BRA    274E
26BE:  DATA 16,40
26C0:  DATA 1B,00
26C2:  DATA 04,C0
26C4:  DATA 01,0B
26C6:  DATA C0,00
26C8:  DATA 06,C0
26CA:  DATA 01,09
26CC:  DATA C0,00
26CE:  DATA 08,C0
26D0:  DATA 01,08
26D2:  DATA C0,00
26D4:  DATA 08,C0
26D6:  DATA 01,09
26D8:  DATA C0,00
26DA:  DATA 06,C0
26DC:  DATA 01,0B
26DE:  DATA C0,00
26E0:  DATA 04,C0
26E2:  DATA 01,1A
26E4:  DATA C0,00
26E6:  DATA 02,80
26E8:  DATA 01,01
26EA:  DATA 04,C0
26EC:  DATA 00,02
26EE:  DATA 80,01
26F0:  DATA 01,07
26F2:  DATA C0,00
26F4:  DATA 04,C0
26F6:  DATA 01,02
26F8:  DATA 80,00
26FA:  DATA 00,04
26FC:  DATA C0,01
26FE:  DATA 06,C0
2700:  DATA 00,0A
2702:  DATA C0,01
2704:  DATA 05,C0
2706:  DATA 00,0C
2708:  DATA C0,01
270A:  DATA 04,C0
270C:  DATA 00,0C
270E:  DATA C0,01
2710:  DATA 03,80
2712:  DATA 00,00
2714:  DATA 00,0E
2716:  DATA C0,01
2718:  DATA 02,80
271A:  DATA 00,00
271C:  DATA 0E,C0
271E:  DATA 01,11
2720:  DATA C0,00
2722:  DATA 28,01
2724:  DATA DC,FE
2726:  DATA 01,FD
2728:  DATA 03,FE
272A:  DATA 03,FF
272C:  DATA 02,FD
272E:  DATA 03,FE
2730:  DATA 02,FF
2732:  DATA 02,FF
2734:  DATA 02,FE
2736:  DATA 03,FE
2738:  DATA FF,02
273A:  DATA FF,FE
273C:  DATA 03,FE
273E:  DATA 02,FF
2740:  DATA 01,FE
2742:  DATA 03,FF
2744:  DATA 03,FE
2746:  DATA FF,02
2748:  DATA FD,FD
274A:  DATA 03,FE
274C:  DATA 01,00
274E:  MOVLW  00
2750:  MOVWF  FF8
2752:  MOVLW  26
2754:  MOVWF  FF7
2756:  MOVLW  BE
2758:  MOVWF  FF6
275A:  TBLRD*+
275C:  MOVF   FF5,W
275E:  MOVWF  00
2760:  XORLW  00
2762:  BZ    278A
2764:  TBLRD*+
2766:  MOVF   FF5,W
2768:  MOVWF  01
276A:  BTFSC  FE8.7
276C:  BRA    2778
276E:  ANDLW  3F
2770:  MOVWF  FEA
2772:  TBLRD*+
2774:  MOVF   FF5,W
2776:  MOVWF  FE9
2778:  BTFSC  01.6
277A:  TBLRD*+
277C:  BTFSS  01.6
277E:  TBLRD*+
2780:  MOVF   FF5,W
2782:  MOVWF  FEE
2784:  DCFSNZ 00,F
2786:  BRA    275A
2788:  BRA    277C
278A:  CLRF   FF8
.................... {
.................... 
....................    enable_interrupts(GLOBAL);
278C:  MOVLW  C0
278E:  IORWF  FF2,F
....................    enable_interrupts(int_rda);
2790:  BSF    F9D.5
.................... 
....................    delay_ms(100);
2792:  MOVLW  64
2794:  MOVLB  2
2796:  MOVWF  x6F
2798:  MOVLB  0
279A:  CALL   05EC
.................... 
....................    glcd_init(ON);
279E:  MOVLW  01
27A0:  MOVLB  2
27A2:  MOVWF  x4F
27A4:  MOVLB  0
27A6:  GOTO   06DE
....................    glcd_fillScreen(0);
27AA:  MOVLB  2
27AC:  CLRF   x6E
27AE:  MOVLB  0
27B0:  CALL   0658
.................... 
....................    int inic_men = 0;
....................    int last_inic_men = 0;
.................... 
....................    int single_men = 0;
....................    int last_single_men = 0;
27B4:  MOVLB  2
27B6:  CLRF   x1C
27B8:  CLRF   x1D
27BA:  CLRF   x1E
27BC:  CLRF   x1F
.................... 
....................    inicio(1);
27BE:  MOVLW  01
27C0:  MOVWF  x4F
27C2:  MOVLB  0
27C4:  CALL   0C10
.................... 
....................    int1 win = 0;
....................    int1 who = 0;
.................... 
....................    int1 bullet_collision = 0;
....................    int sfx_time;
.................... 
....................    int asteroids_lifes[20]; // puede haber hasta 20 asteroides en la pantalla;
....................    int1 asteroid_lost_a_life[20] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
*
27D0:  CLRF   x36
27D2:  CLRF   x37
27D4:  CLRF   x38
.................... 
....................    int temp = 0;
....................    int1 new_game = 0;
*
27C8:  MOVLB  2
27CA:  BCF    x20.0
27CC:  BCF    x20.1
27CE:  BCF    x20.2
*
27D6:  CLRF   x39
27D8:  BCF    x20.3
.................... 
....................    while (TRUE)
....................    {
....................       switch (mode)
27DA:  MOVF   x0E,W
27DC:  XORLW  69
27DE:  MOVLB  0
27E0:  BZ    27FE
27E2:  XORLW  1A
27E4:  BZ    2892
27E6:  XORLW  1E
27E8:  BTFSC  FD8.2
27EA:  BRA    28F6
27EC:  XORLW  07
27EE:  BTFSC  FD8.2
27F0:  BRA    295C
27F2:  XORLW  20
27F4:  BTFSC  FD8.2
27F6:  GOTO   39E0
27FA:  GOTO   43D2
....................       {
....................       case 'i':
....................       { // inicio
....................          if (p1_pot_y > 125)
27FE:  MOVLB  2
2800:  MOVF   x13,W
2802:  SUBLW  7D
2804:  BC    280A
....................          {
....................             inic_men = 0;
2806:  CLRF   x1C
....................          }
2808:  BRA    281A
....................          else
....................          {
....................             if (p1_pot_x > 125)
280A:  MOVF   x12,W
280C:  SUBLW  7D
280E:  BC    2816
....................             {
....................                inic_men = 2;
2810:  MOVLW  02
2812:  MOVWF  x1C
....................             }
2814:  BRA    281A
....................             else
....................             {
....................                inic_men = 1;
2816:  MOVLW  01
2818:  MOVWF  x1C
....................             }
....................          }
.................... 
....................          if (inic_men != last_inic_men)
281A:  MOVF   x1D,W
281C:  SUBWF  x1C,W
281E:  BZ    2832
....................          {
....................             glcd_fillScreen(0);
2820:  CLRF   x6E
2822:  MOVLB  0
2824:  CALL   0658
....................             inicio(inic_men);
2828:  MOVFF  21C,24F
282C:  CALL   0C10
2830:  MOVLB  2
....................          }
....................          if (p1_R)
2832:  BTFSS  x10.3
2834:  BRA    2888
....................          {
....................             switch (inic_men)
2836:  MOVF   x1C,W
2838:  XORLW  01
283A:  MOVLB  0
283C:  BZ    2844
283E:  XORLW  03
2840:  BZ    2860
2842:  BRA    287C
....................             {
....................             case 1:
....................                mode = 's';
2844:  MOVLW  73
2846:  MOVLB  2
2848:  MOVWF  x0E
....................                glcd_fillScreen(0);
284A:  CLRF   x6E
284C:  MOVLB  0
284E:  CALL   0658
....................                single_menu(1);
2852:  MOVLW  01
2854:  MOVLB  2
2856:  MOVWF  x4F
2858:  MOVLB  0
285A:  CALL   0FC8
....................                break;
285E:  BRA    2886
....................             case 2:
....................                mode = 'm';
2860:  MOVLW  6D
2862:  MOVLB  2
2864:  MOVWF  x0E
....................                glcd_fillScreen(0);
2866:  CLRF   x6E
2868:  MOVLB  0
286A:  CALL   0658
....................                single_menu(1);
286E:  MOVLW  01
2870:  MOVLB  2
2872:  MOVWF  x4F
2874:  MOVLB  0
2876:  CALL   0FC8
....................                break;
287A:  BRA    2886
....................             default:
....................                mode = 'i';
287C:  MOVLW  69
287E:  MOVLB  2
2880:  MOVWF  x0E
....................                new_game = 1;
2882:  BSF    x20.3
....................                break;
2884:  MOVLB  0
2886:  MOVLB  2
....................             }
....................          }
.................... 
....................          last_inic_men = inic_men;
2888:  MOVFF  21C,21D
....................          break;
288C:  GOTO   43D4
2890:  MOVLB  0
....................       }
....................       case 's':
....................       { // single
....................          if (p1_pot_y >= 125)
2892:  MOVLB  2
2894:  MOVF   x13,W
2896:  SUBLW  7C
2898:  BC    28A0
....................          {
....................             single_men = 1;
289A:  MOVLW  01
289C:  MOVWF  x1E
....................          }
289E:  BRA    28A2
....................          else
....................          {
....................             single_men = 0;
28A0:  CLRF   x1E
....................          }
.................... 
....................          if (single_men != last_single_men)
28A2:  MOVF   x1F,W
28A4:  SUBWF  x1E,W
28A6:  BZ    28BA
....................          {
....................             glcd_fillScreen(0);
28A8:  CLRF   x6E
28AA:  MOVLB  0
28AC:  CALL   0658
....................             single_menu(single_men);
28B0:  MOVFF  21E,24F
28B4:  CALL   0FC8
28B8:  MOVLB  2
....................          }
.................... 
....................          if (p1_L)
28BA:  BTFSS  x10.2
28BC:  BRA    28EC
....................          {
....................             switch (single_men)
28BE:  MOVF   x1E,W
28C0:  XORLW  00
28C2:  MOVLB  0
28C4:  BZ    28CC
28C6:  XORLW  01
28C8:  BZ    28DC
28CA:  BRA    28EA
....................             {
....................             case 0:
....................                mode = 'i';
28CC:  MOVLW  69
28CE:  MOVLB  2
28D0:  MOVWF  x0E
....................                glcd_fillScreen(0);
28D2:  CLRF   x6E
28D4:  MOVLB  0
28D6:  CALL   0658
....................                break;
28DA:  BRA    28EA
....................             case 1:
....................                mode = 'j';
28DC:  MOVLW  6A
28DE:  MOVLB  2
28E0:  MOVWF  x0E
....................                glcd_fillScreen(0);
28E2:  CLRF   x6E
28E4:  MOVLB  0
28E6:  CALL   0658
....................                break;
28EA:  MOVLB  2
....................             }
....................          }
.................... 
....................          last_single_men = single_men;
28EC:  MOVFF  21E,21F
....................          break;
28F0:  GOTO   43D4
28F4:  MOVLB  0
....................       }
....................       case 'm':
....................       { // multiplayer
....................          if (p1_pot_y >= 125)
28F6:  MOVLB  2
28F8:  MOVF   x13,W
28FA:  SUBLW  7C
28FC:  BC    2904
....................          {
....................             single_men = 1;
28FE:  MOVLW  01
2900:  MOVWF  x1E
....................          }
2902:  BRA    2906
....................          else
....................          {
....................             single_men = 0;
2904:  CLRF   x1E
....................          }
.................... 
....................          if (single_men != last_single_men)
2906:  MOVF   x1F,W
2908:  SUBWF  x1E,W
290A:  BZ    291E
....................          {
....................             glcd_fillScreen(0);
290C:  CLRF   x6E
290E:  MOVLB  0
2910:  CALL   0658
....................             single_menu(single_men);
2914:  MOVFF  21E,24F
2918:  CALL   0FC8
291C:  MOVLB  2
....................          }
.................... 
....................          if (p1_L)
291E:  BTFSS  x10.2
2920:  BRA    2952
....................          {
....................             switch (single_men)
2922:  MOVF   x1E,W
2924:  XORLW  00
2926:  MOVLB  0
2928:  BZ    2930
292A:  XORLW  01
292C:  BZ    2940
292E:  BRA    2950
....................             {
....................             case 0:
....................                mode = 'i';
2930:  MOVLW  69
2932:  MOVLB  2
2934:  MOVWF  x0E
....................                glcd_fillScreen(0);
2936:  CLRF   x6E
2938:  MOVLB  0
293A:  CALL   0658
....................                break;
293E:  BRA    2950
....................             case 1:
....................                mode = 'J';
2940:  MOVLW  4A
2942:  MOVLB  2
2944:  MOVWF  x0E
....................                new_game = 1;
2946:  BSF    x20.3
....................                glcd_fillScreen(0);
2948:  CLRF   x6E
294A:  MOVLB  0
294C:  CALL   0658
....................                break;
2950:  MOVLB  2
....................             }
....................          }
.................... 
....................          last_single_men = single_men;
2952:  MOVFF  21E,21F
....................          break;
2956:  GOTO   43D4
295A:  MOVLB  0
....................       }
....................       case 'j':
....................       { // jugnado single
....................          if (new_level)
295C:  MOVLB  1
295E:  BTFSS  x43.7
2960:  BRA    2B0E
....................          {
....................             new_level = 0;
2962:  BCF    x43.7
....................             for (int i = 0; i < 20; i++)
2964:  MOVLB  2
2966:  CLRF   x3A
2968:  MOVF   x3A,W
296A:  SUBLW  13
296C:  BNC   29B8
....................             {
....................                asteroids_lifes[i] = levels[level][i];
296E:  CLRF   03
2970:  MOVF   x3A,W
2972:  ADDLW  22
2974:  MOVWF  FE9
2976:  MOVLW  02
2978:  ADDWFC 03,W
297A:  MOVWF  FEA
297C:  CLRF   x52
297E:  MOVFF  204,251
2982:  CLRF   x54
2984:  MOVLW  14
2986:  MOVWF  x53
2988:  MOVLB  0
298A:  GOTO   110C
298E:  MOVFF  02,252
2992:  MOVFF  01,251
2996:  MOVLB  2
2998:  MOVF   x3A,W
299A:  ADDWF  01,W
299C:  MOVWF  01
299E:  MOVLW  00
29A0:  ADDWFC 02,W
29A2:  MOVWF  03
29A4:  MOVF   01,W
29A6:  MOVFF  03,FF7
29AA:  MOVLB  0
29AC:  CALL   02AA
29B0:  MOVWF  FEF
29B2:  MOVLB  2
29B4:  INCF   x3A,F
29B6:  BRA    2968
....................             }
....................             if (!level)
29B8:  MOVF   x04,F
29BA:  BNZ   29CE
....................             {
....................                restart_screen();
29BC:  MOVLB  0
29BE:  GOTO   1130
....................                // while(!p1_R);
....................                x_pos = 63;
29C2:  MOVLW  3F
29C4:  MOVLB  1
29C6:  MOVWF  x52
....................                y_pos = 31;
29C8:  MOVLW  1F
29CA:  MOVWF  x53
29CC:  MOVLB  2
....................             }
....................             level++;
29CE:  INCF   x04,F
....................             for (unsigned int i = 0; i < 20; i++)
29D0:  CLRF   x3B
29D2:  MOVF   x3B,W
29D4:  SUBLW  13
29D6:  BTFSS  FD8.0
29D8:  BRA    2B00
....................             { // inicializar la posicion de los asteroides a la esquina superior izquierda de manera random
....................                asteroids_x_pos[i] = (int)(((float)i) / 2.0f) % 10;
29DA:  CLRF   03
29DC:  MOVF   x3B,W
29DE:  ADDLW  B4
29E0:  MOVWF  FE9
29E2:  MOVLW  01
29E4:  ADDWFC 03,W
29E6:  MOVWF  FEA
29E8:  CLRF   x86
29EA:  MOVFF  23B,285
29EE:  MOVLB  0
29F0:  CALL   11AE
29F4:  MOVFF  03,254
29F8:  MOVFF  02,253
29FC:  MOVFF  01,252
2A00:  MOVFF  00,251
2A04:  MOVFF  03,25A
2A08:  MOVFF  02,259
2A0C:  MOVFF  01,258
2A10:  MOVFF  00,257
2A14:  MOVLB  2
2A16:  CLRF   x5E
2A18:  CLRF   x5D
2A1A:  CLRF   x5C
2A1C:  MOVLW  80
2A1E:  MOVWF  x5B
2A20:  MOVLB  0
2A22:  CALL   11E4
2A26:  MOVFF  03,284
2A2A:  MOVFF  02,283
2A2E:  MOVFF  01,282
2A32:  MOVFF  00,281
2A36:  CALL   1342
2A3A:  MOVFF  01,25F
2A3E:  MOVLW  0A
2A40:  MOVLB  2
2A42:  MOVWF  x60
2A44:  MOVLB  0
2A46:  CALL   137E
2A4A:  MOVFF  00,FEF
....................                asteroids_x_pos[i] = (int)((20.0f - (float)i) / 2.0f) % 10;
2A4E:  CLRF   03
2A50:  MOVLB  2
2A52:  MOVF   x3B,W
2A54:  ADDLW  B4
2A56:  MOVWF  FE9
2A58:  MOVLW  01
2A5A:  ADDWFC 03,W
2A5C:  MOVWF  FEA
2A5E:  CLRF   x86
2A60:  MOVFF  23B,285
2A64:  MOVLB  0
2A66:  CALL   11AE
2A6A:  MOVFF  FEA,252
2A6E:  MOVFF  FE9,251
2A72:  BSF    FD8.1
2A74:  MOVLB  2
2A76:  CLRF   x88
2A78:  CLRF   x87
2A7A:  MOVLW  20
2A7C:  MOVWF  x86
2A7E:  MOVLW  83
2A80:  MOVWF  x85
2A82:  MOVFF  03,28C
2A86:  MOVFF  02,28B
2A8A:  MOVFF  01,28A
2A8E:  MOVFF  00,289
2A92:  MOVLB  0
2A94:  CALL   13AA
2A98:  MOVFF  252,FEA
2A9C:  MOVFF  251,FE9
2AA0:  MOVFF  03,256
2AA4:  MOVFF  02,255
2AA8:  MOVFF  01,254
2AAC:  MOVFF  00,253
2AB0:  MOVFF  03,25A
2AB4:  MOVFF  02,259
2AB8:  MOVFF  01,258
2ABC:  MOVFF  00,257
2AC0:  MOVLB  2
2AC2:  CLRF   x5E
2AC4:  CLRF   x5D
2AC6:  CLRF   x5C
2AC8:  MOVLW  80
2ACA:  MOVWF  x5B
2ACC:  MOVLB  0
2ACE:  CALL   11E4
2AD2:  MOVFF  03,284
2AD6:  MOVFF  02,283
2ADA:  MOVFF  01,282
2ADE:  MOVFF  00,281
2AE2:  CALL   1342
2AE6:  MOVFF  01,25F
2AEA:  MOVLW  0A
2AEC:  MOVLB  2
2AEE:  MOVWF  x60
2AF0:  MOVLB  0
2AF2:  CALL   137E
2AF6:  MOVFF  00,FEF
2AFA:  MOVLB  2
2AFC:  INCF   x3B,F
2AFE:  BRA    29D2
....................             }
....................             glcd_fillScreen(0);
2B00:  CLRF   x6E
2B02:  MOVLB  0
2B04:  CALL   0658
....................          }
2B08:  GOTO   39D8
2B0C:  MOVLB  1
....................          else
....................          {
....................             ship_angle = (get_ship_angle() * 3.1416f) / 180.0f; // potenciometros angulos
2B0E:  MOVLB  0
2B10:  GOTO   1622
2B14:  MOVFF  03,252
2B18:  MOVFF  02,251
2B1C:  MOVFF  01,250
2B20:  MOVFF  00,24F
2B24:  MOVFF  03,288
2B28:  MOVFF  02,287
2B2C:  MOVFF  01,286
2B30:  MOVFF  00,285
2B34:  MOVLW  F9
2B36:  MOVLB  2
2B38:  MOVWF  x8C
2B3A:  MOVLW  0F
2B3C:  MOVWF  x8B
2B3E:  MOVLW  49
2B40:  MOVWF  x8A
2B42:  MOVLW  80
2B44:  MOVWF  x89
2B46:  MOVLB  0
2B48:  CALL   16E0
2B4C:  MOVFF  03,252
2B50:  MOVFF  02,251
2B54:  MOVFF  01,250
2B58:  MOVFF  00,24F
2B5C:  MOVFF  03,25A
2B60:  MOVFF  02,259
2B64:  MOVFF  01,258
2B68:  MOVFF  00,257
2B6C:  MOVLB  2
2B6E:  CLRF   x5E
2B70:  CLRF   x5D
2B72:  MOVLW  34
2B74:  MOVWF  x5C
2B76:  MOVLW  86
2B78:  MOVWF  x5B
2B7A:  MOVLB  0
2B7C:  CALL   11E4
2B80:  MOVFF  03,14F
2B84:  MOVFF  02,14E
2B88:  MOVFF  01,14D
2B8C:  MOVFF  00,14C
.................... 
....................             dx = get_x_vel();          // potenciometro movimiento
2B90:  GOTO   17D6
2B94:  MOVFF  03,157
2B98:  MOVFF  02,156
2B9C:  MOVFF  01,155
2BA0:  MOVFF  00,154
....................             dy = get_y_vel();          // potenciometro movimiento
2BA4:  GOTO   184C
2BA8:  MOVFF  03,15B
2BAC:  MOVFF  02,15A
2BB0:  MOVFF  01,159
2BB4:  MOVFF  00,158
....................             if ((float)x_pos + dx < 0) // mover jugador
2BB8:  MOVLB  2
2BBA:  CLRF   x86
2BBC:  MOVFF  152,285
2BC0:  MOVLB  0
2BC2:  CALL   11AE
2BC6:  MOVFF  03,252
2BCA:  MOVFF  02,251
2BCE:  MOVFF  01,250
2BD2:  MOVFF  00,24F
2BD6:  BCF    FD8.1
2BD8:  MOVFF  03,288
2BDC:  MOVFF  02,287
2BE0:  MOVFF  01,286
2BE4:  MOVFF  00,285
2BE8:  MOVFF  157,28C
2BEC:  MOVFF  156,28B
2BF0:  MOVFF  155,28A
2BF4:  MOVFF  154,289
2BF8:  CALL   13AA
2BFC:  MOVFF  03,252
2C00:  MOVFF  02,251
2C04:  MOVFF  01,250
2C08:  MOVFF  00,24F
2C0C:  MOVFF  03,284
2C10:  MOVFF  02,283
2C14:  MOVFF  01,282
2C18:  MOVFF  00,281
2C1C:  MOVLB  2
2C1E:  CLRF   x88
2C20:  CLRF   x87
2C22:  CLRF   x86
2C24:  CLRF   x85
2C26:  MOVLB  0
2C28:  CALL   18C2
2C2C:  BNC   2C92
....................                x_pos = 127 + (int)((float)x_pos + dx);
2C2E:  MOVLB  2
2C30:  CLRF   x86
2C32:  MOVFF  152,285
2C36:  MOVLB  0
2C38:  CALL   11AE
2C3C:  MOVFF  03,252
2C40:  MOVFF  02,251
2C44:  MOVFF  01,250
2C48:  MOVFF  00,24F
2C4C:  BCF    FD8.1
2C4E:  MOVFF  03,288
2C52:  MOVFF  02,287
2C56:  MOVFF  01,286
2C5A:  MOVFF  00,285
2C5E:  MOVFF  157,28C
2C62:  MOVFF  156,28B
2C66:  MOVFF  155,28A
2C6A:  MOVFF  154,289
2C6E:  CALL   13AA
2C72:  MOVFF  03,284
2C76:  MOVFF  02,283
2C7A:  MOVFF  01,282
2C7E:  MOVFF  00,281
2C82:  CALL   1342
2C86:  MOVLW  7F
2C88:  ADDWF  01,W
2C8A:  MOVLB  1
2C8C:  MOVWF  x52
2C8E:  BRA    2CC2
2C90:  MOVLB  0
....................             else
....................                x_pos = (x_pos + (int)dx) % 127;
2C92:  MOVFF  157,284
2C96:  MOVFF  156,283
2C9A:  MOVFF  155,282
2C9E:  MOVFF  154,281
2CA2:  CALL   1342
2CA6:  MOVF   01,W
2CA8:  MOVLB  1
2CAA:  ADDWF  x52,W
2CAC:  MOVLB  2
2CAE:  MOVWF  x50
2CB0:  MOVWF  x5F
2CB2:  MOVLW  7F
2CB4:  MOVWF  x60
2CB6:  MOVLB  0
2CB8:  CALL   137E
2CBC:  MOVFF  00,152
2CC0:  MOVLB  1
.................... 
....................             if ((float)y_pos - dy < 0) // mover jugador
2CC2:  MOVLB  2
2CC4:  CLRF   x86
2CC6:  MOVFF  153,285
2CCA:  MOVLB  0
2CCC:  CALL   11AE
2CD0:  MOVFF  03,252
2CD4:  MOVFF  02,251
2CD8:  MOVFF  01,250
2CDC:  MOVFF  00,24F
2CE0:  BSF    FD8.1
2CE2:  MOVFF  03,288
2CE6:  MOVFF  02,287
2CEA:  MOVFF  01,286
2CEE:  MOVFF  00,285
2CF2:  MOVFF  15B,28C
2CF6:  MOVFF  15A,28B
2CFA:  MOVFF  159,28A
2CFE:  MOVFF  158,289
2D02:  CALL   13AA
2D06:  MOVFF  03,252
2D0A:  MOVFF  02,251
2D0E:  MOVFF  01,250
2D12:  MOVFF  00,24F
2D16:  MOVFF  03,284
2D1A:  MOVFF  02,283
2D1E:  MOVFF  01,282
2D22:  MOVFF  00,281
2D26:  MOVLB  2
2D28:  CLRF   x88
2D2A:  CLRF   x87
2D2C:  CLRF   x86
2D2E:  CLRF   x85
2D30:  MOVLB  0
2D32:  CALL   18C2
2D36:  BNC   2D9C
....................                y_pos = 63 + (int)((float)y_pos - dy);
2D38:  MOVLB  2
2D3A:  CLRF   x86
2D3C:  MOVFF  153,285
2D40:  MOVLB  0
2D42:  CALL   11AE
2D46:  MOVFF  03,252
2D4A:  MOVFF  02,251
2D4E:  MOVFF  01,250
2D52:  MOVFF  00,24F
2D56:  BSF    FD8.1
2D58:  MOVFF  03,288
2D5C:  MOVFF  02,287
2D60:  MOVFF  01,286
2D64:  MOVFF  00,285
2D68:  MOVFF  15B,28C
2D6C:  MOVFF  15A,28B
2D70:  MOVFF  159,28A
2D74:  MOVFF  158,289
2D78:  CALL   13AA
2D7C:  MOVFF  03,284
2D80:  MOVFF  02,283
2D84:  MOVFF  01,282
2D88:  MOVFF  00,281
2D8C:  CALL   1342
2D90:  MOVLW  3F
2D92:  ADDWF  01,W
2D94:  MOVLB  1
2D96:  MOVWF  x53
2D98:  BRA    2DCC
2D9A:  MOVLB  0
....................             else
....................                y_pos = (y_pos - (int)dy) % 63;
2D9C:  MOVFF  15B,284
2DA0:  MOVFF  15A,283
2DA4:  MOVFF  159,282
2DA8:  MOVFF  158,281
2DAC:  CALL   1342
2DB0:  MOVF   01,W
2DB2:  MOVLB  1
2DB4:  SUBWF  x53,W
2DB6:  MOVLB  2
2DB8:  MOVWF  x50
2DBA:  MOVWF  x5F
2DBC:  MOVLW  3F
2DBE:  MOVWF  x60
2DC0:  MOVLB  0
2DC2:  CALL   137E
2DC6:  MOVFF  00,153
2DCA:  MOVLB  1
.................... 
....................             for (unsigned int i = 0; i < 20; i++)
2DCC:  MOVLB  2
2DCE:  CLRF   x3C
2DD0:  MOVF   x3C,W
2DD2:  SUBLW  13
2DD4:  BTFSS  FD8.0
2DD6:  BRA    3010
....................             { // mover asteroides
....................                if ((signed int)asteroids_x_pos[i] + asteroids_dx[i] < 0)
2DD8:  CLRF   03
2DDA:  MOVF   x3C,W
2DDC:  ADDLW  B4
2DDE:  MOVWF  FE9
2DE0:  MOVLW  01
2DE2:  ADDWFC 03,W
2DE4:  MOVWF  FEA
2DE6:  MOVFF  FEF,24F
2DEA:  CLRF   03
2DEC:  MOVF   x3C,W
2DEE:  ADDLW  DC
2DF0:  MOVWF  FE9
2DF2:  MOVLW  01
2DF4:  ADDWFC 03,W
2DF6:  MOVWF  FEA
2DF8:  MOVF   FEF,W
2DFA:  ADDWF  x4F,W
2DFC:  MOVWF  00
2DFE:  BTFSS  FE8.7
2E00:  BRA    2E4A
....................                   asteroids_x_pos[i] = 127 + ((signed int)asteroids_x_pos[i] + asteroids_dx[i]);
2E02:  CLRF   03
2E04:  MOVF   x3C,W
2E06:  ADDLW  B4
2E08:  MOVWF  01
2E0A:  MOVLW  01
2E0C:  ADDWFC 03,F
2E0E:  MOVFF  01,24F
2E12:  MOVFF  03,250
2E16:  CLRF   03
2E18:  MOVF   x3C,W
2E1A:  ADDLW  B4
2E1C:  MOVWF  FE9
2E1E:  MOVLW  01
2E20:  ADDWFC 03,W
2E22:  MOVWF  FEA
2E24:  MOVFF  FEF,251
2E28:  CLRF   03
2E2A:  MOVF   x3C,W
2E2C:  ADDLW  DC
2E2E:  MOVWF  FE9
2E30:  MOVLW  01
2E32:  ADDWFC 03,W
2E34:  MOVWF  FEA
2E36:  MOVF   FEF,W
2E38:  ADDWF  x51,W
2E3A:  ADDLW  7F
2E3C:  MOVWF  x51
2E3E:  MOVFF  250,FEA
2E42:  MOVFF  01,FE9
2E46:  MOVWF  FEF
2E48:  BRA    2EF2
....................                else if (asteroids_x_pos[i] + (unsigned int)asteroids_dx[i] > 127)
2E4A:  CLRF   03
2E4C:  MOVF   x3C,W
2E4E:  ADDLW  B4
2E50:  MOVWF  FE9
2E52:  MOVLW  01
2E54:  ADDWFC 03,W
2E56:  MOVWF  FEA
2E58:  MOVFF  FEF,24F
2E5C:  CLRF   03
2E5E:  MOVF   x3C,W
2E60:  ADDLW  DC
2E62:  MOVWF  FE9
2E64:  MOVLW  01
2E66:  ADDWFC 03,W
2E68:  MOVWF  FEA
2E6A:  MOVF   FEF,W
2E6C:  ADDWF  x4F,W
2E6E:  SUBLW  7F
2E70:  BC    2EBA
....................                   asteroids_x_pos[i] = 0 + ((asteroids_x_pos[i] + (unsigned int)asteroids_dx[i]) - 127);
2E72:  CLRF   03
2E74:  MOVF   x3C,W
2E76:  ADDLW  B4
2E78:  MOVWF  01
2E7A:  MOVLW  01
2E7C:  ADDWFC 03,F
2E7E:  MOVFF  01,24F
2E82:  MOVFF  03,250
2E86:  CLRF   03
2E88:  MOVF   x3C,W
2E8A:  ADDLW  B4
2E8C:  MOVWF  FE9
2E8E:  MOVLW  01
2E90:  ADDWFC 03,W
2E92:  MOVWF  FEA
2E94:  MOVFF  FEF,251
2E98:  CLRF   03
2E9A:  MOVF   x3C,W
2E9C:  ADDLW  DC
2E9E:  MOVWF  FE9
2EA0:  MOVLW  01
2EA2:  ADDWFC 03,W
2EA4:  MOVWF  FEA
2EA6:  MOVF   FEF,W
2EA8:  ADDWF  x51,W
2EAA:  ADDLW  81
2EAC:  MOVWF  x51
2EAE:  MOVFF  250,FEA
2EB2:  MOVFF  01,FE9
2EB6:  MOVWF  FEF
2EB8:  BRA    2EF2
....................                else
....................                   asteroids_x_pos[i] += asteroids_dx[i];
2EBA:  CLRF   03
2EBC:  MOVF   x3C,W
2EBE:  ADDLW  B4
2EC0:  MOVWF  01
2EC2:  MOVLW  01
2EC4:  ADDWFC 03,F
2EC6:  MOVFF  03,250
2ECA:  MOVFF  03,FEA
2ECE:  MOVFF  01,FE9
2ED2:  MOVFF  FEF,251
2ED6:  CLRF   03
2ED8:  MOVF   x3C,W
2EDA:  ADDLW  DC
2EDC:  MOVWF  FE9
2EDE:  MOVLW  01
2EE0:  ADDWFC 03,W
2EE2:  MOVWF  FEA
2EE4:  MOVF   FEF,W
2EE6:  ADDWF  x51,W
2EE8:  MOVFF  250,FEA
2EEC:  MOVFF  01,FE9
2EF0:  MOVWF  FEF
.................... 
....................                if ((signed int)asteroids_y_pos[i] + asteroids_dy[i] < 0)
2EF2:  CLRF   03
2EF4:  MOVF   x3C,W
2EF6:  ADDLW  C8
2EF8:  MOVWF  FE9
2EFA:  MOVLW  01
2EFC:  ADDWFC 03,W
2EFE:  MOVWF  FEA
2F00:  MOVFF  FEF,24F
2F04:  CLRF   03
2F06:  MOVF   x3C,W
2F08:  ADDLW  F0
2F0A:  MOVWF  FE9
2F0C:  MOVLW  01
2F0E:  ADDWFC 03,W
2F10:  MOVWF  FEA
2F12:  MOVF   FEF,W
2F14:  ADDWF  x4F,W
2F16:  MOVWF  00
2F18:  BTFSS  FE8.7
2F1A:  BRA    2F64
....................                   asteroids_y_pos[i] = 63 + ((signed int)asteroids_y_pos[i] + asteroids_dy[i]);
2F1C:  CLRF   03
2F1E:  MOVF   x3C,W
2F20:  ADDLW  C8
2F22:  MOVWF  01
2F24:  MOVLW  01
2F26:  ADDWFC 03,F
2F28:  MOVFF  01,24F
2F2C:  MOVFF  03,250
2F30:  CLRF   03
2F32:  MOVF   x3C,W
2F34:  ADDLW  C8
2F36:  MOVWF  FE9
2F38:  MOVLW  01
2F3A:  ADDWFC 03,W
2F3C:  MOVWF  FEA
2F3E:  MOVFF  FEF,251
2F42:  CLRF   03
2F44:  MOVF   x3C,W
2F46:  ADDLW  F0
2F48:  MOVWF  FE9
2F4A:  MOVLW  01
2F4C:  ADDWFC 03,W
2F4E:  MOVWF  FEA
2F50:  MOVF   FEF,W
2F52:  ADDWF  x51,W
2F54:  ADDLW  3F
2F56:  MOVWF  x51
2F58:  MOVFF  250,FEA
2F5C:  MOVFF  01,FE9
2F60:  MOVWF  FEF
2F62:  BRA    300C
....................                else if (asteroids_y_pos[i] + (unsigned int)asteroids_dy[i] > 63)
2F64:  CLRF   03
2F66:  MOVF   x3C,W
2F68:  ADDLW  C8
2F6A:  MOVWF  FE9
2F6C:  MOVLW  01
2F6E:  ADDWFC 03,W
2F70:  MOVWF  FEA
2F72:  MOVFF  FEF,24F
2F76:  CLRF   03
2F78:  MOVF   x3C,W
2F7A:  ADDLW  F0
2F7C:  MOVWF  FE9
2F7E:  MOVLW  01
2F80:  ADDWFC 03,W
2F82:  MOVWF  FEA
2F84:  MOVF   FEF,W
2F86:  ADDWF  x4F,W
2F88:  SUBLW  3F
2F8A:  BC    2FD4
....................                   asteroids_y_pos[i] = 0 + ((asteroids_y_pos[i] + (unsigned int)asteroids_dy[i]) - 63);
2F8C:  CLRF   03
2F8E:  MOVF   x3C,W
2F90:  ADDLW  C8
2F92:  MOVWF  01
2F94:  MOVLW  01
2F96:  ADDWFC 03,F
2F98:  MOVFF  01,24F
2F9C:  MOVFF  03,250
2FA0:  CLRF   03
2FA2:  MOVF   x3C,W
2FA4:  ADDLW  C8
2FA6:  MOVWF  FE9
2FA8:  MOVLW  01
2FAA:  ADDWFC 03,W
2FAC:  MOVWF  FEA
2FAE:  MOVFF  FEF,251
2FB2:  CLRF   03
2FB4:  MOVF   x3C,W
2FB6:  ADDLW  F0
2FB8:  MOVWF  FE9
2FBA:  MOVLW  01
2FBC:  ADDWFC 03,W
2FBE:  MOVWF  FEA
2FC0:  MOVF   FEF,W
2FC2:  ADDWF  x51,W
2FC4:  ADDLW  C1
2FC6:  MOVWF  x51
2FC8:  MOVFF  250,FEA
2FCC:  MOVFF  01,FE9
2FD0:  MOVWF  FEF
2FD2:  BRA    300C
....................                else
....................                   asteroids_y_pos[i] += asteroids_dy[i];
2FD4:  CLRF   03
2FD6:  MOVF   x3C,W
2FD8:  ADDLW  C8
2FDA:  MOVWF  01
2FDC:  MOVLW  01
2FDE:  ADDWFC 03,F
2FE0:  MOVFF  03,250
2FE4:  MOVFF  03,FEA
2FE8:  MOVFF  01,FE9
2FEC:  MOVFF  FEF,251
2FF0:  CLRF   03
2FF2:  MOVF   x3C,W
2FF4:  ADDLW  F0
2FF6:  MOVWF  FE9
2FF8:  MOVLW  01
2FFA:  ADDWFC 03,W
2FFC:  MOVWF  FEA
2FFE:  MOVF   FEF,W
3000:  ADDWF  x51,W
3002:  MOVFF  250,FEA
3006:  MOVFF  01,FE9
300A:  MOVWF  FEF
300C:  INCF   x3C,F
300E:  BRA    2DD0
....................             }
.................... 
....................             for (unsigned int i = 0; i < 20; i++)
3010:  CLRF   x3D
3012:  MOVF   x3D,W
3014:  SUBLW  13
3016:  BTFSS  FD8.0
3018:  BRA    310E
....................             { // checar si la posicion del jugador coincide con algun asteroide
....................                if (asteroids_lifes[i])
301A:  CLRF   03
301C:  MOVF   x3D,W
301E:  ADDLW  22
3020:  MOVWF  FE9
3022:  MOVLW  02
3024:  ADDWFC 03,W
3026:  MOVWF  FEA
3028:  MOVF   FEF,F
302A:  BTFSC  FD8.2
302C:  BRA    3106
....................                {
....................                   if (((x_pos > asteroids_x_pos[i]) && (x_pos < (asteroids_x_pos[i] + asteroids_lifes[i] * 8))) && ((y_pos > asteroids_y_pos[i]) && (y_pos < (asteroids_y_pos[i] + asteroids_lifes[i] * 8))))
302E:  CLRF   03
3030:  MOVF   x3D,W
3032:  ADDLW  B4
3034:  MOVWF  FE9
3036:  MOVLW  01
3038:  ADDWFC 03,W
303A:  MOVWF  FEA
303C:  MOVF   FEF,W
303E:  MOVLB  1
3040:  SUBWF  x52,W
3042:  BZ    3108
3044:  BNC   3108
3046:  CLRF   03
3048:  MOVLB  2
304A:  MOVF   x3D,W
304C:  ADDLW  B4
304E:  MOVWF  FE9
3050:  MOVLW  01
3052:  ADDWFC 03,W
3054:  MOVWF  FEA
3056:  MOVFF  FEF,24F
305A:  CLRF   03
305C:  MOVF   x3D,W
305E:  ADDLW  22
3060:  MOVWF  FE9
3062:  MOVLW  02
3064:  ADDWFC 03,W
3066:  MOVWF  FEA
3068:  MOVF   FEF,W
306A:  MULLW  08
306C:  MOVF   FF3,W
306E:  ADDWF  x4F,W
3070:  MOVLB  1
3072:  SUBWF  x52,W
3074:  BC    3108
3076:  CLRF   03
3078:  MOVLB  2
307A:  MOVF   x3D,W
307C:  ADDLW  C8
307E:  MOVWF  FE9
3080:  MOVLW  01
3082:  ADDWFC 03,W
3084:  MOVWF  FEA
3086:  MOVF   FEF,W
3088:  MOVLB  1
308A:  SUBWF  x53,W
308C:  BZ    3108
308E:  BNC   3108
3090:  CLRF   03
3092:  MOVLB  2
3094:  MOVF   x3D,W
3096:  ADDLW  C8
3098:  MOVWF  FE9
309A:  MOVLW  01
309C:  ADDWFC 03,W
309E:  MOVWF  FEA
30A0:  MOVFF  FEF,24F
30A4:  CLRF   03
30A6:  MOVF   x3D,W
30A8:  ADDLW  22
30AA:  MOVWF  FE9
30AC:  MOVLW  02
30AE:  ADDWFC 03,W
30B0:  MOVWF  FEA
30B2:  MOVF   FEF,W
30B4:  MULLW  08
30B6:  MOVF   FF3,W
30B8:  ADDWF  x4F,W
30BA:  MOVLB  1
30BC:  SUBWF  x53,W
30BE:  BC    3108
....................                   { // perder
....................                      mode = 'i';
30C0:  MOVLW  69
30C2:  MOVLB  2
30C4:  MOVWF  x0E
....................                      new_level = 1;
30C6:  MOVLB  1
30C8:  BSF    x43.7
....................                      glcd_fillScreen(0);
30CA:  MOVLB  2
30CC:  CLRF   x6E
30CE:  MOVLB  0
30D0:  CALL   0658
....................                      inicio(0);
30D4:  MOVLB  2
30D6:  CLRF   x4F
30D8:  MOVLB  0
30DA:  CALL   0C10
....................                      if (score > best_score)
30DE:  MOVLB  2
30E0:  MOVF   x09,W
30E2:  SUBWF  x07,W
30E4:  BNC   30F6
30E6:  BNZ   30EE
30E8:  MOVF   x06,W
30EA:  SUBWF  x08,W
30EC:  BC    30F6
....................                         best_score = score;
30EE:  MOVFF  207,209
30F2:  MOVFF  206,208
....................                      if (level > best_level)
30F6:  MOVF   x04,W
30F8:  SUBWF  x05,W
30FA:  BC    3100
....................                         best_level = level;
30FC:  MOVFF  204,205
....................                      score = 0;
3100:  CLRF   x07
3102:  CLRF   x06
....................                      level = 0;
3104:  CLRF   x04
3106:  MOVLB  1
....................                   }
....................                }
3108:  MOVLB  2
310A:  INCF   x3D,F
310C:  BRA    3012
....................             }
.................... 
....................             if (bullet)
310E:  MOVLB  1
3110:  BTFSS  x43.2
3112:  BRA    33CA
....................             { // si hay una bala, calcular su posicion, y si hay impacto o se pierde la bala
....................                bullet_x_pos += (signed int)bullet_dx;
3114:  MOVFF  167,284
3118:  MOVFF  166,283
311C:  MOVFF  165,282
3120:  MOVFF  164,281
3124:  MOVLB  0
3126:  CALL   1342
312A:  CLRF   03
312C:  MOVF   01,W
312E:  BTFSC  FE8.7
3130:  DECF   03,F
3132:  MOVLB  1
3134:  ADDWF  x60,F
3136:  MOVF   03,W
3138:  ADDWFC x61,F
....................                bullet_y_pos += (signed int)bullet_dy;
313A:  MOVFF  16B,284
313E:  MOVFF  16A,283
3142:  MOVFF  169,282
3146:  MOVFF  168,281
314A:  MOVLB  0
314C:  CALL   1342
3150:  CLRF   03
3152:  MOVF   01,W
3154:  BTFSC  FE8.7
3156:  DECF   03,F
3158:  MOVLB  1
315A:  ADDWF  x62,F
315C:  MOVF   03,W
315E:  ADDWFC x63,F
....................                // checar collision con asteroides
....................                for (int i = 0; i < 20; i++)
3160:  MOVLB  2
3162:  CLRF   x3E
3164:  MOVF   x3E,W
3166:  SUBLW  13
3168:  BTFSS  FD8.0
316A:  BRA    3324
....................                {
....................                   if (asteroids_lifes[i])
316C:  CLRF   03
316E:  MOVF   x3E,W
3170:  ADDLW  22
3172:  MOVWF  FE9
3174:  MOVLW  02
3176:  ADDWFC 03,W
3178:  MOVWF  FEA
317A:  MOVF   FEF,F
317C:  BTFSC  FD8.2
317E:  BRA    331C
....................                   {
....................                      if ((((bullet_x_pos > asteroids_x_pos[i]) && (bullet_x_pos < (asteroids_x_pos[i] + asteroids_lifes[i] * 8))) && ((bullet_y_pos > asteroids_y_pos[i]) && (bullet_y_pos < (asteroids_y_pos[i] + asteroids_lifes[i] * 8)))) || (((last_bullet_x_pos > asteroids_x_pos[i]) && (last_bullet_x_pos < (asteroids_x_pos[i] + asteroids_lifes[i] * 8))) && ((last_bullet_y_pos > asteroids_y_pos[i]) && (last_bullet_y_pos < (asteroids_y_pos[i] + asteroids_lifes[i] * 8)))))
3180:  CLRF   03
3182:  MOVF   x3E,W
3184:  ADDLW  B4
3186:  MOVWF  FE9
3188:  MOVLW  01
318A:  ADDWFC 03,W
318C:  MOVWF  FEA
318E:  MOVF   FEF,W
3190:  MOVLB  1
3192:  BTFSC  x61.7
3194:  BRA    3232
3196:  MOVF   x61,F
3198:  BNZ   31A0
319A:  SUBWF  x60,W
319C:  BZ    3232
319E:  BNC   3232
31A0:  CLRF   03
31A2:  MOVLB  2
31A4:  MOVF   x3E,W
31A6:  ADDLW  B4
31A8:  MOVWF  FE9
31AA:  MOVLW  01
31AC:  ADDWFC 03,W
31AE:  MOVWF  FEA
31B0:  MOVFF  FEF,24F
31B4:  CLRF   03
31B6:  MOVF   x3E,W
31B8:  ADDLW  22
31BA:  MOVWF  FE9
31BC:  MOVLW  02
31BE:  ADDWFC 03,W
31C0:  MOVWF  FEA
31C2:  MOVF   FEF,W
31C4:  MULLW  08
31C6:  MOVF   FF3,W
31C8:  ADDWF  x4F,W
31CA:  MOVLB  1
31CC:  BTFSC  x61.7
31CE:  BRA    31D8
31D0:  MOVF   x61,F
31D2:  BNZ   3232
31D4:  SUBWF  x60,W
31D6:  BC    3232
31D8:  CLRF   03
31DA:  MOVLB  2
31DC:  MOVF   x3E,W
31DE:  ADDLW  C8
31E0:  MOVWF  FE9
31E2:  MOVLW  01
31E4:  ADDWFC 03,W
31E6:  MOVWF  FEA
31E8:  MOVF   FEF,W
31EA:  MOVLB  1
31EC:  BTFSC  x63.7
31EE:  BRA    3232
31F0:  MOVF   x63,F
31F2:  BNZ   31FA
31F4:  SUBWF  x62,W
31F6:  BZ    3232
31F8:  BNC   3232
31FA:  CLRF   03
31FC:  MOVLB  2
31FE:  MOVF   x3E,W
3200:  ADDLW  C8
3202:  MOVWF  FE9
3204:  MOVLW  01
3206:  ADDWFC 03,W
3208:  MOVWF  FEA
320A:  MOVFF  FEF,24F
320E:  CLRF   03
3210:  MOVF   x3E,W
3212:  ADDLW  22
3214:  MOVWF  FE9
3216:  MOVLW  02
3218:  ADDWFC 03,W
321A:  MOVWF  FEA
321C:  MOVF   FEF,W
321E:  MULLW  08
3220:  MOVF   FF3,W
3222:  ADDWF  x4F,W
3224:  MOVLB  1
3226:  BTFSC  x63.7
3228:  BRA    32D6
322A:  MOVF   x63,F
322C:  BNZ   3232
322E:  SUBWF  x62,W
3230:  BNC   32D6
3232:  CLRF   03
3234:  MOVLB  2
3236:  MOVF   x3E,W
3238:  ADDLW  B4
323A:  MOVWF  FE9
323C:  MOVLW  01
323E:  ADDWFC 03,W
3240:  MOVWF  FEA
3242:  MOVF   FEF,W
3244:  MOVLB  1
3246:  BTFSC  x5E.7
3248:  BRA    331E
324A:  SUBWF  x5E,W
324C:  BZ    331E
324E:  BNC   331E
3250:  CLRF   03
3252:  MOVLB  2
3254:  MOVF   x3E,W
3256:  ADDLW  B4
3258:  MOVWF  FE9
325A:  MOVLW  01
325C:  ADDWFC 03,W
325E:  MOVWF  FEA
3260:  MOVFF  FEF,24F
3264:  CLRF   03
3266:  MOVF   x3E,W
3268:  ADDLW  22
326A:  MOVWF  FE9
326C:  MOVLW  02
326E:  ADDWFC 03,W
3270:  MOVWF  FEA
3272:  MOVF   FEF,W
3274:  MULLW  08
3276:  MOVF   FF3,W
3278:  ADDWF  x4F,W
327A:  MOVLB  1
327C:  BTFSC  x5E.7
327E:  BRA    3284
3280:  SUBWF  x5E,W
3282:  BC    331E
3284:  CLRF   03
3286:  MOVLB  2
3288:  MOVF   x3E,W
328A:  ADDLW  C8
328C:  MOVWF  FE9
328E:  MOVLW  01
3290:  ADDWFC 03,W
3292:  MOVWF  FEA
3294:  MOVF   FEF,W
3296:  MOVLB  1
3298:  BTFSC  x5F.7
329A:  BRA    331E
329C:  SUBWF  x5F,W
329E:  BZ    331E
32A0:  BNC   331E
32A2:  CLRF   03
32A4:  MOVLB  2
32A6:  MOVF   x3E,W
32A8:  ADDLW  C8
32AA:  MOVWF  FE9
32AC:  MOVLW  01
32AE:  ADDWFC 03,W
32B0:  MOVWF  FEA
32B2:  MOVFF  FEF,24F
32B6:  CLRF   03
32B8:  MOVF   x3E,W
32BA:  ADDLW  22
32BC:  MOVWF  FE9
32BE:  MOVLW  02
32C0:  ADDWFC 03,W
32C2:  MOVWF  FEA
32C4:  MOVF   FEF,W
32C6:  MULLW  08
32C8:  MOVF   FF3,W
32CA:  ADDWF  x4F,W
32CC:  MOVLB  1
32CE:  BTFSC  x5F.7
32D0:  BRA    32D6
32D2:  SUBWF  x5F,W
32D4:  BC    331E
....................                      {
....................                         score += (4 - asteroids_lifes[i]);
32D6:  CLRF   03
32D8:  MOVLB  2
32DA:  MOVF   x3E,W
32DC:  ADDLW  22
32DE:  MOVWF  FE9
32E0:  MOVLW  02
32E2:  ADDWFC 03,W
32E4:  MOVWF  FEA
32E6:  MOVF   FEF,W
32E8:  XORLW  FF
32EA:  ADDLW  05
32EC:  ADDWF  x06,F
32EE:  MOVLW  00
32F0:  ADDWFC x07,F
....................                         asteroids_lifes[i]--;
32F2:  CLRF   03
32F4:  MOVF   x3E,W
32F6:  ADDLW  22
32F8:  MOVWF  FE9
32FA:  MOVLW  02
32FC:  ADDWFC 03,W
32FE:  MOVWF  FEA
3300:  DECF   FEF,F
....................                         asteroid_lost_a_life[i] = 1;
3302:  MOVFF  23E,24F
3306:  MOVLW  01
3308:  MOVWF  x50
330A:  MOVLW  02
330C:  MOVWF  x52
330E:  MOVLW  36
3310:  MOVWF  x51
3312:  MOVLB  0
3314:  CALL   193C
....................                         bullet_collision = 1;
3318:  MOVLB  2
331A:  BSF    x20.2
331C:  MOVLB  1
....................                      }
....................                   }
331E:  MOVLB  2
3320:  INCF   x3E,F
3322:  BRA    3164
....................                }
.................... 
....................                glcd_line(last_last_bullet_x_pos, last_last_bullet_y_pos, last_bullet_x_pos, last_bullet_y_pos, 0);
3324:  MOVFF  15C,275
3328:  MOVFF  15D,276
332C:  MOVFF  15E,277
3330:  MOVFF  15F,278
3334:  CLRF   x79
3336:  MOVLB  0
3338:  CALL   0A70
....................                glcd_line(last_bullet_x_pos, last_bullet_y_pos, bullet_x_pos, bullet_y_pos, 1);
333C:  MOVFF  15E,275
3340:  MOVFF  15F,276
3344:  MOVFF  160,277
3348:  MOVFF  162,278
334C:  MOVLW  01
334E:  MOVLB  2
3350:  MOVWF  x79
3352:  MOVLB  0
3354:  CALL   0A70
....................                if (!bullet_collision)
3358:  MOVLB  2
335A:  BTFSC  x20.2
335C:  BRA    33A6
....................                { // si no hay colision, checar si se pierde la bala
....................                   if (bullet_x_pos > 127 || bullet_x_pos < 0 || bullet_y_pos > 63 || bullet_y_pos < 0)
335E:  MOVLB  1
3360:  BTFSC  x61.7
3362:  BRA    336E
3364:  MOVF   x61,F
3366:  BNZ   3384
3368:  MOVF   x60,W
336A:  SUBLW  7F
336C:  BNC   3384
336E:  BTFSC  x61.7
3370:  BRA    3384
3372:  BTFSC  x63.7
3374:  BRA    3380
3376:  MOVF   x63,F
3378:  BNZ   3384
337A:  MOVF   x62,W
337C:  SUBLW  3F
337E:  BNC   3384
3380:  BTFSS  x63.7
3382:  BRA    33A2
....................                   { // bala sali
....................                      bullet = 0;
3384:  BCF    x43.2
....................                      glcd_line(last_bullet_x_pos, last_bullet_y_pos, bullet_x_pos, bullet_y_pos, 0);
3386:  MOVFF  15E,275
338A:  MOVFF  15F,276
338E:  MOVFF  160,277
3392:  MOVFF  162,278
3396:  MOVLB  2
3398:  CLRF   x79
339A:  MOVLB  0
339C:  CALL   0A70
33A0:  MOVLB  1
....................                   }
....................                }
33A2:  BRA    33C8
33A4:  MOVLB  2
....................                else
....................                {
....................                   bullet_collision = 0;
33A6:  BCF    x20.2
....................                   bullet = 0;
33A8:  MOVLB  1
33AA:  BCF    x43.2
....................                   glcd_line(last_bullet_x_pos, last_bullet_y_pos, bullet_x_pos, bullet_y_pos, 0);
33AC:  MOVFF  15E,275
33B0:  MOVFF  15F,276
33B4:  MOVFF  160,277
33B8:  MOVFF  162,278
33BC:  MOVLB  2
33BE:  CLRF   x79
33C0:  MOVLB  0
33C2:  CALL   0A70
33C6:  MOVLB  1
....................                }
....................             }
33C8:  BRA    349C
....................             else
....................             {
....................                if (p1_R)
33CA:  MOVLB  2
33CC:  BTFSS  x10.3
33CE:  BRA    349A
....................                { // disparar si no hay una bala actualmente
....................                   bullet = 1;
33D0:  MOVLB  1
33D2:  BSF    x43.2
....................                   bullet_dx = cos(ship_angle) * (float)bullet_speed; // dispararla segun el angulo q se mira
33D4:  MOVFF  14F,25A
33D8:  MOVFF  14E,259
33DC:  MOVFF  14D,258
33E0:  MOVFF  14C,257
33E4:  MOVLB  0
33E6:  CALL   197E
33EA:  MOVFF  03,252
33EE:  MOVFF  02,251
33F2:  MOVFF  01,250
33F6:  MOVFF  00,24F
33FA:  MOVFF  03,288
33FE:  MOVFF  02,287
3402:  MOVFF  01,286
3406:  MOVFF  00,285
340A:  MOVLB  2
340C:  CLRF   x8C
340E:  CLRF   x8B
3410:  MOVLW  40
3412:  MOVWF  x8A
3414:  MOVLW  81
3416:  MOVWF  x89
3418:  MOVLB  0
341A:  CALL   16E0
341E:  MOVFF  03,167
3422:  MOVFF  02,166
3426:  MOVFF  01,165
342A:  MOVFF  00,164
....................                   bullet_dy = sin(ship_angle) * (float)bullet_speed;
342E:  MOVFF  14F,252
3432:  MOVFF  14E,251
3436:  MOVFF  14D,250
343A:  MOVFF  14C,24F
343E:  GOTO   1CF4
3442:  MOVFF  03,252
3446:  MOVFF  02,251
344A:  MOVFF  01,250
344E:  MOVFF  00,24F
3452:  MOVFF  03,288
3456:  MOVFF  02,287
345A:  MOVFF  01,286
345E:  MOVFF  00,285
3462:  MOVLB  2
3464:  CLRF   x8C
3466:  CLRF   x8B
3468:  MOVLW  40
346A:  MOVWF  x8A
346C:  MOVLW  81
346E:  MOVWF  x89
3470:  MOVLB  0
3472:  CALL   16E0
3476:  MOVFF  03,16B
347A:  MOVFF  02,16A
347E:  MOVFF  01,169
3482:  MOVFF  00,168
....................                   bullet_x_pos = x_pos;
3486:  MOVLB  1
3488:  MOVFF  152,160
348C:  CLRF   x61
....................                   bullet_y_pos = y_pos;
348E:  MOVFF  153,162
3492:  CLRF   x63
....................                   sfx_time = 2;
3494:  MOVLW  02
3496:  MOVLB  2
3498:  MOVWF  x21
349A:  MOVLB  1
....................                }
....................             }
.................... 
....................             for (unsigned int i = 0; i < 20; i++)
349C:  MOVLB  2
349E:  CLRF   x3F
34A0:  MOVF   x3F,W
34A2:  SUBLW  13
34A4:  BTFSS  FD8.0
34A6:  BRA    3686
....................             { // dibuar asteroides actuales
....................                if (asteroids_lifes[i])
34A8:  CLRF   03
34AA:  MOVF   x3F,W
34AC:  ADDLW  22
34AE:  MOVWF  FE9
34B0:  MOVLW  02
34B2:  ADDWFC 03,W
34B4:  MOVWF  FEA
34B6:  MOVF   FEF,F
34B8:  BTFSC  FD8.2
34BA:  BRA    35B4
....................                {
....................                   if (asteroid_lost_a_life[i])
34BC:  MOVFF  23F,24F
34C0:  MOVLW  02
34C2:  MOVWF  x51
34C4:  MOVLW  36
34C6:  MOVWF  x50
34C8:  MOVLB  0
34CA:  CALL   1D44
34CE:  BTFSS  01.0
34D0:  BRA    352E
....................                   {
....................                      draw_asteroid(last_asteroids_x_pos[i], last_asteroids_y_pos[i], asteroids_lifes[i] + 1, 0);
34D2:  CLRF   03
34D4:  MOVLB  2
34D6:  MOVF   x3F,W
34D8:  ADDLW  8C
34DA:  MOVWF  FE9
34DC:  MOVLW  01
34DE:  ADDWFC 03,W
34E0:  MOVWF  FEA
34E2:  MOVFF  FEF,252
34E6:  CLRF   03
34E8:  MOVF   x3F,W
34EA:  ADDLW  A0
34EC:  MOVWF  FE9
34EE:  MOVLW  01
34F0:  ADDWFC 03,W
34F2:  MOVWF  FEA
34F4:  MOVFF  FEF,253
34F8:  CLRF   03
34FA:  MOVF   x3F,W
34FC:  ADDLW  22
34FE:  MOVWF  FE9
3500:  MOVLW  02
3502:  ADDWFC 03,W
3504:  MOVWF  FEA
3506:  MOVLW  01
3508:  ADDWF  FEF,W
350A:  MOVWF  x51
350C:  MOVWF  x54
350E:  CLRF   x55
3510:  MOVLB  0
3512:  CALL   1D7A
....................                      asteroid_lost_a_life[i] = 0;
3516:  MOVFF  23F,24F
351A:  MOVLB  2
351C:  CLRF   x50
351E:  MOVLW  02
3520:  MOVWF  x52
3522:  MOVLW  36
3524:  MOVWF  x51
3526:  MOVLB  0
3528:  CALL   193C
....................                   }
352C:  BRA    356E
....................                   else
....................                   {
....................                      draw_asteroid(last_asteroids_x_pos[i], last_asteroids_y_pos[i], asteroids_lifes[i], 0);
352E:  CLRF   03
3530:  MOVLB  2
3532:  MOVF   x3F,W
3534:  ADDLW  8C
3536:  MOVWF  FE9
3538:  MOVLW  01
353A:  ADDWFC 03,W
353C:  MOVWF  FEA
353E:  MOVFF  FEF,252
3542:  CLRF   03
3544:  MOVF   x3F,W
3546:  ADDLW  A0
3548:  MOVWF  FE9
354A:  MOVLW  01
354C:  ADDWFC 03,W
354E:  MOVWF  FEA
3550:  MOVFF  FEF,253
3554:  CLRF   03
3556:  MOVF   x3F,W
3558:  ADDLW  22
355A:  MOVWF  FE9
355C:  MOVLW  02
355E:  ADDWFC 03,W
3560:  MOVWF  FEA
3562:  MOVFF  FEF,254
3566:  CLRF   x55
3568:  MOVLB  0
356A:  CALL   1D7A
....................                   }
....................                   draw_asteroid(asteroids_x_pos[i], asteroids_y_pos[i], asteroids_lifes[i], 1);
356E:  CLRF   03
3570:  MOVLB  2
3572:  MOVF   x3F,W
3574:  ADDLW  B4
3576:  MOVWF  FE9
3578:  MOVLW  01
357A:  ADDWFC 03,W
357C:  MOVWF  FEA
357E:  MOVFF  FEF,252
3582:  CLRF   03
3584:  MOVF   x3F,W
3586:  ADDLW  C8
3588:  MOVWF  FE9
358A:  MOVLW  01
358C:  ADDWFC 03,W
358E:  MOVWF  FEA
3590:  MOVFF  FEF,253
3594:  CLRF   03
3596:  MOVF   x3F,W
3598:  ADDLW  22
359A:  MOVWF  FE9
359C:  MOVLW  02
359E:  ADDWFC 03,W
35A0:  MOVWF  FEA
35A2:  MOVFF  FEF,254
35A6:  MOVLW  01
35A8:  MOVWF  x55
35AA:  MOVLB  0
35AC:  CALL   1D7A
....................                }
35B0:  BRA    3624
35B2:  MOVLB  2
....................                else
....................                {
....................                   if (asteroid_lost_a_life[i])
35B4:  MOVFF  23F,24F
35B8:  MOVLW  02
35BA:  MOVWF  x51
35BC:  MOVLW  36
35BE:  MOVWF  x50
35C0:  MOVLB  0
35C2:  CALL   1D44
35C6:  BTFSS  01.0
35C8:  BRA    3624
....................                   {
....................                      draw_asteroid(last_asteroids_x_pos[i], last_asteroids_y_pos[i], asteroids_lifes[i] + 1, 0);
35CA:  CLRF   03
35CC:  MOVLB  2
35CE:  MOVF   x3F,W
35D0:  ADDLW  8C
35D2:  MOVWF  FE9
35D4:  MOVLW  01
35D6:  ADDWFC 03,W
35D8:  MOVWF  FEA
35DA:  MOVFF  FEF,252
35DE:  CLRF   03
35E0:  MOVF   x3F,W
35E2:  ADDLW  A0
35E4:  MOVWF  FE9
35E6:  MOVLW  01
35E8:  ADDWFC 03,W
35EA:  MOVWF  FEA
35EC:  MOVFF  FEF,253
35F0:  CLRF   03
35F2:  MOVF   x3F,W
35F4:  ADDLW  22
35F6:  MOVWF  FE9
35F8:  MOVLW  02
35FA:  ADDWFC 03,W
35FC:  MOVWF  FEA
35FE:  MOVLW  01
3600:  ADDWF  FEF,W
3602:  MOVWF  x51
3604:  MOVWF  x54
3606:  CLRF   x55
3608:  MOVLB  0
360A:  CALL   1D7A
....................                      asteroid_lost_a_life[i] = 0;
360E:  MOVFF  23F,24F
3612:  MOVLB  2
3614:  CLRF   x50
3616:  MOVLW  02
3618:  MOVWF  x52
361A:  MOVLW  36
361C:  MOVWF  x51
361E:  MOVLB  0
3620:  CALL   193C
....................                   }
....................                }
....................                last_asteroids_x_pos[i] = asteroids_x_pos[i];
3624:  CLRF   03
3626:  MOVLB  2
3628:  MOVF   x3F,W
362A:  ADDLW  8C
362C:  MOVWF  01
362E:  MOVLW  01
3630:  ADDWFC 03,F
3632:  MOVFF  03,250
3636:  CLRF   03
3638:  MOVF   x3F,W
363A:  ADDLW  B4
363C:  MOVWF  FE9
363E:  MOVLW  01
3640:  ADDWFC 03,W
3642:  MOVWF  FEA
3644:  MOVFF  FEF,251
3648:  MOVFF  250,FEA
364C:  MOVFF  01,FE9
3650:  MOVFF  251,FEF
....................                last_asteroids_y_pos[i] = asteroids_y_pos[i];
3654:  CLRF   03
3656:  MOVF   x3F,W
3658:  ADDLW  A0
365A:  MOVWF  01
365C:  MOVLW  01
365E:  ADDWFC 03,F
3660:  MOVFF  03,250
3664:  CLRF   03
3666:  MOVF   x3F,W
3668:  ADDLW  C8
366A:  MOVWF  FE9
366C:  MOVLW  01
366E:  ADDWFC 03,W
3670:  MOVWF  FEA
3672:  MOVFF  FEF,251
3676:  MOVFF  250,FEA
367A:  MOVFF  01,FE9
367E:  MOVFF  251,FEF
3682:  INCF   x3F,F
3684:  BRA    34A0
....................             }
.................... 
....................             if (bullet)
3686:  MOVLB  1
3688:  BTFSS  x43.2
368A:  BRA    369E
....................             { // dibujar la nueva bala
....................                last_last_bullet_x_pos = last_bullet_x_pos;
368C:  MOVFF  15E,15C
....................                last_last_bullet_y_pos = last_bullet_y_pos;
3690:  MOVFF  15F,15D
....................                last_bullet_x_pos = bullet_x_pos;
3694:  MOVFF  160,15E
....................                last_bullet_y_pos = bullet_y_pos;
3698:  MOVFF  162,15F
....................             }
369C:  BRA    36AE
....................             else
....................             {
....................                last_last_bullet_x_pos = x_pos;
369E:  MOVFF  152,15C
....................                last_last_bullet_y_pos = y_pos;
36A2:  MOVFF  153,15D
....................                last_bullet_x_pos = x_pos;
36A6:  MOVFF  152,15E
....................                last_bullet_y_pos = y_pos;
36AA:  MOVFF  153,15F
....................             }
.................... 
....................             glcd_line(last_x_pos - 1, last_y_pos + 1, last_x_pos + 1, last_y_pos + 1, 0);
36AE:  MOVLW  01
36B0:  SUBWF  x50,W
36B2:  MOVLB  2
36B4:  MOVWF  x4F
36B6:  MOVLW  01
36B8:  MOVLB  1
36BA:  ADDWF  x51,W
36BC:  MOVLB  2
36BE:  MOVWF  x50
36C0:  MOVLW  01
36C2:  MOVLB  1
36C4:  ADDWF  x50,W
36C6:  MOVLB  2
36C8:  MOVWF  x51
36CA:  MOVLW  01
36CC:  MOVLB  1
36CE:  ADDWF  x51,W
36D0:  MOVLB  2
36D2:  MOVWF  x52
36D4:  MOVFF  24F,275
36D8:  MOVFF  250,276
36DC:  MOVFF  251,277
36E0:  MOVWF  x78
36E2:  CLRF   x79
36E4:  MOVLB  0
36E6:  CALL   0A70
....................             glcd_line(last_x_pos - 1, last_y_pos - 1, last_x_pos + 1, last_y_pos - 1, 0);
36EA:  MOVLW  01
36EC:  MOVLB  1
36EE:  SUBWF  x50,W
36F0:  MOVLB  2
36F2:  MOVWF  x4F
36F4:  MOVLW  01
36F6:  MOVLB  1
36F8:  SUBWF  x51,W
36FA:  MOVLB  2
36FC:  MOVWF  x50
36FE:  MOVLW  01
3700:  MOVLB  1
3702:  ADDWF  x50,W
3704:  MOVLB  2
3706:  MOVWF  x51
3708:  MOVLW  01
370A:  MOVLB  1
370C:  SUBWF  x51,W
370E:  MOVLB  2
3710:  MOVWF  x52
3712:  MOVFF  24F,275
3716:  MOVFF  250,276
371A:  MOVFF  251,277
371E:  MOVWF  x78
3720:  CLRF   x79
3722:  MOVLB  0
3724:  CALL   0A70
....................             glcd_line(last_x_pos - 1, last_y_pos + 1, last_x_pos - 1, last_y_pos - 1, 0);
3728:  MOVLW  01
372A:  MOVLB  1
372C:  SUBWF  x50,W
372E:  MOVLB  2
3730:  MOVWF  x4F
3732:  MOVLW  01
3734:  MOVLB  1
3736:  ADDWF  x51,W
3738:  MOVLB  2
373A:  MOVWF  x50
373C:  MOVLW  01
373E:  MOVLB  1
3740:  SUBWF  x50,W
3742:  MOVLB  2
3744:  MOVWF  x51
3746:  MOVLW  01
3748:  MOVLB  1
374A:  SUBWF  x51,W
374C:  MOVLB  2
374E:  MOVWF  x52
3750:  MOVFF  24F,275
3754:  MOVFF  250,276
3758:  MOVFF  251,277
375C:  MOVWF  x78
375E:  CLRF   x79
3760:  MOVLB  0
3762:  CALL   0A70
....................             glcd_line(last_x_pos + 1, last_y_pos + 1, last_x_pos + 1, last_y_pos - 1, 0);
3766:  MOVLW  01
3768:  MOVLB  1
376A:  ADDWF  x50,W
376C:  MOVLB  2
376E:  MOVWF  x4F
3770:  MOVLW  01
3772:  MOVLB  1
3774:  ADDWF  x51,W
3776:  MOVLB  2
3778:  MOVWF  x50
377A:  MOVLW  01
377C:  MOVLB  1
377E:  ADDWF  x50,W
3780:  MOVLB  2
3782:  MOVWF  x51
3784:  MOVLW  01
3786:  MOVLB  1
3788:  SUBWF  x51,W
378A:  MOVLB  2
378C:  MOVWF  x52
378E:  MOVFF  24F,275
3792:  MOVFF  250,276
3796:  MOVFF  251,277
379A:  MOVWF  x78
379C:  CLRF   x79
379E:  MOVLB  0
37A0:  CALL   0A70
.................... 
....................             glcd_line(x_pos - 1, y_pos + 1, x_pos + 1, y_pos + 1, 1);
37A4:  MOVLW  01
37A6:  MOVLB  1
37A8:  SUBWF  x52,W
37AA:  MOVLB  2
37AC:  MOVWF  x4F
37AE:  MOVLW  01
37B0:  MOVLB  1
37B2:  ADDWF  x53,W
37B4:  MOVLB  2
37B6:  MOVWF  x50
37B8:  MOVLW  01
37BA:  MOVLB  1
37BC:  ADDWF  x52,W
37BE:  MOVLB  2
37C0:  MOVWF  x51
37C2:  MOVLW  01
37C4:  MOVLB  1
37C6:  ADDWF  x53,W
37C8:  MOVLB  2
37CA:  MOVWF  x52
37CC:  MOVFF  24F,275
37D0:  MOVFF  250,276
37D4:  MOVFF  251,277
37D8:  MOVWF  x78
37DA:  MOVLW  01
37DC:  MOVWF  x79
37DE:  MOVLB  0
37E0:  CALL   0A70
....................             glcd_line(x_pos - 1, y_pos - 1, x_pos + 1, y_pos - 1, 1);
37E4:  MOVLW  01
37E6:  MOVLB  1
37E8:  SUBWF  x52,W
37EA:  MOVLB  2
37EC:  MOVWF  x4F
37EE:  MOVLW  01
37F0:  MOVLB  1
37F2:  SUBWF  x53,W
37F4:  MOVLB  2
37F6:  MOVWF  x50
37F8:  MOVLW  01
37FA:  MOVLB  1
37FC:  ADDWF  x52,W
37FE:  MOVLB  2
3800:  MOVWF  x51
3802:  MOVLW  01
3804:  MOVLB  1
3806:  SUBWF  x53,W
3808:  MOVLB  2
380A:  MOVWF  x52
380C:  MOVFF  24F,275
3810:  MOVFF  250,276
3814:  MOVFF  251,277
3818:  MOVWF  x78
381A:  MOVLW  01
381C:  MOVWF  x79
381E:  MOVLB  0
3820:  CALL   0A70
....................             glcd_line(x_pos - 1, y_pos + 1, x_pos - 1, y_pos - 1, 1);
3824:  MOVLW  01
3826:  MOVLB  1
3828:  SUBWF  x52,W
382A:  MOVLB  2
382C:  MOVWF  x4F
382E:  MOVLW  01
3830:  MOVLB  1
3832:  ADDWF  x53,W
3834:  MOVLB  2
3836:  MOVWF  x50
3838:  MOVLW  01
383A:  MOVLB  1
383C:  SUBWF  x52,W
383E:  MOVLB  2
3840:  MOVWF  x51
3842:  MOVLW  01
3844:  MOVLB  1
3846:  SUBWF  x53,W
3848:  MOVLB  2
384A:  MOVWF  x52
384C:  MOVFF  24F,275
3850:  MOVFF  250,276
3854:  MOVFF  251,277
3858:  MOVWF  x78
385A:  MOVLW  01
385C:  MOVWF  x79
385E:  MOVLB  0
3860:  CALL   0A70
....................             glcd_line(x_pos + 1, y_pos + 1, x_pos + 1, y_pos - 1, 1);
3864:  MOVLW  01
3866:  MOVLB  1
3868:  ADDWF  x52,W
386A:  MOVLB  2
386C:  MOVWF  x4F
386E:  MOVLW  01
3870:  MOVLB  1
3872:  ADDWF  x53,W
3874:  MOVLB  2
3876:  MOVWF  x50
3878:  MOVLW  01
387A:  MOVLB  1
387C:  ADDWF  x52,W
387E:  MOVLB  2
3880:  MOVWF  x51
3882:  MOVLW  01
3884:  MOVLB  1
3886:  SUBWF  x53,W
3888:  MOVLB  2
388A:  MOVWF  x52
388C:  MOVFF  24F,275
3890:  MOVFF  250,276
3894:  MOVFF  251,277
3898:  MOVWF  x78
389A:  MOVLW  01
389C:  MOVWF  x79
389E:  MOVLB  0
38A0:  CALL   0A70
.................... 
....................             last_ship_angle = ship_angle; // guardar la posicion anterior
38A4:  MOVFF  14F,14B
38A8:  MOVFF  14E,14A
38AC:  MOVFF  14D,149
38B0:  MOVFF  14C,148
....................             last_x_pos = x_pos;
38B4:  MOVFF  152,150
....................             last_y_pos = y_pos;
38B8:  MOVFF  153,151
.................... 
....................             for (int i = 0; i < 20; i++)
38BC:  MOVLB  2
38BE:  CLRF   x40
38C0:  MOVF   x40,W
38C2:  SUBLW  13
38C4:  BNC   38DC
....................             { // checa si ya mataste todos los asteroides
....................                temp += asteroids_lifes[i];
38C6:  CLRF   03
38C8:  MOVF   x40,W
38CA:  ADDLW  22
38CC:  MOVWF  FE9
38CE:  MOVLW  02
38D0:  ADDWFC 03,W
38D2:  MOVWF  FEA
38D4:  MOVF   FEF,W
38D6:  ADDWF  x39,F
38D8:  INCF   x40,F
38DA:  BRA    38C0
....................             }
....................             if (!temp || new_level)
38DC:  MOVF   x39,F
38DE:  BZ    38E8
38E0:  MOVLB  1
38E2:  BTFSS  x43.7
38E4:  BRA    38EC
38E6:  MOVLB  2
....................             {
....................                new_level = 1;
38E8:  MOVLB  1
38EA:  BSF    x43.7
....................                // glcd_fillScreen(1);
....................             }
....................             scores(last_score, last_level, 0);
38EC:  MOVFF  20B,250
38F0:  MOVFF  20A,24F
38F4:  MOVFF  20C,251
38F8:  MOVLB  2
38FA:  CLRF   x52
38FC:  MOVLB  0
38FE:  CALL   21A4
....................             scores(score, level, 1);
3902:  MOVFF  207,250
3906:  MOVFF  206,24F
390A:  MOVFF  204,251
390E:  MOVLW  01
3910:  MOVLB  2
3912:  MOVWF  x52
3914:  MOVLB  0
3916:  CALL   21A4
....................             last_score = score;
391A:  MOVFF  207,20B
391E:  MOVFF  206,20A
....................             last_level = level;
3922:  MOVFF  204,20C
.................... 
....................             delay_ms((int16)(22.0f - ((float)temp * 0.2f))); // manten los frames constantes segun cuantas cosas hayas dibujado
3926:  MOVLB  2
3928:  CLRF   x86
392A:  MOVFF  239,285
392E:  MOVLB  0
3930:  CALL   11AE
3934:  MOVFF  03,252
3938:  MOVFF  02,251
393C:  MOVFF  01,250
3940:  MOVFF  00,24F
3944:  MOVFF  03,288
3948:  MOVFF  02,287
394C:  MOVFF  01,286
3950:  MOVFF  00,285
3954:  MOVLW  CD
3956:  MOVLB  2
3958:  MOVWF  x8C
395A:  MOVLW  CC
395C:  MOVWF  x8B
395E:  MOVLW  4C
3960:  MOVWF  x8A
3962:  MOVLW  7C
3964:  MOVWF  x89
3966:  MOVLB  0
3968:  CALL   16E0
396C:  BSF    FD8.1
396E:  MOVLB  2
3970:  CLRF   x88
3972:  CLRF   x87
3974:  MOVLW  30
3976:  MOVWF  x86
3978:  MOVLW  83
397A:  MOVWF  x85
397C:  MOVFF  03,28C
3980:  MOVFF  02,28B
3984:  MOVFF  01,28A
3988:  MOVFF  00,289
398C:  MOVLB  0
398E:  CALL   13AA
3992:  MOVFF  03,284
3996:  MOVFF  02,283
399A:  MOVFF  01,282
399E:  MOVFF  00,281
39A2:  CALL   1342
39A6:  MOVFF  02,250
39AA:  MOVFF  01,24F
39AE:  MOVFF  02,251
39B2:  MOVLB  2
39B4:  INCF   x51,F
39B6:  DECF   x51,F
39B8:  BTFSC  FD8.2
39BA:  BRA    39C8
39BC:  SETF   x6F
39BE:  MOVLB  0
39C0:  CALL   05EC
39C4:  MOVLB  2
39C6:  BRA    39B6
39C8:  MOVFF  24F,26F
39CC:  MOVLB  0
39CE:  CALL   05EC
.................... 
....................             temp = 0;
39D2:  MOVLB  2
39D4:  CLRF   x39
39D6:  MOVLB  0
....................          }
....................          break;
39D8:  MOVLB  2
39DA:  GOTO   43D4
39DE:  MOVLB  0
....................       }
....................       case 'J':
....................       { // jugando multiplayer
....................          if (new_game)
39E0:  MOVLB  2
39E2:  BTFSS  x20.3
39E4:  BRA    3A00
....................          {
....................             new_game = 0;
39E6:  BCF    x20.3
....................             x_pos_1 = 10;
39E8:  MOVLW  0A
39EA:  MOVLB  1
39EC:  MOVWF  x25
....................             y_pos_1 = 20;
39EE:  MOVLW  14
39F0:  MOVWF  x26
....................             x_pos_2 = 120;
39F2:  MOVLW  78
39F4:  MOVWF  x39
....................             y_pos_2 = 40;
39F6:  MOVLW  28
39F8:  MOVWF  x3A
....................             bullet_1 = 1;
39FA:  BSF    x43.3
....................             bullet_2 = 1;
39FC:  BSF    x43.5
39FE:  MOVLB  2
....................          }
.................... 
....................          dx_1 = get_d(p1_pot_x);        // potenciometro movimiento
3A00:  MOVFF  212,24F
3A04:  MOVLB  0
3A06:  CALL   2232
3A0A:  MOVFF  03,12A
3A0E:  MOVFF  02,129
3A12:  MOVFF  01,128
3A16:  MOVFF  00,127
....................          dy_1 = get_d(p1_pot_y);        // potenciometro movimiento
3A1A:  MOVFF  213,24F
3A1E:  CALL   2232
3A22:  MOVFF  03,12E
3A26:  MOVFF  02,12D
3A2A:  MOVFF  01,12C
3A2E:  MOVFF  00,12B
....................          if ((float)x_pos_1 + dx_1 < 0) // mover jugador
3A32:  MOVLB  2
3A34:  CLRF   x86
3A36:  MOVFF  125,285
3A3A:  MOVLB  0
3A3C:  CALL   11AE
3A40:  MOVFF  03,252
3A44:  MOVFF  02,251
3A48:  MOVFF  01,250
3A4C:  MOVFF  00,24F
3A50:  BCF    FD8.1
3A52:  MOVFF  03,288
3A56:  MOVFF  02,287
3A5A:  MOVFF  01,286
3A5E:  MOVFF  00,285
3A62:  MOVFF  12A,28C
3A66:  MOVFF  129,28B
3A6A:  MOVFF  128,28A
3A6E:  MOVFF  127,289
3A72:  CALL   13AA
3A76:  MOVFF  03,252
3A7A:  MOVFF  02,251
3A7E:  MOVFF  01,250
3A82:  MOVFF  00,24F
3A86:  MOVFF  03,284
3A8A:  MOVFF  02,283
3A8E:  MOVFF  01,282
3A92:  MOVFF  00,281
3A96:  MOVLB  2
3A98:  CLRF   x88
3A9A:  CLRF   x87
3A9C:  CLRF   x86
3A9E:  CLRF   x85
3AA0:  MOVLB  0
3AA2:  CALL   18C2
3AA6:  BNC   3B0C
....................             x_pos_1 = 127 + (int)((float)x_pos_1 + dx_1);
3AA8:  MOVLB  2
3AAA:  CLRF   x86
3AAC:  MOVFF  125,285
3AB0:  MOVLB  0
3AB2:  CALL   11AE
3AB6:  MOVFF  03,252
3ABA:  MOVFF  02,251
3ABE:  MOVFF  01,250
3AC2:  MOVFF  00,24F
3AC6:  BCF    FD8.1
3AC8:  MOVFF  03,288
3ACC:  MOVFF  02,287
3AD0:  MOVFF  01,286
3AD4:  MOVFF  00,285
3AD8:  MOVFF  12A,28C
3ADC:  MOVFF  129,28B
3AE0:  MOVFF  128,28A
3AE4:  MOVFF  127,289
3AE8:  CALL   13AA
3AEC:  MOVFF  03,284
3AF0:  MOVFF  02,283
3AF4:  MOVFF  01,282
3AF8:  MOVFF  00,281
3AFC:  CALL   1342
3B00:  MOVLW  7F
3B02:  ADDWF  01,W
3B04:  MOVLB  1
3B06:  MOVWF  x25
3B08:  BRA    3B3C
3B0A:  MOVLB  0
....................          else
....................             x_pos_1 = (x_pos_1 + (int)dx_1) % 127;
3B0C:  MOVFF  12A,284
3B10:  MOVFF  129,283
3B14:  MOVFF  128,282
3B18:  MOVFF  127,281
3B1C:  CALL   1342
3B20:  MOVF   01,W
3B22:  MOVLB  1
3B24:  ADDWF  x25,W
3B26:  MOVLB  2
3B28:  MOVWF  x50
3B2A:  MOVWF  x5F
3B2C:  MOVLW  7F
3B2E:  MOVWF  x60
3B30:  MOVLB  0
3B32:  CALL   137E
3B36:  MOVFF  00,125
3B3A:  MOVLB  1
.................... 
....................          if ((float)y_pos_1 - dy_1 < 0) // mover jugador
3B3C:  MOVLB  2
3B3E:  CLRF   x86
3B40:  MOVFF  126,285
3B44:  MOVLB  0
3B46:  CALL   11AE
3B4A:  MOVFF  03,252
3B4E:  MOVFF  02,251
3B52:  MOVFF  01,250
3B56:  MOVFF  00,24F
3B5A:  BSF    FD8.1
3B5C:  MOVFF  03,288
3B60:  MOVFF  02,287
3B64:  MOVFF  01,286
3B68:  MOVFF  00,285
3B6C:  MOVFF  12E,28C
3B70:  MOVFF  12D,28B
3B74:  MOVFF  12C,28A
3B78:  MOVFF  12B,289
3B7C:  CALL   13AA
3B80:  MOVFF  03,252
3B84:  MOVFF  02,251
3B88:  MOVFF  01,250
3B8C:  MOVFF  00,24F
3B90:  MOVFF  03,284
3B94:  MOVFF  02,283
3B98:  MOVFF  01,282
3B9C:  MOVFF  00,281
3BA0:  MOVLB  2
3BA2:  CLRF   x88
3BA4:  CLRF   x87
3BA6:  CLRF   x86
3BA8:  CLRF   x85
3BAA:  MOVLB  0
3BAC:  CALL   18C2
3BB0:  BNC   3C16
....................             y_pos_1 = 63 + (int)((float)y_pos_1 - dy_1);
3BB2:  MOVLB  2
3BB4:  CLRF   x86
3BB6:  MOVFF  126,285
3BBA:  MOVLB  0
3BBC:  CALL   11AE
3BC0:  MOVFF  03,252
3BC4:  MOVFF  02,251
3BC8:  MOVFF  01,250
3BCC:  MOVFF  00,24F
3BD0:  BSF    FD8.1
3BD2:  MOVFF  03,288
3BD6:  MOVFF  02,287
3BDA:  MOVFF  01,286
3BDE:  MOVFF  00,285
3BE2:  MOVFF  12E,28C
3BE6:  MOVFF  12D,28B
3BEA:  MOVFF  12C,28A
3BEE:  MOVFF  12B,289
3BF2:  CALL   13AA
3BF6:  MOVFF  03,284
3BFA:  MOVFF  02,283
3BFE:  MOVFF  01,282
3C02:  MOVFF  00,281
3C06:  CALL   1342
3C0A:  MOVLW  3F
3C0C:  ADDWF  01,W
3C0E:  MOVLB  1
3C10:  MOVWF  x26
3C12:  BRA    3C46
3C14:  MOVLB  0
....................          else
....................             y_pos_1 = (y_pos_1 - (int)dy_1) % 63;
3C16:  MOVFF  12E,284
3C1A:  MOVFF  12D,283
3C1E:  MOVFF  12C,282
3C22:  MOVFF  12B,281
3C26:  CALL   1342
3C2A:  MOVF   01,W
3C2C:  MOVLB  1
3C2E:  SUBWF  x26,W
3C30:  MOVLB  2
3C32:  MOVWF  x50
3C34:  MOVWF  x5F
3C36:  MOVLW  3F
3C38:  MOVWF  x60
3C3A:  MOVLB  0
3C3C:  CALL   137E
3C40:  MOVFF  00,126
3C44:  MOVLB  1
.................... 
....................          dx_2 = get_d(p2_pot_x);        // potenciometro movimiento
3C46:  MOVFF  216,24F
3C4A:  MOVLB  0
3C4C:  CALL   2232
3C50:  MOVFF  03,13E
3C54:  MOVFF  02,13D
3C58:  MOVFF  01,13C
3C5C:  MOVFF  00,13B
....................          dy_2 = get_d(p2_pot_y);        // potenciometro movimiento
3C60:  MOVFF  217,24F
3C64:  CALL   2232
3C68:  MOVFF  03,142
3C6C:  MOVFF  02,141
3C70:  MOVFF  01,140
3C74:  MOVFF  00,13F
....................          if ((float)x_pos_2 + dx_2 < 0) // mover jugador
3C78:  MOVLB  2
3C7A:  CLRF   x86
3C7C:  MOVFF  139,285
3C80:  MOVLB  0
3C82:  CALL   11AE
3C86:  MOVFF  03,252
3C8A:  MOVFF  02,251
3C8E:  MOVFF  01,250
3C92:  MOVFF  00,24F
3C96:  BCF    FD8.1
3C98:  MOVFF  03,288
3C9C:  MOVFF  02,287
3CA0:  MOVFF  01,286
3CA4:  MOVFF  00,285
3CA8:  MOVFF  13E,28C
3CAC:  MOVFF  13D,28B
3CB0:  MOVFF  13C,28A
3CB4:  MOVFF  13B,289
3CB8:  CALL   13AA
3CBC:  MOVFF  03,252
3CC0:  MOVFF  02,251
3CC4:  MOVFF  01,250
3CC8:  MOVFF  00,24F
3CCC:  MOVFF  03,284
3CD0:  MOVFF  02,283
3CD4:  MOVFF  01,282
3CD8:  MOVFF  00,281
3CDC:  MOVLB  2
3CDE:  CLRF   x88
3CE0:  CLRF   x87
3CE2:  CLRF   x86
3CE4:  CLRF   x85
3CE6:  MOVLB  0
3CE8:  CALL   18C2
3CEC:  BNC   3D52
....................             x_pos_2 = 127 + (int)((float)x_pos_2 + dx_2);
3CEE:  MOVLB  2
3CF0:  CLRF   x86
3CF2:  MOVFF  139,285
3CF6:  MOVLB  0
3CF8:  CALL   11AE
3CFC:  MOVFF  03,252
3D00:  MOVFF  02,251
3D04:  MOVFF  01,250
3D08:  MOVFF  00,24F
3D0C:  BCF    FD8.1
3D0E:  MOVFF  03,288
3D12:  MOVFF  02,287
3D16:  MOVFF  01,286
3D1A:  MOVFF  00,285
3D1E:  MOVFF  13E,28C
3D22:  MOVFF  13D,28B
3D26:  MOVFF  13C,28A
3D2A:  MOVFF  13B,289
3D2E:  CALL   13AA
3D32:  MOVFF  03,284
3D36:  MOVFF  02,283
3D3A:  MOVFF  01,282
3D3E:  MOVFF  00,281
3D42:  CALL   1342
3D46:  MOVLW  7F
3D48:  ADDWF  01,W
3D4A:  MOVLB  1
3D4C:  MOVWF  x39
3D4E:  BRA    3D82
3D50:  MOVLB  0
....................          else
....................             x_pos_2 = (x_pos_2 + (int)dx_2) % 127;
3D52:  MOVFF  13E,284
3D56:  MOVFF  13D,283
3D5A:  MOVFF  13C,282
3D5E:  MOVFF  13B,281
3D62:  CALL   1342
3D66:  MOVF   01,W
3D68:  MOVLB  1
3D6A:  ADDWF  x39,W
3D6C:  MOVLB  2
3D6E:  MOVWF  x50
3D70:  MOVWF  x5F
3D72:  MOVLW  7F
3D74:  MOVWF  x60
3D76:  MOVLB  0
3D78:  CALL   137E
3D7C:  MOVFF  00,139
3D80:  MOVLB  1
.................... 
....................          if ((float)y_pos_2 - dy_2 < 0) // mover jugador
3D82:  MOVLB  2
3D84:  CLRF   x86
3D86:  MOVFF  13A,285
3D8A:  MOVLB  0
3D8C:  CALL   11AE
3D90:  MOVFF  03,252
3D94:  MOVFF  02,251
3D98:  MOVFF  01,250
3D9C:  MOVFF  00,24F
3DA0:  BSF    FD8.1
3DA2:  MOVFF  03,288
3DA6:  MOVFF  02,287
3DAA:  MOVFF  01,286
3DAE:  MOVFF  00,285
3DB2:  MOVFF  142,28C
3DB6:  MOVFF  141,28B
3DBA:  MOVFF  140,28A
3DBE:  MOVFF  13F,289
3DC2:  CALL   13AA
3DC6:  MOVFF  03,252
3DCA:  MOVFF  02,251
3DCE:  MOVFF  01,250
3DD2:  MOVFF  00,24F
3DD6:  MOVFF  03,284
3DDA:  MOVFF  02,283
3DDE:  MOVFF  01,282
3DE2:  MOVFF  00,281
3DE6:  MOVLB  2
3DE8:  CLRF   x88
3DEA:  CLRF   x87
3DEC:  CLRF   x86
3DEE:  CLRF   x85
3DF0:  MOVLB  0
3DF2:  CALL   18C2
3DF6:  BNC   3E5C
....................             y_pos_2 = 63 + (int)((float)y_pos_2 - dy_2);
3DF8:  MOVLB  2
3DFA:  CLRF   x86
3DFC:  MOVFF  13A,285
3E00:  MOVLB  0
3E02:  CALL   11AE
3E06:  MOVFF  03,252
3E0A:  MOVFF  02,251
3E0E:  MOVFF  01,250
3E12:  MOVFF  00,24F
3E16:  BSF    FD8.1
3E18:  MOVFF  03,288
3E1C:  MOVFF  02,287
3E20:  MOVFF  01,286
3E24:  MOVFF  00,285
3E28:  MOVFF  142,28C
3E2C:  MOVFF  141,28B
3E30:  MOVFF  140,28A
3E34:  MOVFF  13F,289
3E38:  CALL   13AA
3E3C:  MOVFF  03,284
3E40:  MOVFF  02,283
3E44:  MOVFF  01,282
3E48:  MOVFF  00,281
3E4C:  CALL   1342
3E50:  MOVLW  3F
3E52:  ADDWF  01,W
3E54:  MOVLB  1
3E56:  MOVWF  x3A
3E58:  BRA    3E8C
3E5A:  MOVLB  0
....................          else
....................             y_pos_2 = (y_pos_2 - (int)dy_2) % 63;
3E5C:  MOVFF  142,284
3E60:  MOVFF  141,283
3E64:  MOVFF  140,282
3E68:  MOVFF  13F,281
3E6C:  CALL   1342
3E70:  MOVF   01,W
3E72:  MOVLB  1
3E74:  SUBWF  x3A,W
3E76:  MOVLB  2
3E78:  MOVWF  x50
3E7A:  MOVWF  x5F
3E7C:  MOVLW  3F
3E7E:  MOVWF  x60
3E80:  MOVLB  0
3E82:  CALL   137E
3E86:  MOVFF  00,13A
3E8A:  MOVLB  1
.................... 
....................          if(shoot_1){
3E8C:  BTFSS  x43.0
3E8E:  BRA    3E94
....................             cooldown_1 = 0;
3E90:  CLRF   x44
....................          }
3E92:  BRA    3F2E
....................          else{
....................             cooldown_1--;
3E94:  DECF   x44,F
....................             if(cooldown_1 == 0){
3E96:  MOVF   x44,F
3E98:  BNZ   3E9C
....................                shoot_1 = 1;
3E9A:  BSF    x43.0
....................             }
....................             if(cooldown_1 == 10){
3E9C:  MOVF   x44,W
3E9E:  SUBLW  0A
3EA0:  BNZ   3F2E
....................                switch(aiming_1){
3EA2:  MOVF   x45,W
3EA4:  ADDLW  FB
3EA6:  BC    3F2E
3EA8:  ADDLW  05
3EAA:  MOVLB  0
3EAC:  GOTO   43E2
....................                   case 0: 
....................                   case 1:{
....................                      glcd_line(last_bullet_x_pos_1, last_bullet_y_pos_1, 128, last_bullet_y_pos_1, 0);
3EB0:  MOVFF  16E,275
3EB4:  MOVFF  16F,276
3EB8:  MOVLW  80
3EBA:  MOVLB  2
3EBC:  MOVWF  x77
3EBE:  MOVFF  16F,278
3EC2:  CLRF   x79
3EC4:  MOVLB  0
3EC6:  CALL   0A70
....................                      break;
3ECA:  MOVLB  1
3ECC:  BRA    3F2E
3ECE:  MOVLB  0
....................                   }
....................                   case 2:{
....................                      glcd_line(last_bullet_x_pos_1, last_bullet_y_pos_1, last_bullet_x_pos_1, 0, 0);
3ED0:  MOVFF  16E,275
3ED4:  MOVFF  16F,276
3ED8:  MOVFF  16E,277
3EDC:  MOVLB  2
3EDE:  CLRF   x78
3EE0:  CLRF   x79
3EE2:  MOVLB  0
3EE4:  CALL   0A70
....................                      break;
3EE8:  MOVLB  1
3EEA:  BRA    3F2E
3EEC:  MOVLB  0
....................                   }
....................                   case 3:{
....................                      glcd_line(0, last_bullet_y_pos_1, last_bullet_x_pos_1, last_bullet_y_pos_1, 0);
3EEE:  MOVLB  2
3EF0:  CLRF   x75
3EF2:  MOVFF  16F,276
3EF6:  MOVFF  16E,277
3EFA:  MOVFF  16F,278
3EFE:  CLRF   x79
3F00:  MOVLB  0
3F02:  CALL   0A70
....................                      break;
3F06:  MOVLB  1
3F08:  BRA    3F2E
3F0A:  MOVLB  0
....................                   }
....................                   case 4:{
....................                      glcd_line(last_bullet_x_pos_1, last_bullet_y_pos_1, last_bullet_x_pos_1, 63, 0);
3F0C:  MOVFF  16E,275
3F10:  MOVFF  16F,276
3F14:  MOVFF  16E,277
3F18:  MOVLW  3F
3F1A:  MOVLB  2
3F1C:  MOVWF  x78
3F1E:  CLRF   x79
3F20:  MOVLB  0
3F22:  CALL   0A70
....................                      break;
3F26:  MOVLB  1
3F28:  BRA    3F2E
3F2A:  MOVLB  0
3F2C:  MOVLB  1
....................                   }
....................                }
....................             }
....................          }
.................... 
....................          if(p1_L && shoot_1){
3F2E:  MOVLB  2
3F30:  BTFSS  x10.2
3F32:  BRA    40A8
3F34:  MOVLB  1
3F36:  BTFSC  x43.0
3F38:  BRA    3F3E
3F3A:  MOVLB  2
3F3C:  BRA    40A8
....................             aiming_1 = laser_waza(p1_pot_xx, p1_pot_yy);
3F3E:  MOVFF  214,24F
3F42:  MOVFF  215,250
3F46:  MOVLB  0
3F48:  CALL   22AC
3F4C:  MOVFF  01,145
....................             switch(aiming_1){
3F50:  MOVLB  1
3F52:  MOVF   x45,W
3F54:  ADDLW  FB
3F56:  BTFSC  FD8.0
3F58:  BRA    4098
3F5A:  ADDLW  05
3F5C:  MOVLB  0
3F5E:  GOTO   4406
....................                case 0: 
....................                case 1:{
....................                   glcd_line(x_pos_1, y_pos_1, 128, y_pos_1, 1);
3F62:  MOVFF  125,275
3F66:  MOVFF  126,276
3F6A:  MOVLW  80
3F6C:  MOVLB  2
3F6E:  MOVWF  x77
3F70:  MOVFF  126,278
3F74:  MOVLW  01
3F76:  MOVWF  x79
3F78:  MOVLB  0
3F7A:  CALL   0A70
....................                   if(x_pos_2 > x_pos_1){
3F7E:  MOVLB  1
3F80:  MOVF   x39,W
3F82:  SUBWF  x25,W
3F84:  BC    3FAC
....................                      if( (y_pos_2 < (y_pos_1 + 4)) && (y_pos_2 > (y_pos_1 - 4))){
3F86:  MOVLW  04
3F88:  ADDWF  x26,W
3F8A:  SUBWF  x3A,W
3F8C:  BC    3FAC
3F8E:  MOVLW  04
3F90:  SUBWF  x26,W
3F92:  SUBWF  x3A,W
3F94:  BZ    3FAC
3F96:  BNC   3FAC
....................                         new_game = 1;
3F98:  MOVLB  2
3F9A:  BSF    x20.3
....................                         mode = 'i';
3F9C:  MOVLW  69
3F9E:  MOVWF  x0E
....................                         draw_win(1);
3FA0:  MOVLW  01
3FA2:  MOVWF  x4F
3FA4:  MOVLB  0
3FA6:  CALL   22EA
3FAA:  MOVLB  1
....................                      }
....................                   }
....................                   break;
3FAC:  BRA    4098
3FAE:  MOVLB  0
....................                }
....................                case 2:{
....................                   glcd_line(x_pos_1, y_pos_1, x_pos_1, 0, 1);
3FB0:  MOVFF  125,275
3FB4:  MOVFF  126,276
3FB8:  MOVFF  125,277
3FBC:  MOVLB  2
3FBE:  CLRF   x78
3FC0:  MOVLW  01
3FC2:  MOVWF  x79
3FC4:  MOVLB  0
3FC6:  CALL   0A70
....................                   if(y_pos_2 > y_pos_1){
3FCA:  MOVLB  1
3FCC:  MOVF   x3A,W
3FCE:  SUBWF  x26,W
3FD0:  BC    3FF8
....................                      if( (x_pos_2 < (x_pos_1 + 4)) && (x_pos_2 > (x_pos_1 - 4))){
3FD2:  MOVLW  04
3FD4:  ADDWF  x25,W
3FD6:  SUBWF  x39,W
3FD8:  BC    3FF8
3FDA:  MOVLW  04
3FDC:  SUBWF  x25,W
3FDE:  SUBWF  x39,W
3FE0:  BZ    3FF8
3FE2:  BNC   3FF8
....................                         new_game = 1;
3FE4:  MOVLB  2
3FE6:  BSF    x20.3
....................                         mode = 'i';
3FE8:  MOVLW  69
3FEA:  MOVWF  x0E
....................                         draw_win(1);
3FEC:  MOVLW  01
3FEE:  MOVWF  x4F
3FF0:  MOVLB  0
3FF2:  CALL   22EA
3FF6:  MOVLB  1
....................                      }
....................                   }
....................                   break;
3FF8:  BRA    4098
3FFA:  MOVLB  0
....................                }
....................                case 3:{
....................                   glcd_line(0, y_pos_1, x_pos_1, y_pos_1, 1);
3FFC:  MOVLB  2
3FFE:  CLRF   x75
4000:  MOVFF  126,276
4004:  MOVFF  125,277
4008:  MOVFF  126,278
400C:  MOVLW  01
400E:  MOVWF  x79
4010:  MOVLB  0
4012:  CALL   0A70
....................                   if(x_pos_2 < x_pos_1){
4016:  MOVLB  1
4018:  MOVF   x25,W
401A:  SUBWF  x39,W
401C:  BC    4044
....................                      if( (y_pos_2 < (y_pos_1 + 4)) && (y_pos_2 > (y_pos_1 - 4))){
401E:  MOVLW  04
4020:  ADDWF  x26,W
4022:  SUBWF  x3A,W
4024:  BC    4044
4026:  MOVLW  04
4028:  SUBWF  x26,W
402A:  SUBWF  x3A,W
402C:  BZ    4044
402E:  BNC   4044
....................                         new_game = 1;
4030:  MOVLB  2
4032:  BSF    x20.3
....................                         mode = 'i';
4034:  MOVLW  69
4036:  MOVWF  x0E
....................                         draw_win(1);
4038:  MOVLW  01
403A:  MOVWF  x4F
403C:  MOVLB  0
403E:  CALL   22EA
4042:  MOVLB  1
....................                      }
....................                   }
....................                   break;
4044:  BRA    4098
4046:  MOVLB  0
....................                }
....................                case 4:{
....................                   glcd_line(x_pos_1, y_pos_1, x_pos_1, 63, 1);
4048:  MOVFF  125,275
404C:  MOVFF  126,276
4050:  MOVFF  125,277
4054:  MOVLW  3F
4056:  MOVLB  2
4058:  MOVWF  x78
405A:  MOVLW  01
405C:  MOVWF  x79
405E:  MOVLB  0
4060:  CALL   0A70
....................                   if(y_pos_2 < y_pos_1){
4064:  MOVLB  1
4066:  MOVF   x26,W
4068:  SUBWF  x3A,W
406A:  BC    4092
....................                      if( (x_pos_2 < (x_pos_1 + 4)) && (x_pos_2 > (x_pos_1 - 4))){
406C:  MOVLW  04
406E:  ADDWF  x25,W
4070:  SUBWF  x39,W
4072:  BC    4092
4074:  MOVLW  04
4076:  SUBWF  x25,W
4078:  SUBWF  x39,W
407A:  BZ    4092
407C:  BNC   4092
....................                         new_game = 1;
407E:  MOVLB  2
4080:  BSF    x20.3
....................                         mode = 'i';
4082:  MOVLW  69
4084:  MOVWF  x0E
....................                         draw_win(1);
4086:  MOVLW  01
4088:  MOVWF  x4F
408A:  MOVLB  0
408C:  CALL   22EA
4090:  MOVLB  1
....................                      }
....................                   }
....................                   break;
4092:  BRA    4098
4094:  MOVLB  0
4096:  MOVLB  1
....................                }
....................             }
....................             cooldown_1 = 15;
4098:  MOVLW  0F
409A:  MOVWF  x44
....................             shoot_1 = 0;
409C:  BCF    x43.0
....................             last_bullet_x_pos_1 = x_pos_1;
409E:  MOVFF  125,16E
....................             last_bullet_y_pos_1 = y_pos_1;
40A2:  MOVFF  126,16F
40A6:  MOVLB  2
.................... 
....................          }
.................... 
....................          if(shoot_2){
40A8:  MOVLB  1
40AA:  BTFSS  x43.1
40AC:  BRA    40B2
....................             cooldown_2 = 0;
40AE:  CLRF   x46
....................          }
40B0:  BRA    414C
....................          else{
....................             cooldown_2--;
40B2:  DECF   x46,F
....................             if(cooldown_2 == 0){
40B4:  MOVF   x46,F
40B6:  BNZ   40BA
....................                shoot_2 = 1;
40B8:  BSF    x43.1
....................             }
....................             if(cooldown_2 == 10){
40BA:  MOVF   x46,W
40BC:  SUBLW  0A
40BE:  BNZ   414C
....................                switch(aiming_2){
40C0:  MOVF   x47,W
40C2:  ADDLW  FB
40C4:  BC    414C
40C6:  ADDLW  05
40C8:  MOVLB  0
40CA:  GOTO   442A
....................                   case 0: 
....................                   case 1:{
....................                      glcd_line(last_bullet_x_pos_2, last_bullet_y_pos_2, 128, last_bullet_y_pos_2, 0);
40CE:  MOVFF  17E,275
40D2:  MOVFF  17F,276
40D6:  MOVLW  80
40D8:  MOVLB  2
40DA:  MOVWF  x77
40DC:  MOVFF  17F,278
40E0:  CLRF   x79
40E2:  MOVLB  0
40E4:  CALL   0A70
....................                      break;
40E8:  MOVLB  1
40EA:  BRA    414C
40EC:  MOVLB  0
....................                   }
....................                   case 2:{
....................                      glcd_line(last_bullet_x_pos_2, last_bullet_y_pos_2, last_bullet_x_pos_2, 0, 0);
40EE:  MOVFF  17E,275
40F2:  MOVFF  17F,276
40F6:  MOVFF  17E,277
40FA:  MOVLB  2
40FC:  CLRF   x78
40FE:  CLRF   x79
4100:  MOVLB  0
4102:  CALL   0A70
....................                      break;
4106:  MOVLB  1
4108:  BRA    414C
410A:  MOVLB  0
....................                   }
....................                   case 3:{
....................                      glcd_line(0, last_bullet_y_pos_2, last_bullet_x_pos_2, last_bullet_y_pos_2, 0);
410C:  MOVLB  2
410E:  CLRF   x75
4110:  MOVFF  17F,276
4114:  MOVFF  17E,277
4118:  MOVFF  17F,278
411C:  CLRF   x79
411E:  MOVLB  0
4120:  CALL   0A70
....................                      break;
4124:  MOVLB  1
4126:  BRA    414C
4128:  MOVLB  0
....................                   }
....................                   case 4:{
....................                      glcd_line(last_bullet_x_pos_2, last_bullet_y_pos_2, last_bullet_x_pos_2, 63, 0);
412A:  MOVFF  17E,275
412E:  MOVFF  17F,276
4132:  MOVFF  17E,277
4136:  MOVLW  3F
4138:  MOVLB  2
413A:  MOVWF  x78
413C:  CLRF   x79
413E:  MOVLB  0
4140:  CALL   0A70
....................                      break;
4144:  MOVLB  1
4146:  BRA    414C
4148:  MOVLB  0
414A:  MOVLB  1
....................                   }
....................                }
....................             }
....................          }
.................... 
....................          if(p2_L && shoot_2){
414C:  MOVLB  2
414E:  BTFSS  x10.4
4150:  BRA    42BE
4152:  MOVLB  1
4154:  BTFSC  x43.1
4156:  BRA    415C
4158:  MOVLB  2
415A:  BRA    42BE
....................             aiming_2 = laser_waza(p2_pot_xx, p2_pot_yy);
415C:  MOVFF  218,24F
4160:  MOVFF  219,250
4164:  MOVLB  0
4166:  CALL   22AC
416A:  MOVFF  01,147
....................             switch(aiming_2){
416E:  MOVLB  1
4170:  MOVF   x47,W
4172:  ADDLW  FB
4174:  BTFSC  FD8.0
4176:  BRA    42AE
4178:  ADDLW  05
417A:  MOVLB  0
417C:  GOTO   444E
....................                case 0: 
....................                case 1:{
....................                   glcd_line(x_pos_2, y_pos_2, 128, y_pos_2, 1);
4180:  MOVFF  139,275
4184:  MOVFF  13A,276
4188:  MOVLW  80
418A:  MOVLB  2
418C:  MOVWF  x77
418E:  MOVFF  13A,278
4192:  MOVLW  01
4194:  MOVWF  x79
4196:  MOVLB  0
4198:  CALL   0A70
....................                   if(x_pos_1 > x_pos_2){
419C:  MOVLB  1
419E:  MOVF   x25,W
41A0:  SUBWF  x39,W
41A2:  BC    41C8
....................                      if( (y_pos_1 < (y_pos_2 + 4)) && (y_pos_1 > (y_pos_2 - 4))){
41A4:  MOVLW  04
41A6:  ADDWF  x3A,W
41A8:  SUBWF  x26,W
41AA:  BC    41C8
41AC:  MOVLW  04
41AE:  SUBWF  x3A,W
41B0:  SUBWF  x26,W
41B2:  BZ    41C8
41B4:  BNC   41C8
....................                         new_game = 1;
41B6:  MOVLB  2
41B8:  BSF    x20.3
....................                         mode = 'i';
41BA:  MOVLW  69
41BC:  MOVWF  x0E
....................                         draw_win(0);
41BE:  CLRF   x4F
41C0:  MOVLB  0
41C2:  CALL   22EA
41C6:  MOVLB  1
....................                      }
....................                   }
....................                   break;
41C8:  BRA    42AE
41CA:  MOVLB  0
....................                }
....................                case 2:{
....................                   glcd_line(x_pos_2, y_pos_2, x_pos_2, 0, 1);
41CC:  MOVFF  139,275
41D0:  MOVFF  13A,276
41D4:  MOVFF  139,277
41D8:  MOVLB  2
41DA:  CLRF   x78
41DC:  MOVLW  01
41DE:  MOVWF  x79
41E0:  MOVLB  0
41E2:  CALL   0A70
....................                   if(y_pos_1 > y_pos_2){
41E6:  MOVLB  1
41E8:  MOVF   x26,W
41EA:  SUBWF  x3A,W
41EC:  BC    4212
....................                      if( (x_pos_1 < (x_pos_2 + 4)) && (x_pos_1 > (x_pos_2 - 4))){
41EE:  MOVLW  04
41F0:  ADDWF  x39,W
41F2:  SUBWF  x25,W
41F4:  BC    4212
41F6:  MOVLW  04
41F8:  SUBWF  x39,W
41FA:  SUBWF  x25,W
41FC:  BZ    4212
41FE:  BNC   4212
....................                         new_game = 1;
4200:  MOVLB  2
4202:  BSF    x20.3
....................                         mode = 'i';
4204:  MOVLW  69
4206:  MOVWF  x0E
....................                         draw_win(0);
4208:  CLRF   x4F
420A:  MOVLB  0
420C:  CALL   22EA
4210:  MOVLB  1
....................                      }
....................                   }
....................                   break;
4212:  BRA    42AE
4214:  MOVLB  0
....................                }
....................                case 3:{
....................                   glcd_line(0, y_pos_2, x_pos_2, y_pos_2, 1);
4216:  MOVLB  2
4218:  CLRF   x75
421A:  MOVFF  13A,276
421E:  MOVFF  139,277
4222:  MOVFF  13A,278
4226:  MOVLW  01
4228:  MOVWF  x79
422A:  MOVLB  0
422C:  CALL   0A70
....................                   if(x_pos_1 < x_pos_2){
4230:  MOVLB  1
4232:  MOVF   x39,W
4234:  SUBWF  x25,W
4236:  BC    425C
....................                      if( (y_pos_1 < (y_pos_2 + 4)) && (y_pos_1 > (y_pos_2 - 4))){
4238:  MOVLW  04
423A:  ADDWF  x3A,W
423C:  SUBWF  x26,W
423E:  BC    425C
4240:  MOVLW  04
4242:  SUBWF  x3A,W
4244:  SUBWF  x26,W
4246:  BZ    425C
4248:  BNC   425C
....................                         new_game = 1;
424A:  MOVLB  2
424C:  BSF    x20.3
....................                         mode = 'i';
424E:  MOVLW  69
4250:  MOVWF  x0E
....................                         draw_win(0);
4252:  CLRF   x4F
4254:  MOVLB  0
4256:  CALL   22EA
425A:  MOVLB  1
....................                      }
....................                   }
....................                   break;
425C:  BRA    42AE
425E:  MOVLB  0
....................                }
....................                case 4:{
....................                   glcd_line(x_pos_2, y_pos_2, x_pos_2, 63, 1);
4260:  MOVFF  139,275
4264:  MOVFF  13A,276
4268:  MOVFF  139,277
426C:  MOVLW  3F
426E:  MOVLB  2
4270:  MOVWF  x78
4272:  MOVLW  01
4274:  MOVWF  x79
4276:  MOVLB  0
4278:  CALL   0A70
....................                   if(y_pos_1 < y_pos_2){
427C:  MOVLB  1
427E:  MOVF   x3A,W
4280:  SUBWF  x26,W
4282:  BC    42A8
....................                      if( (x_pos_1 < (x_pos_2 + 4)) && (x_pos_1 > (x_pos_2 - 4))){
4284:  MOVLW  04
4286:  ADDWF  x39,W
4288:  SUBWF  x25,W
428A:  BC    42A8
428C:  MOVLW  04
428E:  SUBWF  x39,W
4290:  SUBWF  x25,W
4292:  BZ    42A8
4294:  BNC   42A8
....................                         new_game = 1;
4296:  MOVLB  2
4298:  BSF    x20.3
....................                         mode = 'i';
429A:  MOVLW  69
429C:  MOVWF  x0E
....................                         draw_win(0);
429E:  CLRF   x4F
42A0:  MOVLB  0
42A2:  CALL   22EA
42A6:  MOVLB  1
....................                      }
....................                   }
....................                   break;
42A8:  BRA    42AE
42AA:  MOVLB  0
42AC:  MOVLB  1
....................                }
....................             }
....................             cooldown_2 = 15;
42AE:  MOVLW  0F
42B0:  MOVWF  x46
....................             shoot_2 = 0;
42B2:  BCF    x43.1
....................             last_bullet_x_pos_2 = x_pos_2;
42B4:  MOVFF  139,17E
....................             last_bullet_y_pos_2 = y_pos_2;
42B8:  MOVFF  13A,17F
42BC:  MOVLB  2
.................... 
....................          }
.................... 
....................          
.................... 
....................          
....................          draw_cuadrito(last_x_pos_1, last_y_pos_1, 0);
42BE:  MOVFF  123,24F
42C2:  MOVFF  124,250
42C6:  CLRF   x51
42C8:  MOVLB  0
42CA:  CALL   23E6
....................          draw_cuadrito(x_pos_1, y_pos_1, 1);
42CE:  MOVFF  125,24F
42D2:  MOVFF  126,250
42D6:  MOVLW  01
42D8:  MOVLB  2
42DA:  MOVWF  x51
42DC:  MOVLB  0
42DE:  CALL   23E6
.................... 
....................          last_x_pos_1 = x_pos_1;
42E2:  MOVFF  125,123
....................          last_y_pos_1 = y_pos_1;
42E6:  MOVFF  126,124
.................... 
....................          draw_cuadrito(last_x_pos_2, last_y_pos_2, 0);
42EA:  MOVFF  137,24F
42EE:  MOVFF  138,250
42F2:  MOVLB  2
42F4:  CLRF   x51
42F6:  MOVLB  0
42F8:  CALL   23E6
....................          draw_cuadrito(x_pos_2, y_pos_2, 1);
42FC:  MOVFF  139,24F
4300:  MOVFF  13A,250
4304:  MOVLW  01
4306:  MOVLB  2
4308:  MOVWF  x51
430A:  MOVLB  0
430C:  CALL   23E6
.................... 
....................          last_x_pos_2 = x_pos_2;
4310:  MOVFF  139,137
....................          last_y_pos_2 = y_pos_2;
4314:  MOVFF  13A,138
....................          delay_ms(35);
4318:  MOVLW  23
431A:  MOVLB  2
431C:  MOVWF  x6F
431E:  MOVLB  0
4320:  CALL   05EC
.................... 
....................          if (win)
4324:  MOVLB  2
4326:  BTFSS  x20.0
4328:  BRA    43CE
....................          {
....................             win = 0;
432A:  BCF    x20.0
....................             if (!who)
432C:  BTFSC  x20.1
432E:  BRA    4380
....................             {
....................                glcd_fillScreen(0);
4330:  CLRF   x6E
4332:  MOVLB  0
4334:  CALL   0658
....................                inicio(1);
4338:  MOVLW  01
433A:  MOVLB  2
433C:  MOVWF  x4F
433E:  MOVLB  0
4340:  CALL   0C10
....................                char tewion[] = "GANA 1";
4344:  MOVLW  47
4346:  MOVLB  2
4348:  MOVWF  x41
434A:  MOVLW  41
434C:  MOVWF  x42
434E:  MOVLW  4E
4350:  MOVWF  x43
4352:  MOVLW  41
4354:  MOVWF  x44
4356:  MOVLW  20
4358:  MOVWF  x45
435A:  MOVLW  31
435C:  MOVWF  x46
435E:  CLRF   x47
....................                glcd_text57(22, 50, tewion, 1, 1);
4360:  MOVLW  16
4362:  MOVWF  x75
4364:  MOVLW  32
4366:  MOVWF  x76
4368:  MOVLW  02
436A:  MOVWF  x78
436C:  MOVLW  41
436E:  MOVWF  x77
4370:  MOVLW  01
4372:  MOVWF  x79
4374:  MOVWF  x7A
4376:  MOVLB  0
4378:  CALL   08B4
....................             }
437C:  BRA    43CC
437E:  MOVLB  2
....................             else
....................             {
....................                glcd_fillScreen(0);
4380:  CLRF   x6E
4382:  MOVLB  0
4384:  CALL   0658
....................                inicio(1);
4388:  MOVLW  01
438A:  MOVLB  2
438C:  MOVWF  x4F
438E:  MOVLB  0
4390:  CALL   0C10
....................                char tewion[] = "GANA 2";
4394:  MOVLW  47
4396:  MOVLB  2
4398:  MOVWF  x48
439A:  MOVLW  41
439C:  MOVWF  x49
439E:  MOVLW  4E
43A0:  MOVWF  x4A
43A2:  MOVLW  41
43A4:  MOVWF  x4B
43A6:  MOVLW  20
43A8:  MOVWF  x4C
43AA:  MOVLW  32
43AC:  MOVWF  x4D
43AE:  CLRF   x4E
....................                glcd_text57(22, 50, tewion, 1, 1);
43B0:  MOVLW  16
43B2:  MOVWF  x75
43B4:  MOVLW  32
43B6:  MOVWF  x76
43B8:  MOVLW  02
43BA:  MOVWF  x78
43BC:  MOVLW  48
43BE:  MOVWF  x77
43C0:  MOVLW  01
43C2:  MOVWF  x79
43C4:  MOVWF  x7A
43C6:  MOVLB  0
43C8:  CALL   08B4
43CC:  MOVLB  2
....................             }
....................          }
.................... 
....................          break;
43CE:  BRA    43D4
43D0:  MOVLB  0
....................       }
....................       default:
....................       {
....................          break;
43D2:  MOVLB  2
....................       }
....................       }
.................... 
....................       printf("p");
43D4:  MOVLW  70
43D6:  BTFSS  F9E.4
43D8:  BRA    43D6
43DA:  MOVWF  FAD
43DC:  GOTO   27DA
....................    }
.................... }
.................... 
43E0:  SLEEP 
.................... void glcd_line(int x1, int y1, int x2, int y2, int1 color)
.................... {
....................    signed int x, y, addx, addy, dx, dy;
....................    signed long P;
....................    int i;
....................    dx = abs((signed int)(x2 - x1));
*
0A70:  MOVLB  2
0A72:  MOVF   x75,W
0A74:  SUBWF  x77,W
0A76:  MOVWF  x83
0A78:  MOVF   x83,W
0A7A:  BTFSS  x83.7
0A7C:  BRA    0A84
0A7E:  MOVLW  00
0A80:  BSF    FD8.0
0A82:  SUBFWB x83,W
0A84:  MOVWF  x7E
....................    dy = abs((signed int)(y2 - y1));
0A86:  MOVF   x76,W
0A88:  SUBWF  x78,W
0A8A:  MOVWF  x83
0A8C:  MOVF   x83,W
0A8E:  BTFSS  x83.7
0A90:  BRA    0A98
0A92:  MOVLW  00
0A94:  BSF    FD8.0
0A96:  SUBFWB x83,W
0A98:  MOVWF  x7F
....................    x = x1;
0A9A:  MOVFF  275,27A
....................    y = y1;
0A9E:  MOVFF  276,27B
.................... 
....................    if (x1 > x2)
0AA2:  MOVF   x75,W
0AA4:  SUBWF  x77,W
0AA6:  BC    0AAC
....................       addx = -1;
0AA8:  SETF   x7C
0AAA:  BRA    0AB0
....................    else
....................       addx = 1;
0AAC:  MOVLW  01
0AAE:  MOVWF  x7C
....................    if (y1 > y2)
0AB0:  MOVF   x76,W
0AB2:  SUBWF  x78,W
0AB4:  BC    0ABA
....................       addy = -1;
0AB6:  SETF   x7D
0AB8:  BRA    0ABE
....................    else
....................       addy = 1;
0ABA:  MOVLW  01
0ABC:  MOVWF  x7D
.................... 
....................    if (dx >= dy)
0ABE:  MOVF   x7F,W
0AC0:  XORLW  80
0AC2:  MOVWF  00
0AC4:  MOVF   x7E,W
0AC6:  XORLW  80
0AC8:  SUBWF  00,W
0ACA:  BZ    0ACE
0ACC:  BC    0B6E
....................    {
....................       P = 2 * dy - dx;
0ACE:  MOVLW  02
0AD0:  MOVWF  x84
0AD2:  MOVFF  27F,285
0AD6:  MOVLB  0
0AD8:  RCALL  0A22
0ADA:  MOVLB  2
0ADC:  MOVF   x7E,W
0ADE:  SUBWF  01,W
0AE0:  CLRF   03
0AE2:  BTFSC  FE8.7
0AE4:  DECF   03,F
0AE6:  MOVWF  x80
0AE8:  MOVFF  03,281
.................... 
....................       for (i = 0; i <= dx; ++i)
0AEC:  CLRF   x82
0AEE:  BTFSC  x7E.7
0AF0:  BRA    0B6C
0AF2:  MOVF   x82,W
0AF4:  SUBWF  x7E,W
0AF6:  BNC   0B6C
....................       {
....................          glcd_pixel(x, y, color);
0AF8:  MOVFF  27A,287
0AFC:  MOVFF  27B,288
0B00:  MOVFF  279,289
0B04:  MOVLB  0
0B06:  RCALL  07C8
.................... 
....................          if (P < 0)
0B08:  MOVLB  2
0B0A:  BTFSS  x81.7
0B0C:  BRA    0B30
....................          {
....................             P += 2 * dy;
0B0E:  MOVLW  02
0B10:  MOVWF  x84
0B12:  MOVFF  27F,285
0B16:  MOVLB  0
0B18:  RCALL  0A22
0B1A:  MOVF   01,W
0B1C:  CLRF   03
0B1E:  BTFSC  FE8.7
0B20:  DECF   03,F
0B22:  MOVLB  2
0B24:  ADDWF  x80,F
0B26:  MOVF   03,W
0B28:  ADDWFC x81,F
....................             x += addx;
0B2A:  MOVF   x7C,W
0B2C:  ADDWF  x7A,F
....................          }
0B2E:  BRA    0B68
....................          else
....................          {
....................             P += 2 * dy - 2 * dx;
0B30:  MOVLW  02
0B32:  MOVWF  x84
0B34:  MOVFF  27F,285
0B38:  MOVLB  0
0B3A:  RCALL  0A22
0B3C:  MOVFF  01,283
0B40:  MOVLW  02
0B42:  MOVLB  2
0B44:  MOVWF  x84
0B46:  MOVFF  27E,285
0B4A:  MOVLB  0
0B4C:  RCALL  0A22
0B4E:  MOVF   01,W
0B50:  MOVLB  2
0B52:  SUBWF  x83,W
0B54:  CLRF   03
0B56:  BTFSC  FE8.7
0B58:  DECF   03,F
0B5A:  ADDWF  x80,F
0B5C:  MOVF   03,W
0B5E:  ADDWFC x81,F
....................             x += addx;
0B60:  MOVF   x7C,W
0B62:  ADDWF  x7A,F
....................             y += addy;
0B64:  MOVF   x7D,W
0B66:  ADDWF  x7B,F
....................          }
0B68:  INCF   x82,F
0B6A:  BRA    0AEE
....................       }
....................    }
0B6C:  BRA    0C0C
....................    else
....................    {
....................       P = 2 * dx - dy;
0B6E:  MOVLW  02
0B70:  MOVWF  x84
0B72:  MOVFF  27E,285
0B76:  MOVLB  0
0B78:  RCALL  0A22
0B7A:  MOVLB  2
0B7C:  MOVF   x7F,W
0B7E:  SUBWF  01,W
0B80:  CLRF   03
0B82:  BTFSC  FE8.7
0B84:  DECF   03,F
0B86:  MOVWF  x80
0B88:  MOVFF  03,281
.................... 
....................       for (i = 0; i <= dy; ++i)
0B8C:  CLRF   x82
0B8E:  BTFSC  x7F.7
0B90:  BRA    0C0C
0B92:  MOVF   x82,W
0B94:  SUBWF  x7F,W
0B96:  BNC   0C0C
....................       {
....................          glcd_pixel(x, y, color);
0B98:  MOVFF  27A,287
0B9C:  MOVFF  27B,288
0BA0:  MOVFF  279,289
0BA4:  MOVLB  0
0BA6:  RCALL  07C8
.................... 
....................          if (P < 0)
0BA8:  MOVLB  2
0BAA:  BTFSS  x81.7
0BAC:  BRA    0BD0
....................          {
....................             P += 2 * dx;
0BAE:  MOVLW  02
0BB0:  MOVWF  x84
0BB2:  MOVFF  27E,285
0BB6:  MOVLB  0
0BB8:  RCALL  0A22
0BBA:  MOVF   01,W
0BBC:  CLRF   03
0BBE:  BTFSC  FE8.7
0BC0:  DECF   03,F
0BC2:  MOVLB  2
0BC4:  ADDWF  x80,F
0BC6:  MOVF   03,W
0BC8:  ADDWFC x81,F
....................             y += addy;
0BCA:  MOVF   x7D,W
0BCC:  ADDWF  x7B,F
....................          }
0BCE:  BRA    0C08
....................          else
....................          {
....................             P += 2 * dx - 2 * dy;
0BD0:  MOVLW  02
0BD2:  MOVWF  x84
0BD4:  MOVFF  27E,285
0BD8:  MOVLB  0
0BDA:  RCALL  0A22
0BDC:  MOVFF  01,283
0BE0:  MOVLW  02
0BE2:  MOVLB  2
0BE4:  MOVWF  x84
0BE6:  MOVFF  27F,285
0BEA:  MOVLB  0
0BEC:  RCALL  0A22
0BEE:  MOVF   01,W
0BF0:  MOVLB  2
0BF2:  SUBWF  x83,W
0BF4:  CLRF   03
0BF6:  BTFSC  FE8.7
0BF8:  DECF   03,F
0BFA:  ADDWF  x80,F
0BFC:  MOVF   03,W
0BFE:  ADDWFC x81,F
....................             x += addx;
0C00:  MOVF   x7C,W
0C02:  ADDWF  x7A,F
....................             y += addy;
0C04:  MOVF   x7D,W
0C06:  ADDWF  x7B,F
....................          }
0C08:  INCF   x82,F
0C0A:  BRA    0B8E
....................       }
....................    }
0C0C:  MOVLB  0
0C0E:  RETURN 0
.................... }
.................... void glcd_lineTracing(int *xx, int *yy, int n_points, int1 color)
.................... {
....................    int i;
....................    for (i = 0; i < n_points - 1; i++)
....................    { // Iterate thru all points, drawing a line between each point
....................       glcd_line((xx + i), (yy + i), (xx + i + 1), (yy + i + 1), color);
....................    }
....................    glcd_line((xx + i), (yy + i), (xx), (yy), color);
.................... }
.................... void draw_triangle(int x, int y, float starting_angle, int1 color)
.................... {
....................    int x_points_on_glcd = (int)malloc(3 * sizeof(int));
....................    int y_points_on_glcd = (int)malloc(3 * sizeof(int));
.................... 
....................    for (char i = 0; i < 3; i++)
....................    {
....................       *(x_points_on_glcd + i) = x + (char)((float)5 * cos((float)i * internal_angle - starting_angle));
....................       *(y_points_on_glcd + i) = y + (char)((float)5 * sin((float)i * internal_angle - starting_angle));
....................    }
.................... 
....................    glcd_lineTracing(x_points_on_glcd, y_points_on_glcd, 3, color);
.................... 
....................    free(x_points_on_glcd);
....................    free(y_points_on_glcd);
.................... }
.................... void draw_asteroid(int x, int y, int life, int1 color)
*
1D7A:  MOVLB  2
1D7C:  MOVF   x54,W
1D7E:  MULLW  08
1D80:  MOVF   FF3,W
1D82:  ADDWF  x52,W
1D84:  MOVWF  x56
1D86:  MOVF   x54,W
1D88:  MULLW  08
1D8A:  MOVF   FF3,W
1D8C:  ADDWF  x53,W
1D8E:  MOVWF  x57
.................... {
....................    int x2 = x + life * 8;
....................    int y2 = y + life * 8;
.................... 
....................    if (x2 > 127)
1D90:  MOVF   x56,W
1D92:  SUBLW  7F
1D94:  BTFSC  FD8.0
1D96:  BRA    1F30
....................    {
....................       glcd_line(x, y, 127, y, color);
1D98:  MOVFF  252,275
1D9C:  MOVFF  253,276
1DA0:  MOVLW  7F
1DA2:  MOVWF  x77
1DA4:  MOVFF  253,278
1DA8:  MOVFF  255,279
1DAC:  MOVLB  0
1DAE:  CALL   0A70
....................       glcd_line(0, y, x2 - 127, y, color);
1DB2:  MOVLW  7F
1DB4:  MOVLB  2
1DB6:  SUBWF  x56,W
1DB8:  MOVWF  x58
1DBA:  CLRF   x75
1DBC:  MOVFF  253,276
1DC0:  MOVWF  x77
1DC2:  MOVFF  253,278
1DC6:  MOVFF  255,279
1DCA:  MOVLB  0
1DCC:  CALL   0A70
....................       if (y2 > 63)
1DD0:  MOVLB  2
1DD2:  MOVF   x57,W
1DD4:  SUBLW  3F
1DD6:  BC    1EB6
....................       {
....................          glcd_line(x, y2 - 63, 127, y2 - 63, color);
1DD8:  MOVLW  3F
1DDA:  SUBWF  x57,W
1DDC:  MOVWF  x58
1DDE:  MOVLW  3F
1DE0:  SUBWF  x57,W
1DE2:  MOVWF  x59
1DE4:  MOVFF  252,275
1DE8:  MOVFF  258,276
1DEC:  MOVLW  7F
1DEE:  MOVWF  x77
1DF0:  MOVFF  259,278
1DF4:  MOVFF  255,279
1DF8:  MOVLB  0
1DFA:  CALL   0A70
....................          glcd_line(0, y2 - 63, x2 - 127, y2 - 63, color);
1DFE:  MOVLW  3F
1E00:  MOVLB  2
1E02:  SUBWF  x57,W
1E04:  MOVWF  x58
1E06:  MOVLW  7F
1E08:  SUBWF  x56,W
1E0A:  MOVWF  x59
1E0C:  MOVLW  3F
1E0E:  SUBWF  x57,W
1E10:  MOVWF  x5A
1E12:  CLRF   x75
1E14:  MOVFF  258,276
1E18:  MOVFF  259,277
1E1C:  MOVWF  x78
1E1E:  MOVFF  255,279
1E22:  MOVLB  0
1E24:  CALL   0A70
.................... 
....................          glcd_line(x, y, x, 63, color);
1E28:  MOVFF  252,275
1E2C:  MOVFF  253,276
1E30:  MOVFF  252,277
1E34:  MOVLW  3F
1E36:  MOVLB  2
1E38:  MOVWF  x78
1E3A:  MOVFF  255,279
1E3E:  MOVLB  0
1E40:  CALL   0A70
....................          glcd_line(x, 0, x, y2 - 63, color);
1E44:  MOVLW  3F
1E46:  MOVLB  2
1E48:  SUBWF  x57,W
1E4A:  MOVWF  x58
1E4C:  MOVFF  252,275
1E50:  CLRF   x76
1E52:  MOVFF  252,277
1E56:  MOVWF  x78
1E58:  MOVFF  255,279
1E5C:  MOVLB  0
1E5E:  CALL   0A70
.................... 
....................          glcd_line(x2 - 127, y, x2 - 127, 63, color);
1E62:  MOVLW  7F
1E64:  MOVLB  2
1E66:  SUBWF  x56,W
1E68:  MOVWF  x58
1E6A:  MOVLW  7F
1E6C:  SUBWF  x56,W
1E6E:  MOVWF  x59
1E70:  MOVFF  258,275
1E74:  MOVFF  253,276
1E78:  MOVWF  x77
1E7A:  MOVLW  3F
1E7C:  MOVWF  x78
1E7E:  MOVFF  255,279
1E82:  MOVLB  0
1E84:  CALL   0A70
....................          glcd_line(x2 - 127, 0, x2 - 127, y2 - 63, color);
1E88:  MOVLW  7F
1E8A:  MOVLB  2
1E8C:  SUBWF  x56,W
1E8E:  MOVWF  x58
1E90:  MOVLW  7F
1E92:  SUBWF  x56,W
1E94:  MOVWF  x59
1E96:  MOVLW  3F
1E98:  SUBWF  x57,W
1E9A:  MOVWF  x5A
1E9C:  MOVFF  258,275
1EA0:  CLRF   x76
1EA2:  MOVFF  259,277
1EA6:  MOVWF  x78
1EA8:  MOVFF  255,279
1EAC:  MOVLB  0
1EAE:  CALL   0A70
....................       }
1EB2:  BRA    1F2C
1EB4:  MOVLB  2
....................       else
....................       {
....................          glcd_line(x, y2, 127, y2, color);
1EB6:  MOVFF  252,275
1EBA:  MOVFF  257,276
1EBE:  MOVLW  7F
1EC0:  MOVWF  x77
1EC2:  MOVFF  257,278
1EC6:  MOVFF  255,279
1ECA:  MOVLB  0
1ECC:  CALL   0A70
....................          glcd_line(0, y2, x2 - 127, y2, color);
1ED0:  MOVLW  7F
1ED2:  MOVLB  2
1ED4:  SUBWF  x56,W
1ED6:  MOVWF  x58
1ED8:  CLRF   x75
1EDA:  MOVFF  257,276
1EDE:  MOVWF  x77
1EE0:  MOVFF  257,278
1EE4:  MOVFF  255,279
1EE8:  MOVLB  0
1EEA:  CALL   0A70
.................... 
....................          glcd_line(x, y, x, y2, color);
1EEE:  MOVFF  252,275
1EF2:  MOVFF  253,276
1EF6:  MOVFF  252,277
1EFA:  MOVFF  257,278
1EFE:  MOVFF  255,279
1F02:  CALL   0A70
.................... 
....................          glcd_line(x2 - 127, y, x2 - 127, y2, color);
1F06:  MOVLW  7F
1F08:  MOVLB  2
1F0A:  SUBWF  x56,W
1F0C:  MOVWF  x58
1F0E:  MOVLW  7F
1F10:  SUBWF  x56,W
1F12:  MOVWF  x59
1F14:  MOVFF  258,275
1F18:  MOVFF  253,276
1F1C:  MOVWF  x77
1F1E:  MOVFF  257,278
1F22:  MOVFF  255,279
1F26:  MOVLB  0
1F28:  CALL   0A70
....................       }
....................    }
1F2C:  BRA    2038
1F2E:  MOVLB  2
....................    else
....................    {
....................       glcd_line(x, y, x2, y, color);
1F30:  MOVFF  252,275
1F34:  MOVFF  253,276
1F38:  MOVFF  256,277
1F3C:  MOVFF  253,278
1F40:  MOVFF  255,279
1F44:  MOVLB  0
1F46:  CALL   0A70
....................       if (y2 > 63)
1F4A:  MOVLB  2
1F4C:  MOVF   x57,W
1F4E:  SUBLW  3F
1F50:  BC    1FEE
....................       {
....................          glcd_line(x, y2 - 63, x2, y2 - 63, color);
1F52:  MOVLW  3F
1F54:  SUBWF  x57,W
1F56:  MOVWF  x58
1F58:  MOVLW  3F
1F5A:  SUBWF  x57,W
1F5C:  MOVWF  x59
1F5E:  MOVFF  252,275
1F62:  MOVFF  258,276
1F66:  MOVFF  256,277
1F6A:  MOVWF  x78
1F6C:  MOVFF  255,279
1F70:  MOVLB  0
1F72:  CALL   0A70
.................... 
....................          glcd_line(x, y, x, 63, color);
1F76:  MOVFF  252,275
1F7A:  MOVFF  253,276
1F7E:  MOVFF  252,277
1F82:  MOVLW  3F
1F84:  MOVLB  2
1F86:  MOVWF  x78
1F88:  MOVFF  255,279
1F8C:  MOVLB  0
1F8E:  CALL   0A70
....................          glcd_line(x, 0, x, y2 - 63, color);
1F92:  MOVLW  3F
1F94:  MOVLB  2
1F96:  SUBWF  x57,W
1F98:  MOVWF  x58
1F9A:  MOVFF  252,275
1F9E:  CLRF   x76
1FA0:  MOVFF  252,277
1FA4:  MOVWF  x78
1FA6:  MOVFF  255,279
1FAA:  MOVLB  0
1FAC:  CALL   0A70
.................... 
....................          glcd_line(x2, y, x2, 63, color);
1FB0:  MOVFF  256,275
1FB4:  MOVFF  253,276
1FB8:  MOVFF  256,277
1FBC:  MOVLW  3F
1FBE:  MOVLB  2
1FC0:  MOVWF  x78
1FC2:  MOVFF  255,279
1FC6:  MOVLB  0
1FC8:  CALL   0A70
....................          glcd_line(x2, 0, x2, y2 - 63, color);
1FCC:  MOVLW  3F
1FCE:  MOVLB  2
1FD0:  SUBWF  x57,W
1FD2:  MOVWF  x58
1FD4:  MOVFF  256,275
1FD8:  CLRF   x76
1FDA:  MOVFF  256,277
1FDE:  MOVWF  x78
1FE0:  MOVFF  255,279
1FE4:  MOVLB  0
1FE6:  CALL   0A70
....................       }
1FEA:  BRA    2038
1FEC:  MOVLB  2
....................       else
....................       {
....................          glcd_line(x, y2, x2, y2, color);
1FEE:  MOVFF  252,275
1FF2:  MOVFF  257,276
1FF6:  MOVFF  256,277
1FFA:  MOVFF  257,278
1FFE:  MOVFF  255,279
2002:  MOVLB  0
2004:  CALL   0A70
.................... 
....................          glcd_line(x, y, x, y2, color);
2008:  MOVFF  252,275
200C:  MOVFF  253,276
2010:  MOVFF  252,277
2014:  MOVFF  257,278
2018:  MOVFF  255,279
201C:  CALL   0A70
.................... 
....................          glcd_line(x2, y, x2, y2, color);
2020:  MOVFF  256,275
2024:  MOVFF  253,276
2028:  MOVFF  256,277
202C:  MOVFF  257,278
2030:  MOVFF  255,279
2034:  CALL   0A70
....................       }
....................    }
2038:  RETURN 0
.................... }
.................... 
.................... void glcd_text57(int x, int y, char *textptr, int size, int1 color)
.................... {
.................... 
....................    int i, j, k, l, m; // Loop counters
....................    BYTE pixelData[5]; // Stores character data
.................... 
....................    for (i = 0; textptr[i] != '\0'; ++i, ++x) // Loop through the passed string
*
08B4:  MOVLB  2
08B6:  CLRF   x7B
08B8:  MOVF   x7B,W
08BA:  ADDWF  x77,W
08BC:  MOVWF  FE9
08BE:  MOVLW  00
08C0:  ADDWFC x78,W
08C2:  MOVWF  FEA
08C4:  MOVF   FEF,F
08C6:  BTFSC  FD8.2
08C8:  BRA    0A1E
....................    {
....................       if (textptr[i] < 'S') // Checks if the letter is in the first text array
08CA:  MOVF   x7B,W
08CC:  ADDWF  x77,W
08CE:  MOVWF  FE9
08D0:  MOVLW  00
08D2:  ADDWFC x78,W
08D4:  MOVWF  FEA
08D6:  MOVF   FEF,W
08D8:  SUBLW  52
08DA:  BNC   0920
....................          memcpy(pixelData, TEXT[textptr[i] - ' '], 5);
08DC:  MOVF   x7B,W
08DE:  ADDWF  x77,W
08E0:  MOVWF  FE9
08E2:  MOVLW  00
08E4:  ADDWFC x78,W
08E6:  MOVWF  FEA
08E8:  MOVLW  20
08EA:  SUBWF  FEF,W
08EC:  MULLW  05
08EE:  MOVF   FF3,W
08F0:  CLRF   03
08F2:  MOVWF  x85
08F4:  MOVLW  02
08F6:  MOVWF  FEA
08F8:  MOVLW  80
08FA:  MOVWF  FE9
08FC:  CLRF   x89
08FE:  MOVFF  285,288
0902:  MOVLW  05
0904:  MOVWF  01
0906:  CLRF   FF7
0908:  MOVF   x85,W
090A:  MOVLB  0
090C:  CALL   00AE
0910:  TBLRD*-
0912:  TBLRD*+
0914:  MOVFF  FF5,FEE
0918:  DECFSZ 01,F
091A:  BRA    0912
091C:  BRA    0980
091E:  MOVLB  2
....................       else if (textptr[i] <= '~') // Check if the letter is in the second array
0920:  MOVF   x7B,W
0922:  ADDWF  x77,W
0924:  MOVWF  FE9
0926:  MOVLW  00
0928:  ADDWFC x78,W
092A:  MOVWF  FEA
092C:  MOVF   FEF,W
092E:  SUBLW  7E
0930:  BNC   0974
....................          memcpy(pixelData, TEXT2[textptr[i] - 'S'], 5);
0932:  MOVF   x7B,W
0934:  ADDWF  x77,W
0936:  MOVWF  FE9
0938:  MOVLW  00
093A:  ADDWFC x78,W
093C:  MOVWF  FEA
093E:  MOVLW  53
0940:  SUBWF  FEF,W
0942:  MULLW  05
0944:  MOVF   FF3,W
0946:  CLRF   03
0948:  MOVWF  x85
094A:  MOVLW  02
094C:  MOVWF  FEA
094E:  MOVLW  80
0950:  MOVWF  FE9
0952:  CLRF   x89
0954:  MOVFF  285,288
0958:  MOVLW  05
095A:  MOVWF  01
095C:  CLRF   FF7
095E:  MOVF   x85,W
0960:  MOVLB  0
0962:  RCALL  01BE
0964:  TBLRD*-
0966:  TBLRD*+
0968:  MOVFF  FF5,FEE
096C:  DECFSZ 01,F
096E:  BRA    0966
0970:  BRA    0980
0972:  MOVLB  2
....................       else
....................          memcpy(pixelData, TEXT[0], 5); // Default to space
0974:  CLRF   x80
0976:  CLRF   x81
0978:  CLRF   x82
097A:  CLRF   x83
097C:  CLRF   x84
097E:  MOVLB  0
.................... 
....................       if (x + 5 * size >= GLCD_WIDTH) // Performs character wrapping
0980:  MOVLB  2
0982:  MOVF   x79,W
0984:  MULLW  05
0986:  MOVF   FF3,W
0988:  ADDWF  x75,W
098A:  SUBLW  7F
098C:  BC    099A
....................       {
....................          x = 0;             // Set x at far left position
098E:  CLRF   x75
....................          y += 7 * size + 1; // Set y at next position down
0990:  MOVF   x79,W
0992:  MULLW  07
0994:  MOVF   FF3,W
0996:  ADDLW  01
0998:  ADDWF  x76,F
....................       }
....................       for (j = 0; j < 5; ++j, x += size) // Loop through character byte data
099A:  CLRF   x7C
099C:  MOVF   x7C,W
099E:  SUBLW  04
09A0:  BNC   0A18
....................       {
....................          for (k = 0; k < 7 * size; ++k) // Loop through the vertical pixels
09A2:  CLRF   x7D
09A4:  MOVF   x79,W
09A6:  MULLW  07
09A8:  MOVF   FF3,W
09AA:  SUBWF  x7D,W
09AC:  BC    0A10
....................          {
....................             if (bit_test(pixelData[j], k)) // Check if the pixel should be set
09AE:  CLRF   03
09B0:  MOVF   x7C,W
09B2:  ADDLW  80
09B4:  MOVWF  FE9
09B6:  MOVLW  02
09B8:  ADDWFC 03,W
09BA:  MOVWF  FEA
09BC:  MOVFF  FEF,00
09C0:  MOVF   x7D,W
09C2:  MOVWF  01
09C4:  BZ    09CE
09C6:  BCF    FD8.0
09C8:  RRCF   00,F
09CA:  DECFSZ 01,F
09CC:  BRA    09C6
09CE:  BTFSS  00.0
09D0:  BRA    0A0C
....................             {
....................                for (l = 0; l < size; ++l) // The next two loops change the
09D2:  CLRF   x7E
09D4:  MOVF   x79,W
09D6:  SUBWF  x7E,W
09D8:  BC    0A0C
....................                {                          // character's size
....................                   for (m = 0; m < size; ++m)
09DA:  CLRF   x7F
09DC:  MOVF   x79,W
09DE:  SUBWF  x7F,W
09E0:  BC    0A08
....................                   {
....................                      glcd_pixel(x + m, y + k * size + l, color); // Draws the pixel
09E2:  MOVF   x7F,W
09E4:  ADDWF  x75,W
09E6:  MOVWF  x85
09E8:  MOVF   x7D,W
09EA:  MULWF  x79
09EC:  MOVF   FF3,W
09EE:  ADDWF  x76,W
09F0:  ADDWF  x7E,W
09F2:  MOVWF  x86
09F4:  MOVFF  285,287
09F8:  MOVWF  x88
09FA:  MOVFF  27A,289
09FE:  MOVLB  0
0A00:  RCALL  07C8
0A02:  MOVLB  2
0A04:  INCF   x7F,F
0A06:  BRA    09DC
....................                   }
0A08:  INCF   x7E,F
0A0A:  BRA    09D4
....................                }
....................             }
0A0C:  INCF   x7D,F
0A0E:  BRA    09A4
....................          }
0A10:  INCF   x7C,F
0A12:  MOVF   x79,W
0A14:  ADDWF  x75,F
0A16:  BRA    099C
....................       }
0A18:  INCF   x7B,F
0A1A:  INCF   x75,F
0A1C:  BRA    08B8
....................    }
0A1E:  MOVLB  0
0A20:  RETURN 0
.................... }
.................... 
.................... void inicio(int sec)
.................... {
....................    switch (sec)
*
0C10:  MOVLB  2
0C12:  MOVF   x4F,W
0C14:  XORLW  01
0C16:  MOVLB  0
0C18:  BZ    0C22
0C1A:  XORLW  03
0C1C:  BTFSC  FD8.2
0C1E:  BRA    0D4C
0C20:  BRA    0E76
....................    {
....................    case 1:
....................    {
....................       char text_asteroids[] = "ASTEROIDS";
0C22:  MOVLW  41
0C24:  MOVLB  2
0C26:  MOVWF  x50
0C28:  MOVLW  53
0C2A:  MOVWF  x51
0C2C:  MOVLW  54
0C2E:  MOVWF  x52
0C30:  MOVLW  45
0C32:  MOVWF  x53
0C34:  MOVLW  52
0C36:  MOVWF  x54
0C38:  MOVLW  4F
0C3A:  MOVWF  x55
0C3C:  MOVLW  49
0C3E:  MOVWF  x56
0C40:  MOVLW  44
0C42:  MOVWF  x57
0C44:  MOVLW  53
0C46:  MOVWF  x58
0C48:  CLRF   x59
....................       glcd_text57(38, 4, text_asteroids, 1, 1);
0C4A:  MOVLW  26
0C4C:  MOVWF  x75
0C4E:  MOVLW  04
0C50:  MOVWF  x76
0C52:  MOVLW  02
0C54:  MOVWF  x78
0C56:  MOVLW  50
0C58:  MOVWF  x77
0C5A:  MOVLW  01
0C5C:  MOVWF  x79
0C5E:  MOVWF  x7A
0C60:  MOVLB  0
0C62:  RCALL  08B4
.................... 
....................       for (int i = 0; i < 16; i++)
0C64:  MOVLB  2
0C66:  CLRF   x5A
0C68:  MOVF   x5A,W
0C6A:  SUBLW  0F
0C6C:  BNC   0D48
....................       {
....................          for (int j = 0; j < 16; j++)
0C6E:  CLRF   x5B
0C70:  MOVF   x5B,W
0C72:  SUBLW  0F
0C74:  BNC   0D44
....................          {
....................             if (personaje[j][i] == 1)
0C76:  MOVF   x5B,W
0C78:  MULLW  10
0C7A:  MOVF   FF3,W
0C7C:  CLRF   x76
0C7E:  MOVWF  x75
0C80:  CLRF   03
0C82:  MOVF   x5A,W
0C84:  ADDWF  x75,W
0C86:  MOVWF  01
0C88:  MOVF   x76,W
0C8A:  ADDWFC 03,F
0C8C:  MOVF   01,W
0C8E:  ADDLW  1B
0C90:  MOVWF  FE9
0C92:  MOVLW  00
0C94:  ADDWFC 03,W
0C96:  MOVWF  FEA
0C98:  DECFSZ FEF,W
0C9A:  BRA    0CF0
....................             {
....................                glcd_pixel(20 + i, 26 + j, 0);
0C9C:  MOVLW  14
0C9E:  ADDWF  x5A,W
0CA0:  MOVWF  x75
0CA2:  MOVLW  1A
0CA4:  ADDWF  x5B,W
0CA6:  MOVWF  x76
0CA8:  MOVFF  275,287
0CAC:  MOVWF  x88
0CAE:  CLRF   x89
0CB0:  MOVLB  0
0CB2:  RCALL  07C8
.................... 
....................                glcd_pixel(82 + i, 26 + j, 1);
0CB4:  MOVLW  52
0CB6:  MOVLB  2
0CB8:  ADDWF  x5A,W
0CBA:  MOVWF  x75
0CBC:  MOVLW  1A
0CBE:  ADDWF  x5B,W
0CC0:  MOVWF  x76
0CC2:  MOVFF  275,287
0CC6:  MOVWF  x88
0CC8:  MOVLW  01
0CCA:  MOVWF  x89
0CCC:  MOVLB  0
0CCE:  RCALL  07C8
....................                glcd_pixel(96 + i, 26 + j, 1);
0CD0:  MOVLW  60
0CD2:  MOVLB  2
0CD4:  ADDWF  x5A,W
0CD6:  MOVWF  x75
0CD8:  MOVLW  1A
0CDA:  ADDWF  x5B,W
0CDC:  MOVWF  x76
0CDE:  MOVFF  275,287
0CE2:  MOVWF  x88
0CE4:  MOVLW  01
0CE6:  MOVWF  x89
0CE8:  MOVLB  0
0CEA:  RCALL  07C8
....................             }
0CEC:  BRA    0D3E
0CEE:  MOVLB  2
....................             else
....................             {
....................                glcd_pixel(20 + i, 26 + j, 1);
0CF0:  MOVLW  14
0CF2:  ADDWF  x5A,W
0CF4:  MOVWF  x75
0CF6:  MOVLW  1A
0CF8:  ADDWF  x5B,W
0CFA:  MOVWF  x76
0CFC:  MOVFF  275,287
0D00:  MOVWF  x88
0D02:  MOVLW  01
0D04:  MOVWF  x89
0D06:  MOVLB  0
0D08:  RCALL  07C8
.................... 
....................                glcd_pixel(82 + i, 26 + j, 0);
0D0A:  MOVLW  52
0D0C:  MOVLB  2
0D0E:  ADDWF  x5A,W
0D10:  MOVWF  x75
0D12:  MOVLW  1A
0D14:  ADDWF  x5B,W
0D16:  MOVWF  x76
0D18:  MOVFF  275,287
0D1C:  MOVWF  x88
0D1E:  CLRF   x89
0D20:  MOVLB  0
0D22:  RCALL  07C8
....................                glcd_pixel(96 + i, 26 + j, 0);
0D24:  MOVLW  60
0D26:  MOVLB  2
0D28:  ADDWF  x5A,W
0D2A:  MOVWF  x75
0D2C:  MOVLW  1A
0D2E:  ADDWF  x5B,W
0D30:  MOVWF  x76
0D32:  MOVFF  275,287
0D36:  MOVWF  x88
0D38:  CLRF   x89
0D3A:  MOVLB  0
0D3C:  RCALL  07C8
....................             }
0D3E:  MOVLB  2
0D40:  INCF   x5B,F
0D42:  BRA    0C70
....................          }
0D44:  INCF   x5A,F
0D46:  BRA    0C68
....................       }
....................       break;
0D48:  BRA    0FC4
0D4A:  MOVLB  0
....................    }
....................    case 2:
....................    {
....................       char text_asteroids[] = "ASTEROIDS";
0D4C:  MOVLW  41
0D4E:  MOVLB  2
0D50:  MOVWF  x5C
0D52:  MOVLW  53
0D54:  MOVWF  x5D
0D56:  MOVLW  54
0D58:  MOVWF  x5E
0D5A:  MOVLW  45
0D5C:  MOVWF  x5F
0D5E:  MOVLW  52
0D60:  MOVWF  x60
0D62:  MOVLW  4F
0D64:  MOVWF  x61
0D66:  MOVLW  49
0D68:  MOVWF  x62
0D6A:  MOVLW  44
0D6C:  MOVWF  x63
0D6E:  MOVLW  53
0D70:  MOVWF  x64
0D72:  CLRF   x65
....................       glcd_text57(38, 4, text_asteroids, 1, 1);
0D74:  MOVLW  26
0D76:  MOVWF  x75
0D78:  MOVLW  04
0D7A:  MOVWF  x76
0D7C:  MOVLW  02
0D7E:  MOVWF  x78
0D80:  MOVLW  5C
0D82:  MOVWF  x77
0D84:  MOVLW  01
0D86:  MOVWF  x79
0D88:  MOVWF  x7A
0D8A:  MOVLB  0
0D8C:  RCALL  08B4
.................... 
....................       for (int i = 0; i < 16; i++)
0D8E:  MOVLB  2
0D90:  CLRF   x66
0D92:  MOVF   x66,W
0D94:  SUBLW  0F
0D96:  BNC   0E72
....................       {
....................          for (int j = 0; j < 16; j++)
0D98:  CLRF   x67
0D9A:  MOVF   x67,W
0D9C:  SUBLW  0F
0D9E:  BNC   0E6E
....................          {
....................             if (personaje[j][i] == 1)
0DA0:  MOVF   x67,W
0DA2:  MULLW  10
0DA4:  MOVF   FF3,W
0DA6:  CLRF   x76
0DA8:  MOVWF  x75
0DAA:  CLRF   03
0DAC:  MOVF   x66,W
0DAE:  ADDWF  x75,W
0DB0:  MOVWF  01
0DB2:  MOVF   x76,W
0DB4:  ADDWFC 03,F
0DB6:  MOVF   01,W
0DB8:  ADDLW  1B
0DBA:  MOVWF  FE9
0DBC:  MOVLW  00
0DBE:  ADDWFC 03,W
0DC0:  MOVWF  FEA
0DC2:  DECFSZ FEF,W
0DC4:  BRA    0E18
....................             {
....................                glcd_pixel(20 + i, 26 + j, 1);
0DC6:  MOVLW  14
0DC8:  ADDWF  x66,W
0DCA:  MOVWF  x75
0DCC:  MOVLW  1A
0DCE:  ADDWF  x67,W
0DD0:  MOVWF  x76
0DD2:  MOVFF  275,287
0DD6:  MOVWF  x88
0DD8:  MOVLW  01
0DDA:  MOVWF  x89
0DDC:  MOVLB  0
0DDE:  RCALL  07C8
.................... 
....................                glcd_pixel(82 + i, 26 + j, 0);
0DE0:  MOVLW  52
0DE2:  MOVLB  2
0DE4:  ADDWF  x66,W
0DE6:  MOVWF  x75
0DE8:  MOVLW  1A
0DEA:  ADDWF  x67,W
0DEC:  MOVWF  x76
0DEE:  MOVFF  275,287
0DF2:  MOVWF  x88
0DF4:  CLRF   x89
0DF6:  MOVLB  0
0DF8:  RCALL  07C8
....................                glcd_pixel(96 + i, 26 + j, 0);
0DFA:  MOVLW  60
0DFC:  MOVLB  2
0DFE:  ADDWF  x66,W
0E00:  MOVWF  x75
0E02:  MOVLW  1A
0E04:  ADDWF  x67,W
0E06:  MOVWF  x76
0E08:  MOVFF  275,287
0E0C:  MOVWF  x88
0E0E:  CLRF   x89
0E10:  MOVLB  0
0E12:  RCALL  07C8
....................             }
0E14:  BRA    0E68
0E16:  MOVLB  2
....................             else
....................             {
....................                glcd_pixel(20 + i, 26 + j, 0);
0E18:  MOVLW  14
0E1A:  ADDWF  x66,W
0E1C:  MOVWF  x75
0E1E:  MOVLW  1A
0E20:  ADDWF  x67,W
0E22:  MOVWF  x76
0E24:  MOVFF  275,287
0E28:  MOVWF  x88
0E2A:  CLRF   x89
0E2C:  MOVLB  0
0E2E:  RCALL  07C8
.................... 
....................                glcd_pixel(82 + i, 26 + j, 1);
0E30:  MOVLW  52
0E32:  MOVLB  2
0E34:  ADDWF  x66,W
0E36:  MOVWF  x75
0E38:  MOVLW  1A
0E3A:  ADDWF  x67,W
0E3C:  MOVWF  x76
0E3E:  MOVFF  275,287
0E42:  MOVWF  x88
0E44:  MOVLW  01
0E46:  MOVWF  x89
0E48:  MOVLB  0
0E4A:  RCALL  07C8
....................                glcd_pixel(96 + i, 26 + j, 1);
0E4C:  MOVLW  60
0E4E:  MOVLB  2
0E50:  ADDWF  x66,W
0E52:  MOVWF  x75
0E54:  MOVLW  1A
0E56:  ADDWF  x67,W
0E58:  MOVWF  x76
0E5A:  MOVFF  275,287
0E5E:  MOVWF  x88
0E60:  MOVLW  01
0E62:  MOVWF  x89
0E64:  MOVLB  0
0E66:  RCALL  07C8
....................             }
0E68:  MOVLB  2
0E6A:  INCF   x67,F
0E6C:  BRA    0D9A
....................          }
0E6E:  INCF   x66,F
0E70:  BRA    0D92
....................       }
....................       break;
0E72:  BRA    0FC4
0E74:  MOVLB  0
....................    }
....................    default:
....................    {
....................       for (int i = 2; i < 13; i++)
0E76:  MOVLW  02
0E78:  MOVLB  2
0E7A:  MOVWF  x68
0E7C:  MOVF   x68,W
0E7E:  SUBLW  0C
0E80:  BNC   0EA0
....................       {
....................          glcd_line(32, i, 97, i, 1);
0E82:  MOVLW  20
0E84:  MOVWF  x75
0E86:  MOVFF  268,276
0E8A:  MOVLW  61
0E8C:  MOVWF  x77
0E8E:  MOVFF  268,278
0E92:  MOVLW  01
0E94:  MOVWF  x79
0E96:  MOVLB  0
0E98:  RCALL  0A70
0E9A:  MOVLB  2
0E9C:  INCF   x68,F
0E9E:  BRA    0E7C
....................       }
....................       char text_asteroids[] = "ASTEROIDS";
0EA0:  MOVLW  41
0EA2:  MOVWF  x69
0EA4:  MOVLW  53
0EA6:  MOVWF  x6A
0EA8:  MOVLW  54
0EAA:  MOVWF  x6B
0EAC:  MOVLW  45
0EAE:  MOVWF  x6C
0EB0:  MOVLW  52
0EB2:  MOVWF  x6D
0EB4:  MOVLW  4F
0EB6:  MOVWF  x6E
0EB8:  MOVLW  49
0EBA:  MOVWF  x6F
0EBC:  MOVLW  44
0EBE:  MOVWF  x70
0EC0:  MOVLW  53
0EC2:  MOVWF  x71
0EC4:  CLRF   x72
....................       glcd_text57(38, 4, text_asteroids, 1, 0);
0EC6:  MOVLW  26
0EC8:  MOVWF  x75
0ECA:  MOVLW  04
0ECC:  MOVWF  x76
0ECE:  MOVLW  02
0ED0:  MOVWF  x78
0ED2:  MOVLW  69
0ED4:  MOVWF  x77
0ED6:  MOVLW  01
0ED8:  MOVWF  x79
0EDA:  CLRF   x7A
0EDC:  MOVLB  0
0EDE:  RCALL  08B4
.................... 
....................       for (int i = 0; i < 16; i++)
0EE0:  MOVLB  2
0EE2:  CLRF   x73
0EE4:  MOVF   x73,W
0EE6:  SUBLW  0F
0EE8:  BNC   0FC4
....................       {
....................          for (int j = 0; j < 16; j++)
0EEA:  CLRF   x74
0EEC:  MOVF   x74,W
0EEE:  SUBLW  0F
0EF0:  BNC   0FC0
....................          {
....................             if (personaje[j][i] == 1)
0EF2:  MOVF   x74,W
0EF4:  MULLW  10
0EF6:  MOVF   FF3,W
0EF8:  CLRF   x76
0EFA:  MOVWF  x75
0EFC:  CLRF   03
0EFE:  MOVF   x73,W
0F00:  ADDWF  x75,W
0F02:  MOVWF  01
0F04:  MOVF   x76,W
0F06:  ADDWFC 03,F
0F08:  MOVF   01,W
0F0A:  ADDLW  1B
0F0C:  MOVWF  FE9
0F0E:  MOVLW  00
0F10:  ADDWFC 03,W
0F12:  MOVWF  FEA
0F14:  DECFSZ FEF,W
0F16:  BRA    0F6E
....................             {
....................                glcd_pixel(20 + i, 26 + j, 1);
0F18:  MOVLW  14
0F1A:  ADDWF  x73,W
0F1C:  MOVWF  x75
0F1E:  MOVLW  1A
0F20:  ADDWF  x74,W
0F22:  MOVWF  x76
0F24:  MOVFF  275,287
0F28:  MOVWF  x88
0F2A:  MOVLW  01
0F2C:  MOVWF  x89
0F2E:  MOVLB  0
0F30:  RCALL  07C8
.................... 
....................                glcd_pixel(82 + i, 26 + j, 1);
0F32:  MOVLW  52
0F34:  MOVLB  2
0F36:  ADDWF  x73,W
0F38:  MOVWF  x75
0F3A:  MOVLW  1A
0F3C:  ADDWF  x74,W
0F3E:  MOVWF  x76
0F40:  MOVFF  275,287
0F44:  MOVWF  x88
0F46:  MOVLW  01
0F48:  MOVWF  x89
0F4A:  MOVLB  0
0F4C:  RCALL  07C8
....................                glcd_pixel(96 + i, 26 + j, 1);
0F4E:  MOVLW  60
0F50:  MOVLB  2
0F52:  ADDWF  x73,W
0F54:  MOVWF  x75
0F56:  MOVLW  1A
0F58:  ADDWF  x74,W
0F5A:  MOVWF  x76
0F5C:  MOVFF  275,287
0F60:  MOVWF  x88
0F62:  MOVLW  01
0F64:  MOVWF  x89
0F66:  MOVLB  0
0F68:  RCALL  07C8
....................             }
0F6A:  BRA    0FBA
0F6C:  MOVLB  2
....................             else
....................             {
....................                glcd_pixel(20 + i, 26 + j, 0);
0F6E:  MOVLW  14
0F70:  ADDWF  x73,W
0F72:  MOVWF  x75
0F74:  MOVLW  1A
0F76:  ADDWF  x74,W
0F78:  MOVWF  x76
0F7A:  MOVFF  275,287
0F7E:  MOVWF  x88
0F80:  CLRF   x89
0F82:  MOVLB  0
0F84:  RCALL  07C8
.................... 
....................                glcd_pixel(82 + i, 26 + j, 0);
0F86:  MOVLW  52
0F88:  MOVLB  2
0F8A:  ADDWF  x73,W
0F8C:  MOVWF  x75
0F8E:  MOVLW  1A
0F90:  ADDWF  x74,W
0F92:  MOVWF  x76
0F94:  MOVFF  275,287
0F98:  MOVWF  x88
0F9A:  CLRF   x89
0F9C:  MOVLB  0
0F9E:  RCALL  07C8
....................                glcd_pixel(96 + i, 26 + j, 0);
0FA0:  MOVLW  60
0FA2:  MOVLB  2
0FA4:  ADDWF  x73,W
0FA6:  MOVWF  x75
0FA8:  MOVLW  1A
0FAA:  ADDWF  x74,W
0FAC:  MOVWF  x76
0FAE:  MOVFF  275,287
0FB2:  MOVWF  x88
0FB4:  CLRF   x89
0FB6:  MOVLB  0
0FB8:  RCALL  07C8
....................             }
0FBA:  MOVLB  2
0FBC:  INCF   x74,F
0FBE:  BRA    0EEC
....................          }
0FC0:  INCF   x73,F
0FC2:  BRA    0EE4
....................       }
....................       break;
....................    }
....................    }
0FC4:  MOVLB  0
0FC6:  RETURN 0
.................... }
.................... 
.................... void single_menu(int1 play)
.................... {
....................    char text_ret[] = "RETURN";
0FC8:  MOVLW  52
0FCA:  MOVLB  2
0FCC:  MOVWF  x50
0FCE:  MOVLW  45
0FD0:  MOVWF  x51
0FD2:  MOVLW  54
0FD4:  MOVWF  x52
0FD6:  MOVLW  55
0FD8:  MOVWF  x53
0FDA:  MOVLW  52
0FDC:  MOVWF  x54
0FDE:  MOVLW  4E
0FE0:  MOVWF  x55
0FE2:  CLRF   x56
....................    char text_play[] = "PLAY";
0FE4:  MOVLW  50
0FE6:  MOVWF  x57
0FE8:  MOVLW  4C
0FEA:  MOVWF  x58
0FEC:  MOVLW  41
0FEE:  MOVWF  x59
0FF0:  MOVLW  59
0FF2:  MOVWF  x5A
0FF4:  CLRF   x5B
....................    if (play)
0FF6:  MOVF   x4F,F
0FF8:  BZ    1082
....................    {
....................       for (int i = 29; i <= 41; i++)
0FFA:  MOVLW  1D
0FFC:  MOVWF  x5C
0FFE:  MOVF   x5C,W
1000:  SUBLW  29
1002:  BNC   1022
....................       {
....................          glcd_line(20, i, 90, i, 1);
1004:  MOVLW  14
1006:  MOVWF  x75
1008:  MOVFF  25C,276
100C:  MOVLW  5A
100E:  MOVWF  x77
1010:  MOVFF  25C,278
1014:  MOVLW  01
1016:  MOVWF  x79
1018:  MOVLB  0
101A:  RCALL  0A70
101C:  MOVLB  2
101E:  INCF   x5C,F
1020:  BRA    0FFE
....................       }
....................       glcd_text57(24, 30, text_play, 1, 0);
1022:  MOVLW  18
1024:  MOVWF  x75
1026:  MOVLW  1E
1028:  MOVWF  x76
102A:  MOVLW  02
102C:  MOVWF  x78
102E:  MOVLW  57
1030:  MOVWF  x77
1032:  MOVLW  01
1034:  MOVWF  x79
1036:  CLRF   x7A
1038:  MOVLB  0
103A:  RCALL  08B4
.................... 
....................       for (int i = 43; i <= 55; i++)
103C:  MOVLW  2B
103E:  MOVLB  2
1040:  MOVWF  x5D
1042:  MOVF   x5D,W
1044:  SUBLW  37
1046:  BNC   1064
....................       {
....................          glcd_line(20, i, 90, i, 0);
1048:  MOVLW  14
104A:  MOVWF  x75
104C:  MOVFF  25D,276
1050:  MOVLW  5A
1052:  MOVWF  x77
1054:  MOVFF  25D,278
1058:  CLRF   x79
105A:  MOVLB  0
105C:  RCALL  0A70
105E:  MOVLB  2
1060:  INCF   x5D,F
1062:  BRA    1042
....................       }
....................       glcd_text57(24, 44, text_ret, 1, 1);
1064:  MOVLW  18
1066:  MOVWF  x75
1068:  MOVLW  2C
106A:  MOVWF  x76
106C:  MOVLW  02
106E:  MOVWF  x78
1070:  MOVLW  50
1072:  MOVWF  x77
1074:  MOVLW  01
1076:  MOVWF  x79
1078:  MOVWF  x7A
107A:  MOVLB  0
107C:  RCALL  08B4
....................    }
107E:  BRA    110A
1080:  MOVLB  2
....................    else
....................    {
....................       for (int i = 29; i <= 41; i++)
1082:  MOVLW  1D
1084:  MOVWF  x5E
1086:  MOVF   x5E,W
1088:  SUBLW  29
108A:  BNC   10A8
....................       {
....................          glcd_line(20, i, 90, i, 0);
108C:  MOVLW  14
108E:  MOVWF  x75
1090:  MOVFF  25E,276
1094:  MOVLW  5A
1096:  MOVWF  x77
1098:  MOVFF  25E,278
109C:  CLRF   x79
109E:  MOVLB  0
10A0:  RCALL  0A70
10A2:  MOVLB  2
10A4:  INCF   x5E,F
10A6:  BRA    1086
....................       }
....................       glcd_text57(24, 30, text_play, 1, 1);
10A8:  MOVLW  18
10AA:  MOVWF  x75
10AC:  MOVLW  1E
10AE:  MOVWF  x76
10B0:  MOVLW  02
10B2:  MOVWF  x78
10B4:  MOVLW  57
10B6:  MOVWF  x77
10B8:  MOVLW  01
10BA:  MOVWF  x79
10BC:  MOVWF  x7A
10BE:  MOVLB  0
10C0:  CALL   08B4
.................... 
....................       for (int i = 43; i <= 55; i++)
10C4:  MOVLW  2B
10C6:  MOVLB  2
10C8:  MOVWF  x5F
10CA:  MOVF   x5F,W
10CC:  SUBLW  37
10CE:  BNC   10EE
....................       {
....................          glcd_line(20, i, 90, i, 1);
10D0:  MOVLW  14
10D2:  MOVWF  x75
10D4:  MOVFF  25F,276
10D8:  MOVLW  5A
10DA:  MOVWF  x77
10DC:  MOVFF  25F,278
10E0:  MOVLW  01
10E2:  MOVWF  x79
10E4:  MOVLB  0
10E6:  RCALL  0A70
10E8:  MOVLB  2
10EA:  INCF   x5F,F
10EC:  BRA    10CA
....................       }
....................       glcd_text57(24, 44, text_ret, 1, 0);
10EE:  MOVLW  18
10F0:  MOVWF  x75
10F2:  MOVLW  2C
10F4:  MOVWF  x76
10F6:  MOVLW  02
10F8:  MOVWF  x78
10FA:  MOVLW  50
10FC:  MOVWF  x77
10FE:  MOVLW  01
1100:  MOVWF  x79
1102:  CLRF   x7A
1104:  MOVLB  0
1106:  CALL   08B4
....................    }
110A:  RETURN 0
.................... }
.................... 
.................... void scores(unsigned int16 scr, unsigned int lvl, int1 color)
.................... {
....................    char text_score[6];
....................    sprintf(text_score, "S:%lu", scr);
*
21A4:  MOVLW  02
21A6:  MOVLB  2
21A8:  MOVWF  x1B
21AA:  MOVLW  53
21AC:  MOVWF  x1A
21AE:  MOVWF  x66
21B0:  MOVLB  0
21B2:  RCALL  203A
21B4:  MOVLW  3A
21B6:  MOVLB  2
21B8:  MOVWF  x66
21BA:  MOVLB  0
21BC:  RCALL  203A
21BE:  MOVLW  10
21C0:  MOVWF  FE9
21C2:  MOVFF  250,25E
21C6:  MOVFF  24F,25D
21CA:  BRA    205A
....................    glcd_text57(0, 0, text_score, 1, color);
21CC:  MOVLB  2
21CE:  CLRF   x75
21D0:  CLRF   x76
21D2:  MOVLW  02
21D4:  MOVWF  x78
21D6:  MOVLW  53
21D8:  MOVWF  x77
21DA:  MOVLW  01
21DC:  MOVWF  x79
21DE:  MOVFF  252,27A
21E2:  MOVLB  0
21E4:  CALL   08B4
....................    char text_level[4];
....................    sprintf(text_level, "L:%u", lvl);
21E8:  MOVLW  02
21EA:  MOVLB  2
21EC:  MOVWF  x1B
21EE:  MOVLW  59
21F0:  MOVWF  x1A
21F2:  MOVLW  4C
21F4:  MOVWF  x66
21F6:  MOVLB  0
21F8:  RCALL  203A
21FA:  MOVLW  3A
21FC:  MOVLB  2
21FE:  MOVWF  x66
2200:  MOVLB  0
2202:  RCALL  203A
2204:  MOVFF  251,25D
2208:  MOVLW  1B
220A:  MOVLB  2
220C:  MOVWF  x5E
220E:  MOVLB  0
2210:  BRA    2122
....................    glcd_text57(103, 0, text_level, 1, color);
2212:  MOVLW  67
2214:  MOVLB  2
2216:  MOVWF  x75
2218:  CLRF   x76
221A:  MOVLW  02
221C:  MOVWF  x78
221E:  MOVLW  59
2220:  MOVWF  x77
2222:  MOVLW  01
2224:  MOVWF  x79
2226:  MOVFF  252,27A
222A:  MOVLB  0
222C:  CALL   08B4
2230:  RETURN 0
.................... }
.................... 
.................... float get_ship_angle()
.................... {
....................    if (p1_pot_xx < 80)
*
1622:  MOVLB  2
1624:  MOVF   x14,W
1626:  SUBLW  4F
1628:  BNC   1666
....................    {
....................       if (p1_pot_yy < 80)
162A:  MOVF   x15,W
162C:  SUBLW  4F
162E:  BNC   1640
....................       {
....................          return 225;
1630:  MOVLW  86
1632:  MOVWF  00
1634:  MOVLW  61
1636:  MOVWF  01
1638:  CLRF   02
163A:  CLRF   03
163C:  BRA    16DA
....................       }
163E:  BRA    1664
....................       else if (p1_pot_yy > 170)
1640:  MOVF   x15,W
1642:  SUBLW  AA
1644:  BC    1656
....................       {
....................          return 135;
1646:  MOVLW  86
1648:  MOVWF  00
164A:  MOVLW  07
164C:  MOVWF  01
164E:  CLRF   02
1650:  CLRF   03
1652:  BRA    16DA
....................       }
1654:  BRA    1664
....................       else
....................       {
....................          return 180;
1656:  MOVLW  86
1658:  MOVWF  00
165A:  MOVLW  34
165C:  MOVWF  01
165E:  CLRF   02
1660:  CLRF   03
1662:  BRA    16DA
....................       }
....................    }
1664:  BRA    16DA
....................    else if (p1_pot_xx > 170)
1666:  MOVF   x14,W
1668:  SUBLW  AA
166A:  BC    16A6
....................    {
....................       if (p1_pot_yy < 80)
166C:  MOVF   x15,W
166E:  SUBLW  4F
1670:  BNC   1684
....................       {
....................          return 315;
1672:  MOVLW  87
1674:  MOVWF  00
1676:  MOVLW  1D
1678:  MOVWF  01
167A:  MOVLW  80
167C:  MOVWF  02
167E:  CLRF   03
1680:  BRA    16DA
....................       }
1682:  BRA    16A4
....................       else if (p1_pot_yy > 170)
1684:  MOVF   x15,W
1686:  SUBLW  AA
1688:  BC    169A
....................       {
....................          return 45;
168A:  MOVLW  84
168C:  MOVWF  00
168E:  MOVLW  34
1690:  MOVWF  01
1692:  CLRF   02
1694:  CLRF   03
1696:  BRA    16DA
....................       }
1698:  BRA    16A4
....................       else
....................       {
....................          return 0;
169A:  CLRF   00
169C:  CLRF   01
169E:  CLRF   02
16A0:  CLRF   03
16A2:  BRA    16DA
....................       }
....................    }
16A4:  BRA    16DA
....................    else
....................    {
....................       if (p1_pot_yy < 80)
16A6:  MOVF   x15,W
16A8:  SUBLW  4F
16AA:  BNC   16BC
....................       {
....................          return 270;
16AC:  MOVLW  87
16AE:  MOVWF  00
16B0:  MOVLW  07
16B2:  MOVWF  01
16B4:  CLRF   02
16B6:  CLRF   03
16B8:  BRA    16DA
....................       }
16BA:  BRA    16DA
....................       else if (p1_pot_yy > 170)
16BC:  MOVF   x15,W
16BE:  SUBLW  AA
16C0:  BC    16D2
....................       {
....................          return 180;
16C2:  MOVLW  86
16C4:  MOVWF  00
16C6:  MOVLW  34
16C8:  MOVWF  01
16CA:  CLRF   02
16CC:  CLRF   03
16CE:  BRA    16DA
....................       }
16D0:  BRA    16DA
....................       else
....................       {
....................          return 0;
16D2:  CLRF   00
16D4:  CLRF   01
16D6:  CLRF   02
16D8:  CLRF   03
....................       }
....................    }
16DA:  MOVLB  0
16DC:  GOTO   2B14 (RETURN)
.................... }
.................... float get_x_vel()
.................... {
....................    return (float)((float)p1_pot_x - 127.0f) / 30.0f;
*
17D6:  MOVLB  2
17D8:  CLRF   x86
17DA:  MOVFF  212,285
17DE:  MOVLB  0
17E0:  RCALL  11AE
17E2:  MOVFF  03,252
17E6:  MOVFF  02,251
17EA:  MOVFF  01,250
17EE:  MOVFF  00,24F
17F2:  BSF    FD8.1
17F4:  MOVFF  03,288
17F8:  MOVFF  02,287
17FC:  MOVFF  01,286
1800:  MOVFF  00,285
1804:  MOVLB  2
1806:  CLRF   x8C
1808:  CLRF   x8B
180A:  MOVLW  7E
180C:  MOVWF  x8A
180E:  MOVLW  85
1810:  MOVWF  x89
1812:  MOVLB  0
1814:  RCALL  13AA
1816:  MOVFF  03,252
181A:  MOVFF  02,251
181E:  MOVFF  01,250
1822:  MOVFF  00,24F
1826:  MOVFF  03,25A
182A:  MOVFF  02,259
182E:  MOVFF  01,258
1832:  MOVFF  00,257
1836:  MOVLB  2
1838:  CLRF   x5E
183A:  CLRF   x5D
183C:  MOVLW  70
183E:  MOVWF  x5C
1840:  MOVLW  83
1842:  MOVWF  x5B
1844:  MOVLB  0
1846:  RCALL  11E4
1848:  GOTO   2B94 (RETURN)
.................... }
.................... float get_y_vel()
.................... {
....................    return (float)((float)p1_pot_y - 127.0f) / 30.0f;
184C:  MOVLB  2
184E:  CLRF   x86
1850:  MOVFF  213,285
1854:  MOVLB  0
1856:  RCALL  11AE
1858:  MOVFF  03,252
185C:  MOVFF  02,251
1860:  MOVFF  01,250
1864:  MOVFF  00,24F
1868:  BSF    FD8.1
186A:  MOVFF  03,288
186E:  MOVFF  02,287
1872:  MOVFF  01,286
1876:  MOVFF  00,285
187A:  MOVLB  2
187C:  CLRF   x8C
187E:  CLRF   x8B
1880:  MOVLW  7E
1882:  MOVWF  x8A
1884:  MOVLW  85
1886:  MOVWF  x89
1888:  MOVLB  0
188A:  RCALL  13AA
188C:  MOVFF  03,252
1890:  MOVFF  02,251
1894:  MOVFF  01,250
1898:  MOVFF  00,24F
189C:  MOVFF  03,25A
18A0:  MOVFF  02,259
18A4:  MOVFF  01,258
18A8:  MOVFF  00,257
18AC:  MOVLB  2
18AE:  CLRF   x5E
18B0:  CLRF   x5D
18B2:  MOVLW  70
18B4:  MOVWF  x5C
18B6:  MOVLW  83
18B8:  MOVWF  x5B
18BA:  MOVLB  0
18BC:  RCALL  11E4
18BE:  GOTO   2BA8 (RETURN)
.................... }
.................... 
.................... 
.................... int laser_waza(int x, int y){
....................    if(x > 205){ // derecha
*
22AC:  MOVLB  2
22AE:  MOVF   x4F,W
22B0:  SUBLW  CD
22B2:  BC    22BC
....................       return 2;
22B4:  MOVLW  02
22B6:  MOVWF  01
22B8:  BRA    22E6
....................    }
22BA:  BRA    22C8
....................    else if(x < 50){// izquierda
22BC:  MOVF   x4F,W
22BE:  SUBLW  31
22C0:  BNC   22C8
....................       return 4;
22C2:  MOVLW  04
22C4:  MOVWF  01
22C6:  BRA    22E6
....................    }
....................    if(y > 205){ // arriba
22C8:  MOVF   x50,W
22CA:  SUBLW  CD
22CC:  BC    22D6
....................       return 1;
22CE:  MOVLW  01
22D0:  MOVWF  01
22D2:  BRA    22E6
....................    }
22D4:  BRA    22E2
....................    else if(y < 50){ // abajo
22D6:  MOVF   x50,W
22D8:  SUBLW  31
22DA:  BNC   22E2
....................       return 3;
22DC:  MOVLW  03
22DE:  MOVWF  01
22E0:  BRA    22E6
....................    }
....................    return 0;
22E2:  MOVLW  00
22E4:  MOVWF  01
22E6:  MOVLB  0
22E8:  RETURN 0
.................... }
.................... 
.................... void draw_cuadrito(int x, int y, int1 col)
.................... {
....................    glcd_line(x - 2, y + 2, x + 2, y + 2, col);
*
23E6:  MOVLW  02
23E8:  MOVLB  2
23EA:  SUBWF  x4F,W
23EC:  MOVWF  x52
23EE:  MOVLW  02
23F0:  ADDWF  x50,W
23F2:  MOVWF  x53
23F4:  MOVLW  02
23F6:  ADDWF  x4F,W
23F8:  MOVWF  x54
23FA:  MOVLW  02
23FC:  ADDWF  x50,W
23FE:  MOVWF  x55
2400:  MOVFF  252,275
2404:  MOVFF  253,276
2408:  MOVFF  254,277
240C:  MOVWF  x78
240E:  MOVFF  251,279
2412:  MOVLB  0
2414:  CALL   0A70
....................    glcd_line(x - 2, y - 2, x + 2, y - 2, col);
2418:  MOVLW  02
241A:  MOVLB  2
241C:  SUBWF  x4F,W
241E:  MOVWF  x52
2420:  MOVLW  02
2422:  SUBWF  x50,W
2424:  MOVWF  x53
2426:  MOVLW  02
2428:  ADDWF  x4F,W
242A:  MOVWF  x54
242C:  MOVLW  02
242E:  SUBWF  x50,W
2430:  MOVWF  x55
2432:  MOVFF  252,275
2436:  MOVFF  253,276
243A:  MOVFF  254,277
243E:  MOVWF  x78
2440:  MOVFF  251,279
2444:  MOVLB  0
2446:  CALL   0A70
....................    glcd_line(x - 2, y + 2, x - 2, y - 2, col);
244A:  MOVLW  02
244C:  MOVLB  2
244E:  SUBWF  x4F,W
2450:  MOVWF  x52
2452:  MOVLW  02
2454:  ADDWF  x50,W
2456:  MOVWF  x53
2458:  MOVLW  02
245A:  SUBWF  x4F,W
245C:  MOVWF  x54
245E:  MOVLW  02
2460:  SUBWF  x50,W
2462:  MOVWF  x55
2464:  MOVFF  252,275
2468:  MOVFF  253,276
246C:  MOVFF  254,277
2470:  MOVWF  x78
2472:  MOVFF  251,279
2476:  MOVLB  0
2478:  CALL   0A70
....................    glcd_line(x + 2, y + 2, x + 2, y - 2, col);
247C:  MOVLW  02
247E:  MOVLB  2
2480:  ADDWF  x4F,W
2482:  MOVWF  x52
2484:  MOVLW  02
2486:  ADDWF  x50,W
2488:  MOVWF  x53
248A:  MOVLW  02
248C:  ADDWF  x4F,W
248E:  MOVWF  x54
2490:  MOVLW  02
2492:  SUBWF  x50,W
2494:  MOVWF  x55
2496:  MOVFF  252,275
249A:  MOVFF  253,276
249E:  MOVFF  254,277
24A2:  MOVWF  x78
24A4:  MOVFF  251,279
24A8:  MOVLB  0
24AA:  CALL   0A70
.................... 
....................    glcd_line(x - 4, y + 4, x + 4, y + 4, col);
24AE:  MOVLW  04
24B0:  MOVLB  2
24B2:  SUBWF  x4F,W
24B4:  MOVWF  x52
24B6:  MOVLW  04
24B8:  ADDWF  x50,W
24BA:  MOVWF  x53
24BC:  MOVLW  04
24BE:  ADDWF  x4F,W
24C0:  MOVWF  x54
24C2:  MOVLW  04
24C4:  ADDWF  x50,W
24C6:  MOVWF  x55
24C8:  MOVFF  252,275
24CC:  MOVFF  253,276
24D0:  MOVFF  254,277
24D4:  MOVWF  x78
24D6:  MOVFF  251,279
24DA:  MOVLB  0
24DC:  CALL   0A70
....................    glcd_line(x - 4, y - 4, x + 4, y - 4, col);
24E0:  MOVLW  04
24E2:  MOVLB  2
24E4:  SUBWF  x4F,W
24E6:  MOVWF  x52
24E8:  MOVLW  04
24EA:  SUBWF  x50,W
24EC:  MOVWF  x53
24EE:  MOVLW  04
24F0:  ADDWF  x4F,W
24F2:  MOVWF  x54
24F4:  MOVLW  04
24F6:  SUBWF  x50,W
24F8:  MOVWF  x55
24FA:  MOVFF  252,275
24FE:  MOVFF  253,276
2502:  MOVFF  254,277
2506:  MOVWF  x78
2508:  MOVFF  251,279
250C:  MOVLB  0
250E:  CALL   0A70
....................    glcd_line(x - 4, y + 4, x - 4, y - 4, col);
2512:  MOVLW  04
2514:  MOVLB  2
2516:  SUBWF  x4F,W
2518:  MOVWF  x52
251A:  MOVLW  04
251C:  ADDWF  x50,W
251E:  MOVWF  x53
2520:  MOVLW  04
2522:  SUBWF  x4F,W
2524:  MOVWF  x54
2526:  MOVLW  04
2528:  SUBWF  x50,W
252A:  MOVWF  x55
252C:  MOVFF  252,275
2530:  MOVFF  253,276
2534:  MOVFF  254,277
2538:  MOVWF  x78
253A:  MOVFF  251,279
253E:  MOVLB  0
2540:  CALL   0A70
....................    glcd_line(x + 4, y + 4, x + 4, y - 4, col);
2544:  MOVLW  04
2546:  MOVLB  2
2548:  ADDWF  x4F,W
254A:  MOVWF  x52
254C:  MOVLW  04
254E:  ADDWF  x50,W
2550:  MOVWF  x53
2552:  MOVLW  04
2554:  ADDWF  x4F,W
2556:  MOVWF  x54
2558:  MOVLW  04
255A:  SUBWF  x50,W
255C:  MOVWF  x55
255E:  MOVFF  252,275
2562:  MOVFF  253,276
2566:  MOVFF  254,277
256A:  MOVWF  x78
256C:  MOVFF  251,279
2570:  MOVLB  0
2572:  CALL   0A70
2576:  RETURN 0
.................... }

Configuration Fuses:
   Word  1: CC04   PLL5 CPUDIV1 NOUSBDIV HS FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 0700   CCP2C1 PBADEN LPT1OSC NOMCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
